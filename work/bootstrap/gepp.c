#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmallEiffel The GNU Eiffel Compiler
Release -0.74 Beta #7 (Monday October 1st 2001)
Copyright (C), 1994-2001 - LORIA - UHP - INRIA - FRANCE
Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
http://SmallEiffel.loria.fr
C Compiler options used: -O2 -nologo -D"WIN32" -w
*/
#ifdef __cplusplus
}
#endif
#include "gepp.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/base.c) is included for _all_ modes of 
  compilation (-boost, -no_check, ... -all_check, -debug_check).
*/

/*
  The wrapper for `malloc' (generated C code is supposed to use 
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif SE_NO_CHECK
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use 
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif SE_NO_CHECK
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

int se_cmpT156(T156 o1,T156 o2){
return memcmp(&o1,&o2,sizeof(o1));}
T43 M43={43,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,0,NULL,0,0,0,NULL,0,NULL,0,0,0,0,NULL,0,0,0,0,0,0,0,0,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,0,0,0,0,0,0,0,NULL,0,NULL,NULL,0,NULL,0,0,NULL};
T167 M167={167,NULL};
T95 M95={95};
T172 M172={172,NULL,0,0,0};
T63 M63={63};
T69 M69={69};
T110 M110={110};
T143 M143={143,0,NULL,NULL};
T149 M149={149,0,{NULL,NULL},0,NULL,0};
T83 M83={83,NULL,NULL,NULL};
T60 M60={60,0};
T168 M168={168};
T41 M41={41,NULL};
T23 M23={23,NULL,NULL,NULL};
T176 M176={176};
T166 M166={166,NULL};
T161 M161={161};
T16 M16={16,NULL,NULL,NULL,NULL};
T107 M107={107,NULL,0,0};
T153 M153={153,NULL};
T40 M40={40,0};
T90 M90={90,NULL,0,0};
T94 M94={94,0,NULL,NULL,0};
T154 M154={154,NULL,NULL,0,NULL,{NULL,NULL}};
T7 M7={7,NULL,0,0};
T80 M80={80,NULL,0,0,0,0,0,0,0,0};
T92 M92={92};
T156 M156={NULL,NULL};
T84 M84={84};
T146 M146={146,NULL};
T147 M147={147,NULL};
T76 M76={76,NULL,0,0};
T122 M122={122,NULL,NULL,0,0,0,0,0,0,0,0,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
T148 M148={148};
T79 M79={79,NULL,0,0,0,0,0,0,0,0,0,NULL,0};
T164 M164={164,{NULL,NULL},NULL};
T96 M96={96,{NULL,NULL},NULL};
T162 M162={162};
T125 M125={125};
T86 M86={86,NULL,0,0,0};
T74 M74={74,NULL,0,0};
T65 M65={65,0};
T128 M128={128};
T112 M112={112};
T98 M98={98,{NULL,NULL}};
T106 M106={106,0,0,NULL,NULL};
T174 M174={174,0,NULL,NULL,0,NULL};
T81 M81={81,NULL};
T88 M88={88,NULL};
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/

/*
  This file (SmallEiffel/sys/runtime/boost.c) is automatically included when
  `run_control.boost' is true (ie. only for mode -boost).
*/

void se_print_run_time_stack (void) {
  fprintf(SE_ERR,"Eiffel program crash at run time.\n");
  fprintf(SE_ERR,"No trace when using option \"-boost\"\n");
}

void se_signal_handler(int sig) {
  printf("Received signal %d (man signal).\n",sig);
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
}
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/exception.c) is automatically included 
  when exception handling is used somewhere in the live code.
*/

/*
  Miscellaneous Notes:
  We are currently using the old signal() system call instead of 
  the preferred sigaction() call.  
  
  On Linux systems at least, signal() is implemented using sigaction() 
  so it doesn't really matter.  Need to investigate this on other
  Unix systems.

  James Graves (ansible@xnet.com)
*/

/* 
   Top of the rescue context stack (or NULL if there is no current
   context) :
*/
struct rescue_context *rescue_context_top = NULL;

/* 
   Set to nonzero if the exception was internally generated, as with an
   assertion violation.  It is Os_signal (11) for an OS signal.
*/
int internal_exception_number;
int original_internal_exception_number;

/* 
   Set to nonzero if the exception was a signal (external).  It is 0
   for an internal exception.
*/
int signal_exception_number;

/*
   Used by some internal exceptions to print additional debugging
   information when the exception is not handled and a dump is done.
*/
char *additional_error_message;

static void critical_error_exit(void) {
/* This is called whenever a critical error in the SmallEiffel
   is encountered.  This kind of error cannot be handled by the
   exception handler.
   
   For instance, this routine is called if there is an error in the
   operation of the exception handler routines themselves.
*/
  fprintf(SE_ERR, "There was a critical error in the SmallEiffel runtime.\n");
  exit(EXIT_FAILURE);
}

void setup_signal_handler() {
/*
  Sets up the reception of signals.  If exception handling is enabled
  (by the existance of a rescue clause somewhere), then all OS signals
  now go to exception_handler instead of se_print_run_time_stack().
*/
#ifdef SIG_ERR
/* Check signal() call for errors.  Posix compliant systems should
   define SIG_ERR which is returned by signal() on an error. All Unix 
   signals are included except SIGABRT, SIGKILL and SIGSTOP.  
   
   The other signals SmallEiffel traps for
   other OSs (like SIGBREAK) are not included here, but are below
   in the #else part, for non-Posix systems.
*/

#ifdef SIGHUP
   if ( SIG_ERR == signal( SIGHUP, signal_exception_handler ) ) 
      {
      fprintf(SE_ERR, "Error setting up signal handler for SIGHUP.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGINT
   if ( SIG_ERR == signal( SIGINT, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGINT.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGQUIT
   if ( SIG_ERR == signal( SIGQUIT, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGQUIT.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGILL
   if ( SIG_ERR == signal( SIGILL, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGILL.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGTRAP
   if ( SIG_ERR == signal( SIGTRAP, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGTRAP.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGIOT
   if ( SIG_ERR == signal( SIGIOT, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGIOT.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGBUS
   if ( SIG_ERR == signal( SIGBUS, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGBUS.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGFPE
   if ( SIG_ERR == signal( SIGFPE, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGFPE.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGUSR1
   if ( SIG_ERR == signal( SIGUSR1, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGUSR1.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGSEGV
   if ( SIG_ERR == signal( SIGSEGV, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGSEGV.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGUSR2
   if ( SIG_ERR == signal( SIGUSR2, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGUSR2.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGPIPE
   if ( SIG_ERR == signal( SIGPIPE, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGPIPE.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGALRM
   if ( SIG_ERR == signal( SIGALRM, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGALRM.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGTERM
   if ( SIG_ERR == signal( SIGTERM, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGTERM.\n");
      critical_error_exit();
      }
#endif
       
/* SIGCHLD is ignored, POSIX default action */
       
/* SIGCONT is ignored, POSIX default action */
       
#ifdef SIGTSTP
   if ( SIG_ERR == signal( SIGTSTP, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGTSTP.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGTTIN
   if ( SIG_ERR == signal( SIGTTIN, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGTTIN.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGTTOU
   if ( SIG_ERR == signal( SIGTTOU, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGTTOU.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGURG
   if ( SIG_ERR == signal( SIGURG, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGURG.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGXCPU
   if ( SIG_ERR == signal( SIGXCPU, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGXCPU.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGXFSZ
   if ( SIG_ERR == signal( SIGXFSZ, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGXFSZ.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGVTALRM
   if ( SIG_ERR == signal( SIGVTALRM, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGVTALRM.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGPROF
   if ( SIG_ERR == signal( SIGPROF, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGPROF.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGWINCH
   if ( SIG_ERR == signal( SIGWINCH, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGWINCH.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGIO
   if ( SIG_ERR == signal( SIGIO, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGIO.\n");
      critical_error_exit();
      }
#endif
       
#ifdef SIGPWR
   if ( SIG_ERR == signal( SIGPWR, signal_exception_handler ) ) {
      fprintf(SE_ERR, "Error setting up signal handler for SIGPWR.\n");
      critical_error_exit();
      }
#endif
       
#else   /* SIG_ERR not defined, non-Posix system? */

/* These don't check return code for the signal() OS call.  Bad practice,
   but what can be done?  */

#ifdef SIGBREAK
   /* This signal does not exist on Unix systems. */
   signal( SIGBREAK, signal_exception_handler );
#endif

#ifdef SIGHUP
   signal( SIGHUP, signal_exception_handler );
#endif

#ifdef SIGINT
   signal( SIGINT, signal_exception_handler );
#endif

#ifdef SIGQUIT
   signal( SIGQUIT, signal_exception_handler );
#endif

#ifdef SIGILL
   signal( SIGILL, signal_exception_handler );
#endif

#ifdef SIGTRAP
   signal( SIGTRAP, signal_exception_handler );
#endif

#ifdef SIGIOT
   signal( SIGIOT, signal_exception_handler );
#endif

#ifdef SIGBUS
   signal( SIGBUS, signal_exception_handler );
#endif

#ifdef SIGFPE
   signal( SIGFPE, signal_exception_handler );
#endif

#ifdef SIGUSR1
   signal( SIGUSR1, signal_exception_handler );
#endif

#ifdef SIGSEGV
   signal( SIGSEGV, signal_exception_handler );
#endif

#ifdef SIGUSR2
   signal( SIGUSR2, signal_exception_handler );
#endif

#ifdef SIGPIPE
   signal( SIGPIPE, signal_exception_handler );
#endif

#ifdef SIGALRM
   signal( SIGALRM, signal_exception_handler );
#endif

#ifdef SIGTERM
   signal( SIGTERM, signal_exception_handler );
#endif

#ifdef SIGCHLD
   signal( SIGCHLD, signal_exception_handler );
#endif

#ifdef SIGCONT
   signal( SIGCONT, signal_exception_handler );
#endif

#ifdef SIGSTOP
   /* This should also silently fail on all Unix systems, but it may
      be effective on other OSs. */
   signal( SIGSTOP, signal_exception_handler );
#endif

#ifdef SIGTSTP
   signal( SIGTSTP, signal_exception_handler );
#endif

#ifdef SIGTTIN
   signal( SIGTTIN, signal_exception_handler );
#endif

#ifdef SIGTTOU
   signal( SIGTTOU, signal_exception_handler );
#endif

#ifdef SIGURG
   signal( SIGURG, signal_exception_handler );
#endif

#ifdef SIGXCPU
   signal( SIGXCPU, signal_exception_handler );
#endif

#ifdef SIGXFSZ
   signal( SIGXFSZ, signal_exception_handler );
#endif

#ifdef SIGTALRM
   signal( SIGTALRM, signal_exception_handler );
#endif

#ifdef SIGPROF
   signal( SIGPROF, signal_exception_handler );
#endif

#ifdef SIGWINCH
   signal( SIGWINCH, signal_exception_handler );
#endif

#ifdef SIGIO
   signal( SIGIO, signal_exception_handler );
#endif

#ifdef SIGPWR
   signal( SIGPWR, signal_exception_handler );
#endif

#endif  /* ifdef SIG_ERR */

}

#ifdef SE_NO_CHECK
static void reset_assertion_checking(struct rescue_context * current_context) {
  /* Unwind the dump stack, resetting assertion checking when a rescue
     clause is invoked.  
     This function must be called just before the LONGJMP to the 
     enclosing rescue context.
  */
  while(se_dst!=current_context->top_of_ds){
    if(se_dst->fd!=NULL)se_dst->fd->assertion_flag=1;
    se_dst = se_dst->caller;
  }
}
#endif

void signal_exception_handler(int signal_number) {
  /* Set up to be called whenever an OS signal has been received.
     Checks to see if there is a rescue clause active (somewhere on the
     call stack), and if so, transfer control to that.
  */
  struct rescue_context *current_context;

#ifdef SIG_ERR
  /* some OS implementations automatically block a signal while
   * executing the signal handler, but some do not. */
  if ( SIG_ERR == signal( signal_number, SIG_IGN ) ) {
    fprintf(SE_ERR, "In signal_exception_handler: ");
    fprintf(SE_ERR, "Error turning off signal %d.\n", signal_number );
    critical_error_exit();
  }
#else
  signal( signal_number, SIG_IGN );
#endif

  internal_exception_number = Os_signal;
  original_internal_exception_number = 0;
  signal_exception_number = signal_number;
       
  if ( rescue_context_top != NULL ) {
    current_context = rescue_context_top;
    rescue_context_top = rescue_context_top->next;

    /* now re-enable that signal */
#ifdef SIG_ERR
    if ( SIG_ERR == signal( signal_number, signal_exception_handler ) ) {
      fprintf(SE_ERR, "In signal_exception_handler: ");
      fprintf(SE_ERR, "Error turning on signal %d.\n", signal_number );
      critical_error_exit();
    }
#else
    signal( signal_number, signal_exception_handler );
#endif

#ifdef SE_NO_CHECK
    /* Unwind dump_stack structures PRIOR to jumping :
     */
    reset_assertion_checking(current_context) ;
#endif
    LONGJMP( current_context->jb, internal_exception_number );
  }

  /* No current rescue clause, exit with a dump : */
  print_exception();
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
}

void internal_exception_handler(int exception_number) {
  /* Called whenever an internal (to SmallEiffel) exception is to
     be raised (`raise' feature, assertion violation, etc.).  

     Checks to see if there is a current rescue clause (somewhere 
     in the call stack), and transfers control to it.
     Else exit with a stack trace (if enabled).
  */
  struct rescue_context *current_context;

  /* UNCOMMENT THIS PART TO DEBUG WITH EXCEPTION:
     print_exception(); se_print_run_time_stack();
  */



  /* If this is not a routine failure, clear out old exception
   * information. */
  if ( exception_number != Routine_failure ) {
    internal_exception_number = exception_number;
    original_internal_exception_number = 0;
    signal_exception_number = 0;
  }
  else {
    original_internal_exception_number = internal_exception_number;
  }

  if ( rescue_context_top != NULL ) {
    current_context = rescue_context_top;
    rescue_context_top = rescue_context_top->next;
#ifdef SE_NO_CHECK
    /* Unwind dump_stack structures PRIOR to jumping :
     */
    reset_assertion_checking(current_context) ;
#endif
    LONGJMP( current_context->jb, exception_number );
  }
  
  /* No current rescue clause, exit with a dump : */
  print_exception();
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
}

#ifdef SE_NO_CHECK
static void print_exception_case( int ex_num ) {
  switch( ex_num ) {
  case Check_instruction:
    fprintf(SE_ERR, "Check instruction failed.\n");
    break;
  case Class_invariant:
    fprintf(SE_ERR, "Class invariant not maintained.\n");
    break;
  case Developer_exception:
    fprintf(SE_ERR, "Developer exception:\n");
    break;
  case Incorrect_inspect_value:
    fprintf(SE_ERR, "Incorrect inspect value.\n");
    break;
  case Loop_invariant:
    fprintf(SE_ERR, "Loop invariant failed.\n");
    break;
  case Loop_variant:
    fprintf(SE_ERR, "Loop variant failed to decrease.\n");
    break;
  case No_more_memory:
    fprintf(SE_ERR, "Failed to allocate additional memory.\n");
    break;
  case Postcondition:
    fprintf(SE_ERR, "Postcondition (ensure clause) failed.\n");
    break;
  case Precondition:
    fprintf(SE_ERR, "Precondition (require clause) failed.\n");
    break;
  case Routine_failure:
    fprintf(SE_ERR, "Routine failure.\n");
    break;
  case Os_signal:
    fprintf(SE_ERR, "OS Signal (%d) received.\n", 
	    signal_exception_number );
    break;
  case Void_attached_to_expanded:
    fprintf(SE_ERR, "A Void became attached to an expanded object.\n");
    fprintf(SE_ERR, "Please report this problem to the SmallEiffel team.\n");
    break;
  case Void_call_target:
    fprintf(SE_ERR, "Feature call attempted on a Void reference.\n");
    break;
  case System_level_type_error:
    fprintf(SE_ERR, "System-level type error (probably a bad covariant call).\n");
    break;
  default:
    fprintf(SE_ERR, "There was an unknown exception.\n");
    fprintf(SE_ERR, "Please report this problem to the SmallEiffel team.\n");
  }
}
#endif

void print_exception(void) {
  /* Display some information about last not handled exception. */
#ifdef SE_NO_CHECK
  fprintf(SE_ERR,"Exception number %d not handled.\n",internal_exception_number);
  if ( internal_exception_number == Routine_failure ) {
    fprintf(SE_ERR, "Routine failure.  Original exception: \n");
    print_exception_case( original_internal_exception_number );
  }
  else {
    print_exception_case( internal_exception_number );
  }
  if ( additional_error_message != NULL ) {
    fprintf(SE_ERR, "%s\n", additional_error_message );
  }
#endif
}
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_directory.c) is automatically 
  included when some external "SmallEiffel" feature of class BASIC_DIRECTORY
  is live.
*/

#ifdef WIN32
#define SIMULATED_MODE
/* The simulated mode for WIN32.
*/
typedef struct _SIMULATED_DIR {
  HANDLE handle;
  WIN32_FIND_DATA data;
  int entry_used;
} SIMULATED_DIR;

static SIMULATED_DIR* simulated_opendir(char* path) {
  int len = strlen((char*)path);
  char* pattern = se_malloc(len + 5); 
  SIMULATED_DIR* result = se_malloc(sizeof(SIMULATED_DIR));
  
  pattern = strcpy(pattern,(char*)path);
  if (pattern[len - 1] != '\\') pattern[len++] = '\\';
  pattern[len++] = '*';
  pattern[len++] = '.';
  pattern[len++] = '*';
  pattern[len++] = 0;
  result->handle = FindFirstFile(pattern,&(result->data));
  if (result->handle == INVALID_HANDLE_VALUE) {
    free(pattern);
    free(result);
    return NULL;
  }
  result->entry_used = 0;
  return result;
}

static void* simulated_readdir(SIMULATED_DIR* dirstream) {
  if (dirstream->entry_used) {
    if (FindNextFile(dirstream->handle,&(dirstream->data))) {
      dirstream->entry_used = 1;
      return dirstream;
    }
    else { 
      return NULL;
    }
  }
  else {
    dirstream->entry_used = 1;
    return dirstream;
  }
}

#define simulated_get_entry_name(x) ((x)->data.cFileName)

static int simulated_closedir(SIMULATED_DIR* dirstream) {
  FindClose(dirstream->handle);
  free(dirstream);
  return 0;
}


/* GCC(MingW32) doesn't need these prototypes; whereas, LCC needs them. */
char * getcwd(char* buffer, int maxlen);
int chdir(const char* buffer);
int mkdir(const char* directory_path);
int rmdir(const char* directory_path);


#define simulated_getcwd(x, y) getcwd(x, y)
#define simulated_chdir(x) chdir(x)
#define simulated_rmdir(x) rmdir(x)

int simulated_mkdir(const char* directory_path, int perm) {
   
  mkdir(directory_path);
  return 0;
}

#endif  /* WIN32 */

#ifdef AMIGA
#define SIMULATED_MODE
/* The simulated mode for AmigaOS 2.04+ 
   Author: Thomas Aglassinger <agi@rieska.oulu.fi>

   Normally this shouldn't be necessary as all compilers include a
   simulation of the Un*x directory API. However, they differ in
   certain details, often resulting into compiler errors. Thus a
   implementation using native AmigaDOS calls seems preferable.
 
   Note that many of the happenings below have to deal with the
   various idiosyncracies of the "dos.library", which are not all
   documented clearly in the Autodocs. The biggest surprises should
   be reflected in comments. But consider reading chapter 17 of
   Ralph Babel's "Amiga Guru Book" before changing anything.
*/
#include <exec/types.h>
#include <dos/dos.h>
#include <dos/dostags.h>

#include <proto/exec.h>
#include <proto/dos.h>

typedef struct _SIMULATED_DIR {
  struct FileInfoBlock *info;
  BPTR lock;
} SIMULATED_DIR;


/* Release all resources allocated during `simulated_opendir'; also
   works correctly if structure was only partially initialized.
*/
static void free_simulated_dir(SIMULATED_DIR * dir) {
  if (dir != NULL) {
    if (dir->lock != NULL) {
      UnLock(dir->lock);
    }
    if (dir->info != NULL) {
      FreeDosObject(DOS_FIB, dir->info);
    }
    free(dir);
  }
}

static SIMULATED_DIR * simulated_opendir(char *path) {
  BOOL ok = FALSE;
  SIMULATED_DIR *result = se_malloc(sizeof(SIMULATED_DIR));
  
  if (result != NULL) {
    result->lock = NULL;
    result->info = (struct FileInfoBlock *) AllocDosObject(DOS_FIB, NULL);
    if (result->info != NULL) {
      result->lock = Lock(path, ACCESS_READ);
      if (result->lock != NULL) {
	ok = (Examine(result->lock, result->info) != DOSFALSE);
	if (ok) {
	  /* Ensure we are scanning a directory, not a file */
	  ok = (result->info->fib_DirEntryType >= 0)
	    && (result->info->fib_DirEntryType != ST_SOFTLINK);
	}
      }
    }
  }
  if (!ok) {
    free_simulated_dir(result);
    result = NULL;
  }
  return result;
}

static void * simulated_readdir(SIMULATED_DIR * dirstream) {
  BOOL ok;
  SIMULATED_DIR *result = NULL;
  
  ok = (ExNext(dirstream->lock, dirstream->info) != DOSFALSE);
  
  if (ok) {
    result = dirstream;
  }
  return (void *) result;
}

#define simulated_get_entry_name(entry) ((entry)->info->fib_FileName)

static int simulated_closedir(SIMULATED_DIR * dirstream) {
  free_simulated_dir(dirstream);
  return 0;
}


static EIF_POINTER simulated_getcwd(char *buffer, size_t maximum_length) {
     EIF_POINTER result = NULL;
     BPTR lock = Lock("", ACCESS_READ);
     if (lock != NULL) {
       if (NameFromLock(lock, buffer, maximum_length) != DOSFALSE) {
         result = (EIF_POINTER) buffer;
       }
       UnLock(lock);
     }
     return result;
   }

static int simulated_chdir(char *name) {
  int result = -1;
  BPTR lock = Lock(name, ACCESS_READ);
  if (lock != NULL) {
    /* Change the current working directory (CWD) of the task 
     */
    BPTR old_lock = CurrentDir(lock);
    
    /* Attempt to update internal buffer of the process.
       If we are not running in a process, but a plain task, this
       call does not cause any harm.
    */
    /* FIXME: What's the result of SetCurrentDirName() in a plain
       task? If it is FALSE, the below code won't work. 
    */
    if (SetCurrentDirName(name)) {
      /* If this was successful, unlock `old_lock' because we
	 are not going to restore it later; this routine is one
	 of the few cases where such behavior is appropriate.
      */
      UnLock(old_lock);
      result = 0;
    } 
    else {
      /* If it fails, restore the previous CWD and make the
	 whole routine fail.
      */
      CurrentDir(old_lock);
    }
  }
  return result;
}

static void strip_trailing_slash(char *path, size_t *length, 
				 BOOL * stripped) {
  /* Used in `simulated_mkdir' and `simulated_rmdir' to temporarily
     blank out a possible traling slash (/) in the directory path.
     `restore_trailing_slash' puts it back in place afterwards.
  */
  *length = strlen(path);
  if ((*length > 0) && (path[*length - 1] == '/')) {
    *stripped = TRUE;
    path[*length - 1] = '\0';
  } else {
    *stripped = FALSE;
  }
}

static void restore_trailing_slash(char *path, size_t *length, 
				   BOOL * stripped) {
  if (*stripped) {
    path[*length - 1] = '/';
  }
}

static int simulated_mkdir(char *directory_path, int permission) {
  BPTR lock;
  int result = -1;
  size_t path_length;
  BOOL slash_stripped;
  
  strip_trailing_slash(directory_path, &path_length, &slash_stripped);
  lock = CreateDir(directory_path);
  if (lock != NULL) {
    UnLock(lock);
    result = 0;
  }
  restore_trailing_slash(directory_path, &path_length, &slash_stripped);
  return result;
}

static int simulated_rmdir(char *directory_path) {
  int result = -1;
  size_t path_length;
  BOOL slash_stripped;
  
  strip_trailing_slash(directory_path, &path_length, &slash_stripped);
  if (DeleteFile(directory_path)) {
    result = 0;
  }
  restore_trailing_slash(directory_path, &path_length, &slash_stripped);
  return result;
}
#endif /* AMIGA */

/*--------------------------------------------------------------------
  At his point, either this is a Linux/POSIX platform or some
  SIMULATED_MODE is defined. Unsupported platform should add their own
  SIMULATED_MODE before.
*/

EIF_POINTER basic_directory_open(EIF_POINTER path) {
  /* 
     This is the implementation of the Eiffel external feature 
     `basic_directory_open' from class BASIC_DIRECTORY.
     See Eiffel source file for additional information.
  */
#ifndef SIMULATED_MODE
  return (opendir(((char*) path)));
#else
  return (simulated_opendir(((char*) path)));
#endif
}

EIF_POINTER basic_directory_read_entry(EIF_POINTER dirstream) {
  /* 
     This is the implementation of the Eiffel external feature 
     `basic_directory_read_entry' from class BASIC_DIRECTORY.
     See Eiffel source file for additional information.
  */
#ifndef SIMULATED_MODE
  return readdir((DIR*)dirstream);
#else
  return simulated_readdir((SIMULATED_DIR*)dirstream);
#endif
}

EIF_POINTER basic_directory_get_entry_name(EIF_POINTER entry) {
  /* 
     This is the implementation of the Eiffel external feature 
     `basic_directory_get_entry_name' from class BASIC_DIRECTORY.
     See Eiffel source file for additional information.
  */
#ifndef SIMULATED_MODE
  return (((struct dirent*)entry)->d_name);
#else
  return simulated_get_entry_name((SIMULATED_DIR*)entry);
#endif
}

EIF_BOOLEAN basic_directory_close(EIF_POINTER dirstream) {
  /* 
     This is the implementation of the Eiffel external feature 
     `basic_directory_close' from class BASIC_DIRECTORY.
     See Eiffel source file for additional information.
  */
  int status;
#ifndef SIMULATED_MODE
  status = (closedir((DIR*)dirstream) == 0);
#else
  status = (simulated_closedir((SIMULATED_DIR*)dirstream) == 0);
#endif
  return ((EIF_BOOLEAN)(status ? 1 : 0));
}

EIF_POINTER basic_directory_cwd(void) {
  /* 
     This is the implementation of the Eiffel external feature 
     `basic_directory_current_working_directory' from class BASIC_DIRECTORY.
     See Eiffel source file for additional information.
  */
  static char* buf = NULL;
#ifdef WIN32
  /* MS Windows requires size to be an int; whereas in non-windows systems,
     it needs to be size_t
  */
  static int size = 0;
#else
  static size_t size = 0;
#endif
  int status;
  if (buf == NULL) {
    size = 256;
    buf = (char*)se_malloc(size);
  }
  

#ifndef SIMULATED_MODE
  status = (getcwd(buf,size) != NULL);
#else
  status = (simulated_getcwd(buf,size) != NULL);
#endif


  if (status) {
    return buf;
  }
  else {
    free(buf);
    size = size * 2;
    buf = (char*)se_malloc(size);
    return basic_directory_cwd();
  }
}

EIF_BOOLEAN basic_directory_chdir(EIF_POINTER destination) {
  /* 
     This is the implementation of the Eiffel external feature 
     `basic_directory_chdir' from class BASIC_DIRECTORY.
     See Eiffel source file for additional information.
  */
  int status;
#ifndef SIMULATED_MODE
  status = (chdir((char*)destination));
#else
  status = simulated_chdir((char*)destination);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

EIF_BOOLEAN basic_directory_mkdir(EIF_POINTER directory_path){
  /* 
     This is the implementation of the Eiffel external feature 
     `basic_directory_mkdir' from class BASIC_DIRECTORY.
     See Eiffel source file for additional information.
  */
  int status;
#ifndef SIMULATED_MODE
  status = (mkdir((char*)directory_path,0777));
#else
  status = simulated_mkdir((char*)directory_path,0777);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

EIF_BOOLEAN basic_directory_rmdir(EIF_POINTER directory_path){
  /* 
     This is the implementation of the Eiffel external feature 
     `basic_directory_rmdir' from class BASIC_DIRECTORY.
     See Eiffel source file for additional information.
  */
  int status;
#ifndef SIMULATED_MODE
  status = rmdir((char*)directory_path);
#else
  status = simulated_rmdir((char*)directory_path);
#endif
  return ((EIF_BOOLEAN)(status == 0 ? 1 : 0));
}

/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_getenv.c) is automatically 
  included when the GENERAL.basic_getenv feature is used (ie. in live code).
*/

EIF_POINTER basic_getenv(EIF_POINTER name) {

  return ((EIF_POINTER)(getenv((char*)name)));
}

T6 r8is_null(T8 C){
T6 R=0;
R=!((NULL!=C));
return R;
}

T6 r6_ix_not(T6 C){
T6 R=0;
/*[IF*/
if(C){
}
else{
R=1;
}
/*FI]*/
return R;
}

T6 r6_px_or(T6 C,T6 a1){
T6 R=0;
R=(C)||(a1);
return R;
}

T6 r6_px_and(T6 C,T6 a1){
T6 R=0;
R=(C)&&(a1);
return R;
}

T6 r3_px_6061(T3 C,T3 a1){
T6 R=0;
R=(T3code(C))<=(T3code(a1));
return R;
}

T6 r3is_digit(T3 C){
T6 R=0;
/*[IF*/
if((((unsigned)(C))>=((unsigned)(((T3)'0'))))){
R=(((unsigned)(C))<=((unsigned)(((T3)'9'))));
}
/*FI]*/
return R;
}

T6 r3is_separator(T3 C){
T6 R=0;
/*[INSPECT*/
{int z1=C;
switch(z1){
case 0:
case 9:
case 10:
case 12:
case 13:
case 32:
R=1;
break;
}
}/*INSPECT]*/
return R;
}

T6 r3_px_6261(T3 C,T3 a1){
T6 R=0;
R=(T3code(C))>=(T3code(a1));
return R;
}

T2 r3value(T3 C){
T2 R=0;
R=(T3code(C))-(48);
return R;
}

T2 r3decimal_value(T3 C){
T2 R=0;
R=(T3code(C))-(48);
return R;
}

T0* r2out(T2 C){
T0* R=NULL;
/*[IRF3.3clear*/((((T7*)((T7*)(oBC1tagged_out_memory))))->_count/*8*/)=(0);
/*]*/
/*[IRF3.6out_in_tagged_out_memory*/{T2 C1=C;
r2append_in(C1,oBC1tagged_out_memory);
}/*]*/
R=r7twin((T7*)(oBC1tagged_out_memory));
return R;
}

T2 r2max(T2 C,T2 a1){
T2 R=0;
/*[IF*/
if((a1)<(C)){
R=C;
}
else{
R=a1;
}
/*FI]*/
return R;
}

T2 r2min(T2 C,T2 a1){
T2 R=0;
/*[IF*/
if((C)<(a1)){
R=C;
}
else{
R=a1;
}
/*FI]*/
return R;
}

T3 r2digit(T2 C){
T3 R=0;
R=((T3)((C)+(T3code(((T3)'0')))));
return R;
}

void r2append_in(T2 C,T0* a1){
T2 _val=0;
T2 _i=0;
/*[IF*/
if((C)==(0)){
r7extend(((T7*)a1),((T3)'0'));
}
else{
/*[IF*/
if((C)>(0)){
_i=((/*RF2*/(((T7*)a1))->_count/*8*/))+(1);
_val=C;
while (!((_val)==(0)))
{
r7extend(((T7*)a1),r2digit((_val)%(10)));
_val=(_val)/(10);
}
}
else{
r7extend(((T7*)a1),((T3)'\55'));
_i=((/*RF2*/(((T7*)a1))->_count/*8*/))+(1);
_val=C;
while (!((_val)==(0)))
{
r7extend(((T7*)a1),r2digit(-((_val)%(10))));
_val=(_val)/(10);
}
}
/*FI]*/
_val=(/*RF2*/(((T7*)a1))->_count/*8*/);
while (!((_i)>=(_val)))
{
r7swap(((T7*)a1),_i,_val);
_val=(_val)-(1);
_i=(_i)+(1);
}
}
/*FI]*/
}
T0*oBC1tagged_out_memory=NULL;

void r109clear_all(T109 C,T2 a1){
T0* _v=NULL;
T2 _i=0;
_i=a1;
while (!((_i)<(0)))
{
(C)[_i]=(_v);
_i=(_i)-(1);
}
}

T109 r109realloc(T109 C,T2 a1,T2 a2){
T109 R=NULL;
R=((T109)(se_calloc(a2,sizeof(T0*))));
r109copy_from(R,C,(a1)-(1));
return R;
}

void r109set_all_with(T109 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r109clear(T109 C,T2 a1,T2 a2){
T0* _v=NULL;
T2 _i=0;
_i=a1;
while (!((_i)>(a2)))
{
(C)[_i]=(_v);
_i=(_i)+(1);
}
}

void r109copy_from(T109 C,T109 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r87clear_all(T87 C,T2 a1){
T0* _v=NULL;
T2 _i=0;
_i=a1;
while (!((_i)<(0)))
{
(C)[_i]=(_v);
_i=(_i)-(1);
}
}

T87 r87realloc(T87 C,T2 a1,T2 a2){
T87 R=NULL;
R=((T87)(se_calloc(a2,sizeof(T0*))));
r87copy_from(R,C,(a1)-(1));
return R;
}

void r87move(T87 C,T2 a1,T2 a2,T2 a3){
T2 _i=0;
/*[IF*/
if((a3)==(0)){
}
 else if((a3)<(0)){
_i=a1;
while (!((_i)>(a2)))
{
(C)[(_i)+(a3)]=((C)[_i]);
_i=(_i)+(1);
}
}
else{
_i=a2;
while (!((_i)<(a1)))
{
(C)[(_i)+(a3)]=((C)[_i]);
_i=(_i)-(1);
}
}
/*FI]*/
}

void r87set_all_with(T87 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r87clear(T87 C,T2 a1,T2 a2){
T0* _v=NULL;
T2 _i=0;
_i=a1;
while (!((_i)>(a2)))
{
(C)[_i]=(_v);
_i=(_i)+(1);
}
}

void r87copy_from(T87 C,T87 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r9copy_slice(T9 C,T2 a1,T9 a2,T2 a3,T2 a4){
T2 _i1=0;
T2 _i2=0;
_i1=a1;
_i2=a3;
while (!((_i2)>(a4)))
{
(C)[_i1]=((a2)[_i2]);
_i2=(_i2)+(1);
_i1=(_i1)+(1);
}
}

T9 r9realloc(T9 C,T2 a1,T2 a2){
T9 R=NULL;
R=((T9)(se_calloc(a2,sizeof(T3))));
r9copy_from(R,C,(a1)-(1));
return R;
}

void r9set_all_with(T9 C,T3 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

T6 r9fast_memcmp(T9 C,T9 a1,T2 a2){
T6 R=0;
T2 _i=0;
_i=(a2)-(1);
while (!(((_i)<(0))||(((C)[_i])!=((a1)[_i]))))
{
_i=(_i)-(1);
}
R=(_i)<(0);
return R;
}

void r9copy_at(T9 C,T2 a1,T9 a2,T2 a3){
T2 _at_idx=0;
T2 _src_idx=0;
_src_idx=(a3)-(1);
_at_idx=(a1)+(_src_idx);
while (!((_src_idx)<(0)))
{
(C)[_at_idx]=((a2)[_src_idx]);
_src_idx=(_src_idx)-(1);
_at_idx=(_at_idx)-(1);
}
}

void r9copy_from(T9 C,T9 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r78clear_all(T78 C,T2 a1){
T2 _v=0;
T2 _i=0;
_i=a1;
while (!((_i)<(0)))
{
(C)[_i]=(_v);
_i=(_i)-(1);
}
}

T78 r78realloc(T78 C,T2 a1,T2 a2){
T78 R=NULL;
R=((T78)(se_calloc(a2,sizeof(T2))));
r78copy_from(R,C,(a1)-(1));
return R;
}

void r78set_all_with(T78 C,T2 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r78clear(T78 C,T2 a1,T2 a2){
T2 _v=0;
T2 _i=0;
_i=a1;
while (!((_i)>(a2)))
{
(C)[_i]=(_v);
_i=(_i)+(1);
}
}

void r78copy_from(T78 C,T78 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r75clear_all(T75 C,T2 a1){
T0* _v=NULL;
T2 _i=0;
_i=a1;
while (!((_i)<(0)))
{
(C)[_i]=(_v);
_i=(_i)-(1);
}
}

T75 r75realloc(T75 C,T2 a1,T2 a2){
T75 R=NULL;
R=((T75)(se_calloc(a2,sizeof(T0*))));
r75copy_from(R,C,(a1)-(1));
return R;
}

void r75set_all_with(T75 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r75clear(T75 C,T2 a1,T2 a2){
T0* _v=NULL;
T2 _i=0;
_i=a1;
while (!((_i)>(a2)))
{
(C)[_i]=(_v);
_i=(_i)+(1);
}
}

void r75copy_from(T75 C,T75 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r7copy(T7* C,T0* a1){
T2 _c=0;
_c=(/*RF2*/(((T7*)a1))->_count/*8*/);
/*[IF*/
if((_c)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))<(_c)){
(/*SFN*/C->_storage/*4*/)=((T9)(se_calloc(_c,sizeof(T3))));
(/*SFN*/C->_capacity/*12*/)=_c;
}
/*FI]*/
r9copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),(_c)-(1));
}
/*FI]*/
(/*SFN*/C->_count/*8*/)=_c;
}

T0* r7substring(T7* C,T2 a1,T2 a2){
T0* R=NULL;
T2 _c=0;
_c=((a2)-(a1))+(1);
{T7*n=((T7*)se_malloc(sizeof(*n))/*16*/);
*n=M7;
r7make(n,_c);
R=((T0*)n);
}
/*[IRF3.3set_count*/((((T7*)(((T7*)R))))->_count/*8*/)=(_c);
/*]*/
r9copy_slice((/*RF2*/(((T7*)R))->_storage/*4*/),0,(/*RF2*/(C)->_storage/*4*/),(a1)-(1),(a2)-(1));
return R;
}

T6 r7is_equal(T7* C,T0* a1){
T6 R=0;
/*[IF*/
if(((/*RF2*/(C)->_count/*8*/))==((/*RF2*/(((T7*)a1))->_count/*8*/))){
R=r9fast_memcmp((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),(/*RF2*/(C)->_count/*8*/));
}
/*FI]*/
return R;
}

T6 r7is_integer(T7* C){
T6 R=0;
T2 _i=0;
T2 _state=0;
T2 _value=0;
T6 _negative=0;
T3 _cc=0;
_i=1;
while (!(((_state)==(4))||((_i)>((/*RF2*/(C)->_count/*8*/)))))
{
_cc=/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[INSPECT*/
{int z1=_state;
switch(z1){
case 0:
/*[IF*/
if(r3is_separator(_cc)){
}
 else if((_cc)==(((T3)'\53'))){
_state=1;
}
 else if((_cc)==(((T3)'\55'))){
_negative=1;
_state=1;
}
 else if(r3is_digit(_cc)){
_value=r3decimal_value(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/);
_state=2;
}
else{
_state=4;
}
/*FI]*/
break;
case 1:
/*[IF*/
if(r3is_digit(_cc)){
_value=r3decimal_value(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/);
/*[IF*/
if(_negative){
_value=(-(1))*(_value);
}
/*FI]*/
_state=2;
}
else{
_state=4;
}
/*FI]*/
break;
case 2:
/*[IF*/
if(r3is_digit(_cc)){
/*[IF*/
if(_negative){
_value=((10)*(_value))-(r3decimal_value(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/));
}
else{
_value=((10)*(_value))+(r3decimal_value(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/));
}
/*FI]*/
/*[IF*/
if(((_negative)&&((_value)>(0)))||((!(_negative))&&((_value)<(0)))){
_state=4;
}
/*FI]*/
}
 else if(r3is_separator(_cc)){
_state=3;
}
else{
_state=4;
}
/*FI]*/
break;
default:;
/*[IF*/
if(r3is_separator(_cc)){
}
else{
_state=4;
}
/*FI]*/
}
}/*INSPECT]*/
_i=(_i)+(1);
}
/*[IF*/
if(((_state)!=(0))&&((_state)!=(4))){
R=1;
}
/*FI]*/
return R;
}

void r7make(T7* C,T2 a1){
/*[IF*/
if((a1)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))<(a1)){
(/*SFN*/C->_storage/*4*/)=((T9)(se_calloc(a1,sizeof(T3))));
(/*SFN*/C->_capacity/*12*/)=a1;
}
/*FI]*/
}
/*FI]*/
(/*SFN*/C->_count/*8*/)=0;
}

void r7append_string(T7* C,T0* a1){
T2 _s_count=0;
T2 _needed_capacity=0;
T2 _new_capacity=0;
_s_count=(/*RF2*/(((T7*)a1))->_count/*8*/);
_needed_capacity=((/*RF2*/(C)->_count/*8*/))+(_s_count);
/*[IF*/
if((_needed_capacity)>((/*RF2*/(C)->_capacity/*12*/))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
(/*SFN*/C->_storage/*4*/)=((T9)(se_calloc(_needed_capacity,sizeof(T3))));
(/*SFN*/C->_capacity/*12*/)=_needed_capacity;
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
/*[IF*/
if((_needed_capacity)>(_new_capacity)){
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_needed_capacity);
(/*SFN*/C->_capacity/*12*/)=_needed_capacity;
}
else{
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
r9copy_at((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_count/*8*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),_s_count);
(/*SFN*/C->_count/*8*/)=_needed_capacity;
}

void r7make_filled(T7* C,T3 a1,T2 a2){
r7make(C,a2);
(/*SFN*/C->_count/*8*/)=a2;
/*[IRF3.6fill_with*/{T7* C1=C;
T3 b1=a1;
r9set_all_with((/*RF2*/(C1)->_storage/*4*/),b1,((/*RF2*/(C1)->_count/*8*/))-(1));
}/*]*/
}

void r7extend(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
_new_capacity=32;
(/*SFN*/C->_storage/*4*/)=((T9)(se_calloc(_new_capacity,sizeof(T3))));
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}

T2 r7hash_code(T7* C){
T2 R=0;
T2 _i=0;
T2 _j=0;
_j=(/*RF2*/(C)->_count/*8*/);
_i=1;
while (!((_j)<=(0)))
{
R=((5)*(R))+(T3code(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/));
_i=(_i)+(1);
_j=(_j)-(1);
}
/*[IF*/
if((R)<(0)){
R=-((R)+(1));
}
/*FI]*/
return R;
}

T2 r7to_integer(T7* C){
T2 R=0;
T2 _i=0;
T2 _state=0;
T3 _cc=0;
T6 _negative=0;
_i=1;
while (!((_i)>((/*RF2*/(C)->_count/*8*/))))
{
_cc=/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[INSPECT*/
{int z1=_state;
switch(z1){
case 0:
/*[IF*/
if(r3is_separator(_cc)){
}
 else if((_cc)==(((T3)'\53'))){
_state=1;
}
 else if((_cc)==(((T3)'\55'))){
_negative=1;
_state=1;
}
else{
R=r3value(_cc);
_state=2;
}
/*FI]*/
break;
case 1:
R=r3value(_cc);
/*[IF*/
if(_negative){
R=(-(1))*(R);
}
/*FI]*/
_state=2;
break;
case 2:
/*[IF*/
if(r3is_digit(_cc)){
/*[IF*/
if(_negative){
R=((10)*(R))-(r3decimal_value(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/));
}
else{
R=((10)*(R))+(r3decimal_value(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/));
}
/*FI]*/
}
else{
_state=3;
}
/*FI]*/
break;
default:;
_i=(/*RF2*/(C)->_count/*8*/);
}
}/*INSPECT]*/
_i=(_i)+(1);
}
return R;
}

void r7append_character(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
_new_capacity=32;
(/*SFN*/C->_storage/*4*/)=((T9)(se_calloc(_new_capacity,sizeof(T3))));
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}

void r7from_external_copy(T7* C,T8 a1){
T9 _s=NULL;
T2 _i=0;
_s=a1;
(/*SFN*/C->_count/*8*/)=0;
while (!(((_s)[_i])==(((T3)'\0'))))
{
r7append_character(C,(_s)[_i]);
_i=(_i)+(1);
}
}

T8 r7to_external(T7* C){
T8 R=NULL;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
/*[IF*/
if((/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[((/*RF2*/(C)->_count/*8*/))-(1)]/*)*/)!=(((T3)'\0'))){
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[((/*RF2*/(C)->_count/*8*/))-(1)]=(((T3)'\0'));
/*]*/
}
/*FI]*/
}
else{
r7append_character(C,((T3)'\0'));
}
/*FI]*/
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))-(1);
R=((void*)((/*RF2*/(C)->_storage/*4*/)));
return R;
}

T0* r7twin(T7* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T7*)R)=M7;
r7copy(((T7*)R),((T0*)C));
return R;
}

void r7swap(T7* C,T2 a1,T2 a2){
T3 _tmp=0;
_tmp=/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(a1)-(1)]/*)*/;
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[(a1)-(1)]=(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(a2)-(1)]/*)*/);
/*]*/
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[(a2)-(1)]=(_tmp);
/*]*/
}

void r172copy(T172* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T172*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T172*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=((T78)(se_calloc(_needed_capacity,sizeof(T2))));
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r78copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T172*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

T2 r172count(T172* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}

T2 r172item(T172* C,T2 a1){
T2 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

T0* r172twin(T172* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T172*)R)=M172;
r172copy(((T172*)R),((T0*)C));
return R;
}

void r107copy(T107* C,T0* a1){
T2 _other_upper=0;
T2 _new_capacity=0;
_other_upper=(/*RF2*/(((T107*)a1))->_upper/*12*/);
/*[IF*/
if((_other_upper)>=(0)){
_new_capacity=(_other_upper)+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_new_capacity)){
(/*SFN*/C->_storage/*4*/)=((T109)(se_calloc(_new_capacity,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
}
 else if(((/*RF2*/(C)->_capacity/*8*/))>(0)){
r109clear_all((/*RF2*/(C)->_storage/*4*/),((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
r109copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T107*)a1))->_storage/*4*/),_other_upper);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))>(0)){
r109clear_all((/*RF2*/(C)->_storage/*4*/),((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=_other_upper;
}

void r107make(T107* C,T2 a1){
/*[IF*/
if((a1)==(0)){
/*[IF*/
if((((/*RF2*/(C)->_capacity/*8*/))>(0))&&(((/*RF2*/(C)->_upper/*12*/))>=(0))){
r109clear((/*RF2*/(C)->_storage/*4*/),0,(/*RF2*/(C)->_upper/*12*/));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=-(1);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
(/*SFN*/C->_storage/*4*/)=((T109)(se_calloc(a1,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=a1;
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))<(a1)){
(/*SFN*/C->_storage/*4*/)=((T109)(se_calloc(a1,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=a1;
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
else{
r109clear((/*RF2*/(C)->_storage/*4*/),0,(/*RF2*/(C)->_upper/*12*/));
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
/*FI]*/
}

void r107resize(T107* C,T2 a1){
T2 _new_capacity=0;
/*[IF*/
if((a1)>(/*(IRF4.6count*/((/*RF2*/(C)->_upper/*12*/))+(1)/*)*/)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
(/*SFN*/C->_storage/*4*/)=((T109)(se_calloc(a1,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=a1;
}
 else if(((/*RF2*/(C)->_capacity/*8*/))<(a1)){
_new_capacity=((/*RF2*/(C)->_capacity/*8*/))*(2);
while (!((_new_capacity)>=(a1)))
{
_new_capacity=(_new_capacity)*(2);
}
(/*SFN*/C->_storage/*4*/)=r109realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*8*/),_new_capacity);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
}
/*FI]*/
}
 else if((a1)!=(/*(IRF4.6count*/((/*RF2*/(C)->_upper/*12*/))+(1)/*)*/)){
r109clear((/*RF2*/(C)->_storage/*4*/),a1,(/*(IRF4.6count*/((/*RF2*/(C)->_upper/*12*/))+(1)/*)*/)-(1));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}

T0* r107twin(T107* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T107*)R)=M107;
r107copy(((T107*)R),((T0*)C));
return R;
}

void r90copy(T90* C,T0* a1){
T2 _other_upper=0;
T2 _new_capacity=0;
_other_upper=(/*RF2*/(((T90*)a1))->_upper/*12*/);
/*[IF*/
if((_other_upper)>=(0)){
_new_capacity=(_other_upper)+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_new_capacity)){
(/*SFN*/C->_storage/*4*/)=((T87)(se_calloc(_new_capacity,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
}
 else if(((/*RF2*/(C)->_capacity/*8*/))>(0)){
r87clear_all((/*RF2*/(C)->_storage/*4*/),((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
r87copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T90*)a1))->_storage/*4*/),_other_upper);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))>(0)){
r87clear_all((/*RF2*/(C)->_storage/*4*/),((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=_other_upper;
}

void r90make(T90* C,T2 a1){
/*[IF*/
if((a1)==(0)){
/*[IF*/
if((((/*RF2*/(C)->_capacity/*8*/))>(0))&&(((/*RF2*/(C)->_upper/*12*/))>=(0))){
r87clear((/*RF2*/(C)->_storage/*4*/),0,(/*RF2*/(C)->_upper/*12*/));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=-(1);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
(/*SFN*/C->_storage/*4*/)=((T87)(se_calloc(a1,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=a1;
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))<(a1)){
(/*SFN*/C->_storage/*4*/)=((T87)(se_calloc(a1,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=a1;
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
else{
r87clear((/*RF2*/(C)->_storage/*4*/),0,(/*RF2*/(C)->_upper/*12*/));
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
/*FI]*/
}

void r90resize(T90* C,T2 a1){
T2 _new_capacity=0;
/*[IF*/
if((a1)>(/*(IRF4.6count*/((/*RF2*/(C)->_upper/*12*/))+(1)/*)*/)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
(/*SFN*/C->_storage/*4*/)=((T87)(se_calloc(a1,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=a1;
}
 else if(((/*RF2*/(C)->_capacity/*8*/))<(a1)){
_new_capacity=((/*RF2*/(C)->_capacity/*8*/))*(2);
while (!((_new_capacity)>=(a1)))
{
_new_capacity=(_new_capacity)*(2);
}
(/*SFN*/C->_storage/*4*/)=r87realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*8*/),_new_capacity);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
}
/*FI]*/
}
 else if((a1)!=(/*(IRF4.6count*/((/*RF2*/(C)->_upper/*12*/))+(1)/*)*/)){
r87clear((/*RF2*/(C)->_storage/*4*/),a1,(/*(IRF4.6count*/((/*RF2*/(C)->_upper/*12*/))+(1)/*)*/)-(1));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}

T0* r90twin(T90* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T90*)R)=M90;
r90copy(((T90*)R),((T0*)C));
return R;
}

void r76copy(T76* C,T0* a1){
T2 _other_upper=0;
T2 _new_capacity=0;
_other_upper=(/*RF2*/(((T76*)a1))->_upper/*12*/);
/*[IF*/
if((_other_upper)>=(0)){
_new_capacity=(_other_upper)+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_new_capacity)){
(/*SFN*/C->_storage/*4*/)=((T78)(se_calloc(_new_capacity,sizeof(T2))));
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
}
 else if(((/*RF2*/(C)->_capacity/*8*/))>(0)){
r78clear_all((/*RF2*/(C)->_storage/*4*/),((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
r78copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T76*)a1))->_storage/*4*/),_other_upper);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))>(0)){
r78clear_all((/*RF2*/(C)->_storage/*4*/),((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=_other_upper;
}

void r76make(T76* C,T2 a1){
/*[IF*/
if((a1)==(0)){
/*[IF*/
if((((/*RF2*/(C)->_capacity/*8*/))>(0))&&(((/*RF2*/(C)->_upper/*12*/))>=(0))){
r78clear((/*RF2*/(C)->_storage/*4*/),0,(/*RF2*/(C)->_upper/*12*/));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=-(1);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
(/*SFN*/C->_storage/*4*/)=((T78)(se_calloc(a1,sizeof(T2))));
(/*SFN*/C->_capacity/*8*/)=a1;
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))<(a1)){
(/*SFN*/C->_storage/*4*/)=((T78)(se_calloc(a1,sizeof(T2))));
(/*SFN*/C->_capacity/*8*/)=a1;
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
else{
r78clear((/*RF2*/(C)->_storage/*4*/),0,(/*RF2*/(C)->_upper/*12*/));
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
/*FI]*/
}

void r76resize(T76* C,T2 a1){
T2 _new_capacity=0;
/*[IF*/
if((a1)>(/*(IRF4.6count*/((/*RF2*/(C)->_upper/*12*/))+(1)/*)*/)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
(/*SFN*/C->_storage/*4*/)=((T78)(se_calloc(a1,sizeof(T2))));
(/*SFN*/C->_capacity/*8*/)=a1;
}
 else if(((/*RF2*/(C)->_capacity/*8*/))<(a1)){
_new_capacity=((/*RF2*/(C)->_capacity/*8*/))*(2);
while (!((_new_capacity)>=(a1)))
{
_new_capacity=(_new_capacity)*(2);
}
(/*SFN*/C->_storage/*4*/)=r78realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*8*/),_new_capacity);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
}
/*FI]*/
}
 else if((a1)!=(/*(IRF4.6count*/((/*RF2*/(C)->_upper/*12*/))+(1)/*)*/)){
r78clear((/*RF2*/(C)->_storage/*4*/),a1,(/*(IRF4.6count*/((/*RF2*/(C)->_upper/*12*/))+(1)/*)*/)-(1));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}

T0* r76twin(T76* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T76*)R)=M76;
r76copy(((T76*)R),((T0*)C));
return R;
}

void r76with_capacity(T76* C,T2 a1){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(a1)){
(/*SFN*/C->_storage/*4*/)=((T78)(se_calloc(a1,sizeof(T2))));
(/*SFN*/C->_capacity/*8*/)=a1;
}
 else if(((/*RF2*/(C)->_capacity/*8*/))>(a1)){
r78clear((/*RF2*/(C)->_storage/*4*/),0,(/*RF2*/(C)->_upper/*12*/));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=-(1);
}

void r76from_collection(T76* C,T0* a1){
T2 _i1=0;
T2 _i2=0;
T2 _up=0;
r76with_capacity(C,X171count(a1));
(/*SFN*/C->_upper/*12*/)=(X171count(a1))-(1);
_i1=0;
_i2=X171lower(a1);
_up=/*SSWA2*//*X171upper*/(/*RF2*/(((T76*)a1))->_upper/*12*/);
while (!((_i2)>(_up)))
{
((/*RF2*/(C)->_storage/*4*/))[_i1]=(X171item(a1,_i2));
_i1=(_i1)+(1);
_i2=(_i2)+(1);
}
}

void r86copy(T86* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T86*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T86*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=((T87)(se_calloc(_needed_capacity,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r87copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T86*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

void r86force(T86* C,T0* a1,T2 a2){
/*[IF*/
if(((/*RF2*/(C)->_upper/*12*/))<(a2)){
/*[IF*/
if((a2)==(((/*RF2*/(C)->_upper/*12*/))+(1))){
r86add_last(C,a1);
}
else{
r86resize(C,(/*RF2*/(C)->_lower/*16*/),a2);
/*[IRF3.6put*/{T86* C1=C;
T0* b1=a1;
T2 b2=a2;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}
/*FI]*/
}
 else if((a2)<((/*RF2*/(C)->_lower/*16*/))){
r86resize(C,a2,(/*RF2*/(C)->_upper/*12*/));
/*[IRF3.6put*/{T86* C1=C;
T0* b1=a1;
T2 b2=a2;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}
else{
/*[IRF3.6put*/{T86* C1=C;
T0* b1=a1;
T2 b2=a2;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}
/*FI]*/
}

T2 r86count(T86* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}

T0* r86item(T86* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

T6 r86valid_index(T86* C,T2 a1){
T6 R=0;
R=(((/*RF2*/(C)->_lower/*16*/))<=(a1))&&((a1)<=((/*RF2*/(C)->_upper/*12*/)));
return R;
}

void r86make(T86* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=((T87)(se_calloc(_needed,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T86* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T86* C2=C1;
T0* c1=__value;
r87set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

void r86add_last(T86* C,T0* a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<((r86count(C))+(1))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
_new_capacity=16;
(/*SFN*/C->_storage/*4*/)=((T87)(se_calloc(_new_capacity,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*8*/));
(/*SFN*/C->_storage/*4*/)=r87realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*8*/),_new_capacity);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
}
/*FI]*/
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=((/*RF2*/(C)->_upper/*12*/))+(1);
/*[IRF3.6put*/{T86* C1=C;
T0* b1=a1;
T2 b2=(/*RF2*/(C)->_upper/*12*/);
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}

void r86resize(T86* C,T2 a1,T2 a2){
T2 _needed=0;
T2 _offset=0;
T2 _intersize=0;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if((_needed)>((/*RF2*/(C)->_capacity/*8*/))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
(/*SFN*/C->_storage/*4*/)=((T87)(se_calloc(_needed,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
(/*SFN*/C->_storage/*4*/)=r87realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*8*/),_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
/*FI]*/
}
/*FI]*/
_offset=((/*RF2*/(C)->_lower/*16*/))-(a1);
_intersize=((r2min(a2,(/*RF2*/(C)->_upper/*12*/)))-(r2max(a1,(/*RF2*/(C)->_lower/*16*/))))+(1);
/*[IF*/
if((_intersize)>(0)){
/*[IF*/
if((_offset)==(0)){
/*[IF*/
if((_intersize)<((/*RF2*/(C)->_capacity/*8*/))){
r87clear((/*RF2*/(C)->_storage/*4*/),_intersize,((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
}
 else if((_offset)<(0)){
r87move((/*RF2*/(C)->_storage/*4*/),-(_offset),((_intersize)-(_offset))-(1),_offset);
/*[IF*/
if((_intersize)<((/*RF2*/(C)->_capacity/*8*/))){
r87clear((/*RF2*/(C)->_storage/*4*/),_intersize,((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
}
else{
r87move((/*RF2*/(C)->_storage/*4*/),0,(_intersize)-(1),_offset);
r87clear((/*RF2*/(C)->_storage/*4*/),0,(_offset)-(1));
/*[IF*/
if(((_intersize)+(_offset))<((/*RF2*/(C)->_capacity/*8*/))){
r87clear((/*RF2*/(C)->_storage/*4*/),(_intersize)+(_offset),((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
}
/*FI]*/
}
else{
r87clear((/*RF2*/(C)->_storage/*4*/),0,((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
}
/*FI]*/
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
}

T0* r86twin(T86* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T86*)R)=M86;
r86copy(((T86*)R),((T0*)C));
return R;
}

void r74copy(T74* C,T0* a1){
T2 _other_upper=0;
T2 _new_capacity=0;
_other_upper=/*SSWARF2*//*X74upper*/(/*RF2*/(((T90*)a1))->_upper/*12*/);
/*[IF*/
if((_other_upper)>=(0)){
_new_capacity=(_other_upper)+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_new_capacity)){
(/*SFN*/C->_storage/*4*/)=((T75)(se_calloc(_new_capacity,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
}
 else if(((/*RF2*/(C)->_capacity/*8*/))>(0)){
r75clear_all((/*RF2*/(C)->_storage/*4*/),((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
r75copy_from((/*RF2*/(C)->_storage/*4*/),/*SSWARF2*//*X74storage*/((T75)((/*RF2*/(((T90*)a1))->_storage/*4*/))),_other_upper);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))>(0)){
r75clear_all((/*RF2*/(C)->_storage/*4*/),((/*RF2*/(C)->_capacity/*8*/))-(1));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=_other_upper;
}

T2 r74count(T74* C){
T2 R=0;
R=((/*RF2*/(C)->_upper/*12*/))+(1);
return R;
}

T0* r74item(T74* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[a1];
return R;
}

void r74make(T74* C,T2 a1){
/*[IF*/
if((a1)==(0)){
/*[IF*/
if((((/*RF2*/(C)->_capacity/*8*/))>(0))&&(((/*RF2*/(C)->_upper/*12*/))>=(0))){
r75clear((/*RF2*/(C)->_storage/*4*/),0,(/*RF2*/(C)->_upper/*12*/));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=-(1);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
(/*SFN*/C->_storage/*4*/)=((T75)(se_calloc(a1,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=a1;
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
 else if(((/*RF2*/(C)->_capacity/*8*/))<(a1)){
(/*SFN*/C->_storage/*4*/)=((T75)(se_calloc(a1,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=a1;
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
else{
r75clear((/*RF2*/(C)->_storage/*4*/),0,(/*RF2*/(C)->_upper/*12*/));
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}
/*FI]*/
}

void r74resize(T74* C,T2 a1){
T2 _new_capacity=0;
/*[IF*/
if((a1)>(r74count(C))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
(/*SFN*/C->_storage/*4*/)=((T75)(se_calloc(a1,sizeof(T0*))));
(/*SFN*/C->_capacity/*8*/)=a1;
}
 else if(((/*RF2*/(C)->_capacity/*8*/))<(a1)){
_new_capacity=((/*RF2*/(C)->_capacity/*8*/))*(2);
while (!((_new_capacity)>=(a1)))
{
_new_capacity=(_new_capacity)*(2);
}
(/*SFN*/C->_storage/*4*/)=r75realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*8*/),_new_capacity);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
}
/*FI]*/
}
 else if((a1)!=(r74count(C))){
r75clear((/*RF2*/(C)->_storage/*4*/),a1,(r74count(C))-(1));
}
/*FI]*/
(/*SFN*/C->_upper/*12*/)=(a1)-(1);
}

T0* r74twin(T74* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T74*)R)=M74;
r74copy(((T74*)R),((T0*)C));
return R;
}

void r69clear_all(T0* a1){
T0* _v=NULL;
X74set_all_with(a1,_v);
}

T0* r69make(T2 a1){
T0* R=NULL;
{T74*n=((T74*)se_malloc(sizeof(*n))/*16*/);
*n=M74;
r74make(n,a1);
R=((T0*)n);
}
return R;
}

T0* r69resize(T0* a1,T2 a2){
T0* R=NULL;
R=a1;
X74resize(R,a2);
return R;
}

T0* r69twin(T69* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T69*)R)=*C;
return R;
}

T0* r110to_fixed_array(T0* a1){
T0* R=NULL;
R=r110make_from_array(a1);
return R;
}

T0* r110make(T2 a1){
T0* R=NULL;
{T76*n=((T76*)se_malloc(sizeof(*n))/*16*/);
*n=M76;
r76make(n,a1);
R=((T0*)n);
}
return R;
}

T0* r110make_from_array(T0* a1){
T0* R=NULL;
{T76*n=((T76*)se_malloc(sizeof(*n))/*16*/);
*n=M76;
r76from_collection(n,a1);
R=((T0*)n);
}
return R;
}

T0* r110resize(T0* a1,T2 a2){
T0* R=NULL;
R=a1;
r76resize(((T76*)R),a2);
return R;
}

T0* r110twin(T110* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T110*)R)=*C;
return R;
}

void r143copy(T143* C,T0* a1){
/*[IF*/
if((((/*RF2*/(C)->_container/*8*/))!=((void*)(NULL)))&&(!(r143off(C)))){
r122remove_traversing_cursor((T122*)((/*RF2*/(C)->_container/*8*/)),(T0*)C);
}
/*FI]*/
*((T143*)(C))=*((T143*)(a1));
(/*SFN*/C->_next_cursor/*12*/)=NULL;
/*[IF*/
if(!(r143off(C))){
r122add_traversing_cursor((T122*)((/*RF2*/(C)->_container/*8*/)),(T0*)C);
}
/*FI]*/
}

void r143make(T143* C,T0* a1){
(/*SFN*/C->_container/*8*/)=a1;
(/*SFN*/C->_position/*4*/)=-1;
}

T6 r143off(T143* C){
T6 R=0;
R=r122cursor_off((T0*)C);
return R;
}

T0* r143twin(T143* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T143*)R)=M143;
r143copy(((T143*)R),((T0*)C));
return R;
}

T0* r168make(T2 a1){
T0* R=NULL;
{T107*n=((T107*)se_malloc(sizeof(*n))/*16*/);
*n=M107;
r107make(n,a1);
R=((T0*)n);
}
return R;
}

T0* r168resize(T0* a1,T2 a2){
T0* R=NULL;
R=a1;
r107resize(((T107*)R),a2);
return R;
}

T0* r168twin(T168* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T168*)R)=*C;
return R;
}

T2 r122new_capacity(T2 a1){
T2 R=0;
R=(2)*(a1);
return R;
}

void r122copy(T122* C,T0* a1){
T0* _old_cursor=NULL;
/*[IF*/
if((a1)!=((void*)(C))){
_old_cursor=(/*RF2*/(C)->_internal_cursor/*48*/);
r122move_all_cursors_after(C);
*((T122*)(C))=*((T122*)(a1));
/*[IF*/
if((_old_cursor)!=((void*)(NULL))){
(/*SFN*/C->_internal_cursor/*48*/)=_old_cursor;
}
else{
(/*SFN*/C->_internal_cursor/*48*/)=r122new_cursor(C);
}
/*FI]*/
/*[IRF3.3unset_found_item*/((((T122*)(C)))->_found_position/*44*/)=(0);
/*]*/
r122clone_items(C);
r122clone_keys(C);
r122clone_slots(C);
r122clone_clashes(C);
}
/*FI]*/
}

void r122force(T122* C,T0* a1,T0* a2){
T2 _i=0;
T2 _h=0;
/*[IRF3.3unset_found_item*/((((T122*)(C)))->_found_position/*44*/)=(0);
/*]*/
r122search_position(C,a2);
/*[IF*/
if(((/*RF2*/(C)->_position/*32*/))!=(0)){
/*[IRF3.5items_put*//*[IRF3.5put*/((/*RF2*/(((T90*)((/*RF2*/(C)->_items/*52*/))))->_storage/*4*/))[(/*RF2*/(C)->_position/*32*/)]=(a1);
/*]*/
/*]*/
}
else{
/*[IF*/
if(((/*RF2*/(C)->_count/*12*/))==((/*RF2*/(C)->_capacity/*16*/))){
r122resize(C,r122new_capacity(((/*RF2*/(C)->_count/*12*/))+(1)));
_h=r122hash_position(C,a2);
}
else{
_h=(/*RF2*/(C)->_slots_position/*36*/);
}
/*FI]*/
_i=(/*RF2*/(C)->_free_slot/*28*/);
/*[IF*/
if((_i)==(0)){
(/*SFN*/C->_last_position/*20*/)=((/*RF2*/(C)->_last_position/*20*/))+(1);
_i=(/*RF2*/(C)->_last_position/*20*/);
}
else{
(/*SFN*/C->_free_slot/*28*/)=(-1)-(/*(IRF4.6clashes_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[_i]/*)*//*)*/);
}
/*FI]*/
/*[IRF3.5clashes_put*//*[IRF3.5put*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[_i]=(/*(IRF4.6slots_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_slots/*64*/))))->_storage/*4*/))[_h]/*)*//*)*/);
/*]*/
/*]*/
/*[IRF3.5slots_put*//*[IRF3.5put*/((/*RF2*/(((T76*)((/*RF2*/(C)->_slots/*64*/))))->_storage/*4*/))[_h]=(_i);
/*]*/
/*]*/
/*[IRF3.5items_put*//*[IRF3.5put*/((/*RF2*/(((T90*)((/*RF2*/(C)->_items/*52*/))))->_storage/*4*/))[_i]=(a1);
/*]*/
/*]*/
/*[IRF3.5keys_put*//*[IRF3.5put*/((/*RF2*/(((T90*)((/*RF2*/(C)->_keys/*56*/))))->_storage/*4*/))[_i]=(a2);
/*]*/
/*]*/
(/*SFN*/C->_count/*12*/)=((/*RF2*/(C)->_count/*12*/))+(1);
}
/*FI]*/
}

void r122make_clashes(T122* C,T2 a1){
(/*SFN*/C->_clashes/*60*/)=r110make(a1);
}

void r122search_position(T122* C,T0* a1){
T2 _i=0;
T2 _prev=0;
T0* _a_tester=NULL;
/*[IF*/
if((a1)==((void*)(NULL))){
(/*SFN*/C->_position/*32*/)=/*(IRF4.6slots_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_slots/*64*/))))->_storage/*4*/))[(/*RF2*/(C)->_modulus/*24*/)]/*)*//*)*/;
(/*SFN*/C->_slots_position/*36*/)=(/*RF2*/(C)->_modulus/*24*/);
(/*SFN*/C->_clashes_previous_position/*40*/)=0;
}
else{
_a_tester=(/*RF2*/(C)->_key_equality_tester/*8*/);
/*[IF*/
if((_a_tester)!=((void*)(NULL))){
/*[IF*/
if((((/*RF2*/(C)->_position/*32*/))==(0))||(!(r128test(a1,/*(IRF4.6keys_item*//*(IRF4.6item*/((/*RF2*/(((T90*)((/*RF2*/(C)->_keys/*56*/))))->_storage/*4*/))[(/*RF2*/(C)->_position/*32*/)]/*)*//*)*/)))){
(/*SFN*/C->_slots_position/*36*/)=r122hash_position(C,a1);
_i=/*(IRF4.6slots_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_slots/*64*/))))->_storage/*4*/))[(/*RF2*/(C)->_slots_position/*36*/)]/*)*//*)*/;
(/*SFN*/C->_position/*32*/)=0;
_prev=0;
while (!((_i)==(0)))
{
/*[IF*/
if(r128test(a1,/*(IRF4.6keys_item*//*(IRF4.6item*/((/*RF2*/(((T90*)((/*RF2*/(C)->_keys/*56*/))))->_storage/*4*/))[_i]/*)*//*)*/)){
(/*SFN*/C->_position/*32*/)=_i;
_i=0;
}
else{
_prev=_i;
_i=/*(IRF4.6clashes_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[_i]/*)*//*)*/;
}
/*FI]*/
}
(/*SFN*/C->_clashes_previous_position/*40*/)=_prev;
}
/*FI]*/
}
else{
/*[IF*/
if((((/*RF2*/(C)->_position/*32*/))==(0))||((a1)!=((void*)(/*(IRF4.6keys_item*//*(IRF4.6item*/((/*RF2*/(((T90*)((/*RF2*/(C)->_keys/*56*/))))->_storage/*4*/))[(/*RF2*/(C)->_position/*32*/)]/*)*//*)*/)))){
(/*SFN*/C->_slots_position/*36*/)=r122hash_position(C,a1);
_i=/*(IRF4.6slots_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_slots/*64*/))))->_storage/*4*/))[(/*RF2*/(C)->_slots_position/*36*/)]/*)*//*)*/;
(/*SFN*/C->_position/*32*/)=0;
_prev=0;
while (!((_i)==(0)))
{
/*[IF*/
if((a1)==((void*)(/*(IRF4.6keys_item*//*(IRF4.6item*/((/*RF2*/(((T90*)((/*RF2*/(C)->_keys/*56*/))))->_storage/*4*/))[_i]/*)*//*)*/))){
(/*SFN*/C->_position/*32*/)=_i;
_i=0;
}
else{
_prev=_i;
_i=/*(IRF4.6clashes_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[_i]/*)*//*)*/;
}
/*FI]*/
}
(/*SFN*/C->_clashes_previous_position/*40*/)=_prev;
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}

void r122remove_traversing_cursor(T122* C,T0* a1){
T0* _current_cursor=NULL;
T0* _previous_cursor=NULL;
/*[IF*/
if((a1)!=((void*)((/*RF2*/(C)->_internal_cursor/*48*/)))){
_previous_cursor=(/*RF2*/(C)->_internal_cursor/*48*/);
_current_cursor=(/*RF2*/(((T143*)_previous_cursor))->_next_cursor/*12*/);
while (!(r6_px_or((_current_cursor)==((void*)(a1)),(_current_cursor)==((void*)(NULL)))))
{
_previous_cursor=_current_cursor;
_current_cursor=(/*RF2*/(((T143*)_current_cursor))->_next_cursor/*12*/);
}
/*[IF*/
if((_current_cursor)==((void*)(a1))){
/*[IRF3.3set_next_cursor*/((((T143*)(((T143*)_previous_cursor))))->_next_cursor/*12*/)=((/*RF2*/(((T143*)a1))->_next_cursor/*12*/));
/*]*/
/*[IRF3.3set_next_cursor*/((((T143*)(((T143*)a1))))->_next_cursor/*12*/)=(NULL);
/*]*/
}
/*FI]*/
}
/*FI]*/
}

void r122clone_slots(T122* C){
(/*SFN*/C->_slots/*64*/)=r122clone((/*RF2*/(C)->_slots/*64*/));
}
T0*oBC53FIXED_INTEGER_ARRAY_=NULL;

void r122keys_resize(T122* C,T2 a1){
(/*SFN*/C->_keys/*56*/)=r125resize((/*RF2*/(C)->_keys/*56*/),a1);
}

void r122clone_clashes(T122* C){
(/*SFN*/C->_clashes/*60*/)=r122clone((/*RF2*/(C)->_clashes/*60*/));
}

void r122move_all_cursors_after(T122* C){
T0* _a_cursor=NULL;
T0* _next_cursor=NULL;
_a_cursor=(/*RF2*/(C)->_internal_cursor/*48*/);
while (!((_a_cursor)==((void*)(NULL))))
{
/*[IRF3.3set_position*/((((T143*)(((T143*)_a_cursor))))->_position/*4*/)=(-2);
/*]*/
_next_cursor=(/*RF2*/(((T143*)_a_cursor))->_next_cursor/*12*/);
/*[IRF3.3set_next_cursor*/((((T143*)(((T143*)_a_cursor))))->_next_cursor/*12*/)=(NULL);
/*]*/
_a_cursor=_next_cursor;
}
}

void r122make_items(T122* C,T2 a1){
{T125*n=((T125*)se_malloc(sizeof(*n))/*4*/);
*n=M125;
(/*SFN*/C->_FIXED_ITEM_ARRAY_/*68*/)=((T0*)n);
}
(/*SFN*/C->_items/*52*/)=r125make(a1);
}

void r122add_traversing_cursor(T122* C,T0* a1){
/*[IF*/
if((a1)!=((void*)((/*RF2*/(C)->_internal_cursor/*48*/)))){
/*[IRF3.3set_next_cursor*/((((T143*)(((T143*)a1))))->_next_cursor/*12*/)=((/*RF2*/((T143*)((/*RF2*/(C)->_internal_cursor/*48*/)))->_next_cursor/*12*/));
/*]*/
/*[IRF3.3set_next_cursor*/((((T143*)((T143*)((/*RF2*/(C)->_internal_cursor/*48*/)))))->_next_cursor/*12*/)=(a1);
/*]*/
}
/*FI]*/
}

T0* r122clone(T0* a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((void*)(NULL))){
R=X10twin(a1);
}
/*FI]*/
return R;
}

void r122remove_position(T122* C,T2 a1){
T0* _dead_item=NULL;
T0* _k=NULL;
T0* _dead_key=NULL;
T2 _h=0;
/*[IF*/
if((a1)!=((/*RF2*/(C)->_position/*32*/))){
_k=/*(IRF4.6keys_item*//*(IRF4.6item*/((/*RF2*/(((T90*)((/*RF2*/(C)->_keys/*56*/))))->_storage/*4*/))[a1]/*)*//*)*/;
_h=r122hash_position(C,_k);
/*[IF*/
if((/*(IRF4.6slots_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_slots/*64*/))))->_storage/*4*/))[_h]/*)*//*)*/)==(a1)){
(/*SFN*/C->_position/*32*/)=a1;
(/*SFN*/C->_slots_position/*36*/)=_h;
(/*SFN*/C->_clashes_previous_position/*40*/)=0;
}
else{
r122search_position(C,_k);
}
/*FI]*/
}
/*FI]*/
r122move_cursors_forth(C,(/*RF2*/(C)->_position/*32*/));
/*[IF*/
if(((/*RF2*/(C)->_clashes_previous_position/*40*/))==(0)){
/*[IRF3.5slots_put*//*[IRF3.5put*/((/*RF2*/(((T76*)((/*RF2*/(C)->_slots/*64*/))))->_storage/*4*/))[(/*RF2*/(C)->_slots_position/*36*/)]=(/*(IRF4.6clashes_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[(/*RF2*/(C)->_position/*32*/)]/*)*//*)*/);
/*]*/
/*]*/
}
else{
/*[IRF3.5clashes_put*//*[IRF3.5put*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[(/*RF2*/(C)->_clashes_previous_position/*40*/)]=(/*(IRF4.6clashes_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[(/*RF2*/(C)->_position/*32*/)]/*)*//*)*/);
/*]*/
/*]*/
}
/*FI]*/
/*[IRF3.5items_put*//*[IRF3.5put*/((/*RF2*/(((T90*)((/*RF2*/(C)->_items/*52*/))))->_storage/*4*/))[(/*RF2*/(C)->_position/*32*/)]=(_dead_item);
/*]*/
/*]*/
/*[IRF3.5keys_put*//*[IRF3.5put*/((/*RF2*/(((T90*)((/*RF2*/(C)->_keys/*56*/))))->_storage/*4*/))[(/*RF2*/(C)->_position/*32*/)]=(_dead_key);
/*]*/
/*]*/
/*[IF*/
if(r6_px_and(((/*RF2*/(C)->_free_slot/*28*/))==(0),((/*RF2*/(C)->_position/*32*/))==((/*RF2*/(C)->_last_position/*20*/)))){
(/*SFN*/C->_last_position/*20*/)=((/*RF2*/(C)->_last_position/*20*/))-(1);
/*[IRF3.5clashes_put*//*[IRF3.5put*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[(/*RF2*/(C)->_position/*32*/)]=(0);
/*]*/
/*]*/
}
else{
/*[IRF3.5clashes_put*//*[IRF3.5put*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[(/*RF2*/(C)->_position/*32*/)]=((-1)-((/*RF2*/(C)->_free_slot/*28*/)));
/*]*/
/*]*/
(/*SFN*/C->_free_slot/*28*/)=(/*RF2*/(C)->_position/*32*/);
}
/*FI]*/
(/*SFN*/C->_count/*12*/)=((/*RF2*/(C)->_count/*12*/))-(1);
}

void r122make(T122* C,T2 a1){
{T128*n=((T128*)se_malloc(sizeof(*n))/*4*/);
*n=M128;
(/*SFN*/C->_key_equality_tester/*8*/)=((T0*)n);
}
r122make_with_equality_testers(C,a1,NULL,(/*RF2*/(C)->_key_equality_tester/*8*/));
}

void r122remove(T122* C,T0* a1){
/*[IRF3.3unset_found_item*/((((T122*)(C)))->_found_position/*44*/)=(0);
/*]*/
r122search_position(C,a1);
/*[IF*/
if(((/*RF2*/(C)->_position/*32*/))!=(0)){
r122remove_position(C,(/*RF2*/(C)->_position/*32*/));
}
/*FI]*/
}

void r122clone_items(T122* C){
(/*SFN*/C->_items/*52*/)=r122clone((/*RF2*/(C)->_items/*52*/));
}

T6 r122has(T122* C,T0* a1){
T6 R=0;
r122search_position(C,a1);
R=((/*RF2*/(C)->_position/*32*/))!=(0);
return R;
}

void r122make_keys(T122* C,T2 a1){
{T125*n=((T125*)se_malloc(sizeof(*n))/*4*/);
*n=M125;
(/*SFN*/C->_FIXED_KEY_ARRAY_/*72*/)=((T0*)n);
}
(/*SFN*/C->_keys/*56*/)=r125make(a1);
}

T2 r122hash_position(T122* C,T0* a1){
T2 R=0;
/*[IF*/
if((a1)!=((void*)(NULL))){
R=(r7hash_code(((T7*)a1)))%((/*RF2*/(C)->_modulus/*24*/));
}
else{
R=(/*RF2*/(C)->_modulus/*24*/);
}
/*FI]*/
return R;
}

void r122items_resize(T122* C,T2 a1){
(/*SFN*/C->_items/*52*/)=r125resize((/*RF2*/(C)->_items/*52*/),a1);
}

void r122clone_keys(T122* C){
(/*SFN*/C->_keys/*56*/)=r122clone((/*RF2*/(C)->_keys/*56*/));
}

void r122make_with_equality_testers(T122* C,T2 a1,T0* a2,T0* a3){
(/*SFN*/C->_equality_tester/*4*/)=a2;
(/*SFN*/C->_key_equality_tester/*8*/)=a3;
(/*SFN*/C->_capacity/*16*/)=a1;
r122make_items(C,(a1)+(1));
r122make_keys(C,(a1)+(1));
r122make_clashes(C,(a1)+(1));
(/*SFN*/C->_modulus/*24*/)=r122new_modulus(a1);
r122make_slots(C,((/*RF2*/(C)->_modulus/*24*/))+(1));
(/*SFN*/C->_last_position/*20*/)=0;
(/*SFN*/C->_free_slot/*28*/)=0;
(/*SFN*/C->_position/*32*/)=0;
/*[IRF3.3unset_found_item*/((((T122*)(C)))->_found_position/*44*/)=(0);
/*]*/
(/*SFN*/C->_internal_cursor/*48*/)=r122new_cursor(C);
}

void r122move_cursors_after(T122* C,T2 a1){
T0* _a_cursor=NULL;
T0* _previous_cursor=NULL;
T0* _next_cursor=NULL;
_a_cursor=(/*RF2*/(C)->_internal_cursor/*48*/);
/*[IF*/
if(((/*RF2*/(((T143*)_a_cursor))->_position/*4*/))==(a1)){
/*[IRF3.3set_position*/((((T143*)(((T143*)_a_cursor))))->_position/*4*/)=(-2);
/*]*/
}
/*FI]*/
_previous_cursor=_a_cursor;
_a_cursor=(/*RF2*/(((T143*)_a_cursor))->_next_cursor/*12*/);
while (!((_a_cursor)==((void*)(NULL))))
{
/*[IF*/
if(((/*RF2*/(((T143*)_a_cursor))->_position/*4*/))==(a1)){
/*[IRF3.3set_position*/((((T143*)(((T143*)_a_cursor))))->_position/*4*/)=(-2);
/*]*/
_next_cursor=(/*RF2*/(((T143*)_a_cursor))->_next_cursor/*12*/);
/*[IRF3.3set_next_cursor*/((((T143*)(((T143*)_previous_cursor))))->_next_cursor/*12*/)=(_next_cursor);
/*]*/
/*[IRF3.3set_next_cursor*/((((T143*)(((T143*)_a_cursor))))->_next_cursor/*12*/)=(NULL);
/*]*/
_a_cursor=_next_cursor;
}
else{
_previous_cursor=_a_cursor;
_a_cursor=(/*RF2*/(((T143*)_a_cursor))->_next_cursor/*12*/);
}
/*FI]*/
}
}

void r122resize(T122* C,T2 a1){
T2 _m=0;
T2 _i=0;
T2 _h=0;
/*[IRF3.3unset_found_item*/((((T122*)(C)))->_found_position/*44*/)=(0);
/*]*/
_m=r122new_modulus(a1);
r122slots_resize(C,(_m)+(1));
_i=(/*RF2*/(C)->_modulus/*24*/);
while (!((_i)<(0)))
{
/*[IRF3.5slots_put*//*[IRF3.5put*/((/*RF2*/(((T76*)((/*RF2*/(C)->_slots/*64*/))))->_storage/*4*/))[_i]=(0);
/*]*/
/*]*/
_i=(_i)-(1);
}
(/*SFN*/C->_modulus/*24*/)=_m;
_i=(/*RF2*/(C)->_last_position/*20*/);
while (!((_i)<(1)))
{
/*[IF*/
if((/*(IRF4.6clashes_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[_i]/*)*//*)*/)>(-1)){
_h=r122hash_position(C,/*(IRF4.6keys_item*//*(IRF4.6item*/((/*RF2*/(((T90*)((/*RF2*/(C)->_keys/*56*/))))->_storage/*4*/))[_i]/*)*//*)*/);
/*[IRF3.5clashes_put*//*[IRF3.5put*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[_i]=(/*(IRF4.6slots_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_slots/*64*/))))->_storage/*4*/))[_h]/*)*//*)*/);
/*]*/
/*]*/
/*[IRF3.5slots_put*//*[IRF3.5put*/((/*RF2*/(((T76*)((/*RF2*/(C)->_slots/*64*/))))->_storage/*4*/))[_h]=(_i);
/*]*/
/*]*/
}
/*FI]*/
_i=(_i)-(1);
}
r122items_resize(C,(a1)+(1));
r122keys_resize(C,(a1)+(1));
r122clashes_resize(C,(a1)+(1));
(/*SFN*/C->_capacity/*16*/)=a1;
(/*SFN*/C->_position/*32*/)=0;
}

void r122move_cursors_forth(T122* C,T2 a1){
T2 _i=0;
T2 _nb=0;
_i=(a1)+(1);
_nb=(/*RF2*/(C)->_last_position/*20*/);
while (!(((_i)>(_nb))||((/*(IRF4.6clashes_item*//*(IRF4.6item*/((/*RF2*/(((T76*)((/*RF2*/(C)->_clashes/*60*/))))->_storage/*4*/))[_i]/*)*//*)*/)>(-1))))
{
_i=(_i)+(1);
}
/*[IF*/
if((_i)>(_nb)){
r122move_cursors_after(C,a1);
}
else{
r122move_all_cursors(C,a1,_i);
}
/*FI]*/
}

void r122clashes_resize(T122* C,T2 a1){
(/*SFN*/C->_clashes/*60*/)=r110resize((/*RF2*/(C)->_clashes/*60*/),a1);
}

void r122slots_resize(T122* C,T2 a1){
(/*SFN*/C->_slots/*64*/)=r110resize((/*RF2*/(C)->_slots/*64*/),a1);
}

T0* r122twin(T122* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T122*)R)=M122;
r122copy(((T122*)R),((T0*)C));
return R;
}

T0* r122new_cursor(T122* C){
T0* R=NULL;
{T143*n=((T143*)se_malloc(sizeof(*n))/*16*/);
*n=M143;
r143make(n,(T0*)C);
R=((T0*)n);
}
return R;
}

void r122make_slots(T122* C,T2 a1){
(/*SFN*/C->_slots/*64*/)=r110make(a1);
}

void r122move_all_cursors(T122* C,T2 a1,T2 a2){
T0* _a_cursor=NULL;
_a_cursor=(/*RF2*/(C)->_internal_cursor/*48*/);
while (!((_a_cursor)==((void*)(NULL))))
{
/*[IF*/
if(((/*RF2*/(((T143*)_a_cursor))->_position/*4*/))==(a1)){
/*[IRF3.3set_position*/((((T143*)(((T143*)_a_cursor))))->_position/*4*/)=(a2);
/*]*/
}
/*FI]*/
_a_cursor=(/*RF2*/(((T143*)_a_cursor))->_next_cursor/*12*/);
}
}

T2 r122new_modulus(T2 a1){
T2 R=0;
R=(((a1)+(1))*(3))/(2);
return R;
}

T6 r122cursor_off(T0* a1){
T6 R=0;
R=((/*RF2*/(((T143*)a1))->_position/*4*/))<(0);
return R;
}

T0* r125make(T2 a1){
T0* R=NULL;
{T90*n=((T90*)se_malloc(sizeof(*n))/*16*/);
*n=M90;
r90make(n,a1);
R=((T0*)n);
}
return R;
}

T0* r125resize(T0* a1,T2 a2){
T0* R=NULL;
R=a1;
r90resize(((T90*)R),a2);
return R;
}

T0* r125twin(T125* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T125*)R)=*C;
return R;
}

T6 r128test(T0* a1,T0* a2){
T6 R=0;
/*[IF*/
if((a1)==((void*)(NULL))){
R=(a2)==((void*)(NULL));
}
 else if((a2)==((void*)(NULL))){
R=0;
}
else{
R=r7is_equal(((T7*)a1),a2);
}
/*FI]*/
return R;
}

T0* r128twin(T128* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T128*)R)=*C;
return R;
}

void r106copy(T106* C,T0* a1){
/*[IF*/
if((a1)!=((void*)(C))){
*((T106*)(C))=*((T106*)(a1));
(/*SFN*/C->_storage/*12*/)=r106clone((/*RF2*/(C)->_storage/*12*/));
}
/*FI]*/
}

void r106put(T106* C,T0* a1){
(/*SFN*/C->_count/*4*/)=((/*RF2*/(C)->_count/*4*/))+(1);
/*[IRF3.5put*/((/*RF2*/((T107*)((/*RF2*/(C)->_storage/*12*/)))->_storage/*4*/))[(/*RF2*/(C)->_count/*4*/)]=(a1);
/*]*/
}

T0* r106item(T106* C){
T0* R=NULL;
R=/*(IRF4.6item*/((/*RF2*/((T107*)((/*RF2*/(C)->_storage/*12*/)))->_storage/*4*/))[(/*RF2*/(C)->_count/*4*/)]/*)*/;
return R;
}

T0* r106clone(T0* a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((void*)(NULL))){
R=X10twin(a1);
}
/*FI]*/
return R;
}

void r106make(T106* C,T2 a1){
{T168*n=((T168*)se_malloc(sizeof(*n))/*4*/);
*n=M168;
(/*SFN*/C->_FIXED_ARRAY_/*16*/)=((T0*)n);
}
(/*SFN*/C->_storage/*12*/)=r168make((a1)+(1));
(/*SFN*/C->_capacity/*8*/)=a1;
}

void r106remove(T106* C){
T0* _dead_item=NULL;
/*[IRF3.5put*/((/*RF2*/((T107*)((/*RF2*/(C)->_storage/*12*/)))->_storage/*4*/))[(/*RF2*/(C)->_count/*4*/)]=(_dead_item);
/*]*/
(/*SFN*/C->_count/*4*/)=((/*RF2*/(C)->_count/*4*/))-(1);
}

T0* r106twin(T106* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T106*)R)=M106;
r106copy(((T106*)R),((T0*)C));
return R;
}

T6 r106is_full(T106* C){
T6 R=0;
R=((/*RF2*/(C)->_count/*4*/))==((/*RF2*/(C)->_capacity/*8*/));
return R;
}

void r43yy_refill_input_buffer(T43* C){
T2 _yy_new_start=0;
/*SSPRF3*//*X80set_index*//*[IRF3.3set_index*/((((T79*)((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))))->_index/*24*/)=((/*RF2*/(C)->_yy_start/*109*/));
/*]*/
X80fill((/*RF2*/(C)->_input_buffer/*81*/));
r43yy_set_content(C,/*SSWARF2*//*X80content*/(/*RF2*/((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))->_content/*4*/));
_yy_new_start=/*SSWARF2*//*X80index*/(/*RF2*/((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))->_index/*24*/);
(/*SFN*/C->_yy_end/*105*/)=(((/*RF2*/(C)->_yy_end/*105*/))-((/*RF2*/(C)->_yy_start/*109*/)))+(_yy_new_start);
(/*SFN*/C->_yy_start/*109*/)=_yy_new_start;
}

T0* r43text_substring(T43* C,T2 a1,T2 a2){
T0* R=NULL;
/*[IF*/
if((a2)<(a1)){
{T7*n=((T7*)se_malloc(sizeof(*n))/*16*/);
*n=M7;
r7make(n,0);
R=((T0*)n);
}
}
else{
R=r112substring((/*RF2*/(C)->_yy_content/*101*/),(((/*RF2*/(C)->_yy_start/*109*/))+(a1))-(1),(((/*RF2*/(C)->_yy_start/*109*/))+(a2))-(1));
}
/*FI]*/
return R;
}

void r43yy_build_tables(T43* C){
(/*SFN*/C->_yy_nxt/*138*/)=r43yy_nxt_template();
if(NULL!=((/*SFN*/C->_yy_nxt/*138*/))){
switch(((T0*)(/*SFN*/C->_yy_nxt/*138*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yy_nxt/*138*/)=NULL;
}
}(/*SFN*/C->_yy_chk/*142*/)=r43yy_chk_template();
if(NULL!=((/*SFN*/C->_yy_chk/*142*/))){
switch(((T0*)(/*SFN*/C->_yy_chk/*142*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yy_chk/*142*/)=NULL;
}
}(/*SFN*/C->_yy_base/*146*/)=r43yy_base_template();
if(NULL!=((/*SFN*/C->_yy_base/*146*/))){
switch(((T0*)(/*SFN*/C->_yy_base/*146*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yy_base/*146*/)=NULL;
}
}(/*SFN*/C->_yy_def/*150*/)=r43yy_def_template();
if(NULL!=((/*SFN*/C->_yy_def/*150*/))){
switch(((T0*)(/*SFN*/C->_yy_def/*150*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yy_def/*150*/)=NULL;
}
}(/*SFN*/C->_yy_ec/*154*/)=r43yy_ec_template();
if(NULL!=((/*SFN*/C->_yy_ec/*154*/))){
switch(((T0*)(/*SFN*/C->_yy_ec/*154*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yy_ec/*154*/)=NULL;
}
}(/*SFN*/C->_yy_meta/*158*/)=r43yy_meta_template();
if(NULL!=((/*SFN*/C->_yy_meta/*158*/))){
switch(((T0*)(/*SFN*/C->_yy_meta/*158*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yy_meta/*158*/)=NULL;
}
}(/*SFN*/C->_yy_accept/*162*/)=r43yy_accept_template();
if(NULL!=((/*SFN*/C->_yy_accept/*162*/))){
switch(((T0*)(/*SFN*/C->_yy_accept/*162*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yy_accept/*162*/)=NULL;
}
}}
T0*oBC45yy_meta_template=NULL;
int fBC45yy_meta_template=0;

T0* r43yy_meta_template(void){
if(fBC45yy_meta_template==0){fBC45yy_meta_template=1;{
oBC45yy_meta_template=r43yy_fixed_array(se_ma172(18,
0,
1,
1,
2,
3,
1,
1,
4,
4,
4,
4,
4,
4,
4,
4,
4,
5,
1));
}}
return oBC45yy_meta_template;
}

T6 r43syntax_error(T43* C){
T6 R=0;
R=((/*RF2*/(C)->_yy_parsing_status/*69*/))!=(12);
return R;
}
T0*oBC43yycheck_template=NULL;
int fBC43yycheck_template=0;

T0* r43yycheck_template(void){
if(fBC43yycheck_template==0){fBC43yycheck_template=1;{
oBC43yycheck_template=r43yyfixed_array(se_ma172(53,
6,
8,
5,
0,
3,
4,
5,
6,
7,
12,
13,
10,
18,
3,
4,
5,
6,
7,
0,
9,
10,
24,
25,
12,
31,
11,
11,
16,
17,
14,
15,
37,
3,
4,
5,
6,
7,
14,
15,
11,
15,
18,
14,
15,
11,
11,
11,
11,
-(1),
37,
13,
12,
12));
}}
return oBC43yycheck_template;
}

void r43yy_set_beginning_of_line(T43* C){
/*[IF*/
if(((/*RF2*/(C)->_yy_end/*105*/))>((/*RF2*/(C)->_yy_start/*109*/))){
/*SSPRF3*//*X80set_beginning_of_line*//*[IRF3.3set_beginning_of_line*/((((T79*)((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))))->_beginning_of_line/*32*/)=((/*(IRF4.6item*/((/*RF2*/((T7*)((/*RF2*/(C)->_yy_content/*101*/)))->_storage/*4*/))[(((/*RF2*/(C)->_yy_end/*105*/))-(1))-(1)]/*)*/)==(((T3)'\n')));
/*]*/
}
/*FI]*/
}
T0*oBC45yy_accept_template=NULL;
int fBC45yy_accept_template=0;

T0* r43yy_accept_template(void){
if(fBC45yy_accept_template==0){fBC45yy_accept_template=1;{
oBC45yy_accept_template=r43yy_fixed_array(se_ma172(67,
0,
0,
0,
0,
0,
14,
14,
24,
22,
12,
11,
9,
21,
15,
20,
21,
21,
17,
21,
14,
13,
12,
10,
1,
0,
0,
0,
0,
15,
0,
18,
17,
19,
14,
13,
0,
0,
0,
0,
0,
0,
16,
0,
0,
0,
0,
0,
0,
0,
0,
4,
0,
0,
0,
0,
0,
0,
5,
2,
0,
0,
8,
7,
3,
0,
6,
0));
}}
return oBC45yy_accept_template;
}

void r43read_token(T43* C){
T2 _yy_cp=0;
T2 _yy_bp=0;
T2 _yy_current_state=0;
T2 _yy_next_state=0;
T2 _yy_matched_count=0;
T2 _yy_act=0;
T2 _yy_goto=0;
T2 _yy_c=0;
T6 _yy_found=0;
T2 _yy_rejected_line=0;
T2 _yy_rejected_column=0;
T2 _yy_rejected_position=0;
(/*SFN*/C->_last_token/*77*/)=-2;
_yy_goto=1;
while (!(((/*RF2*/(C)->_last_token/*77*/))!=(-2)))
{
/*[INSPECT*/
{int z1=_yy_goto;
switch(z1){
case 1:
/*[IF*/
if((/*RF2*/(C)->_yy_more_flag/*125*/)){
(/*SFN*/C->_yy_more_len/*126*/)=((/*RF2*/(C)->_yy_end/*105*/))-((/*RF2*/(C)->_yy_start/*109*/));
(/*SFN*/C->_yy_more_flag/*125*/)=0;
}
else{
(/*SFN*/C->_yy_more_len/*126*/)=0;
(/*SFN*/C->_line/*85*/)=(/*RF2*/(C)->_yy_line/*113*/);
(/*SFN*/C->_column/*89*/)=(/*RF2*/(C)->_yy_column/*117*/);
(/*SFN*/C->_position/*93*/)=(/*RF2*/(C)->_yy_position/*121*/);
}
/*FI]*/
_yy_cp=(/*RF2*/(C)->_yy_end/*105*/);
_yy_bp=_yy_cp;
_yy_current_state=((/*RF2*/(C)->_yy_start_state/*97*/))+(r43yy_at_beginning_of_line(C));
/*[IF*/
/*AF*//*AE*/
/*FI]*/
_yy_goto=2;
break;
case 2:
/*[IF*/
if(((/*RF2*/(C)->_yy_ec/*154*/))!=((void*)(NULL))){
_yy_c=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_ec/*154*/)))->_storage/*4*/))[T3code(/*(IRF4.6item*/((/*RF2*/((T7*)((/*RF2*/(C)->_yy_content/*101*/)))->_storage/*4*/))[(_yy_cp)-(1)]/*)*/)]/*)*/;
}
else{
_yy_c=T3code(/*(IRF4.6item*/((/*RF2*/((T7*)((/*RF2*/(C)->_yy_content/*101*/)))->_storage/*4*/))[(_yy_cp)-(1)]/*)*/);
}
/*FI]*/
/*[IF*/
if((!(0))&&((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_accept/*162*/)))->_storage/*4*/))[_yy_current_state]/*)*/)!=(0))){
(/*SFN*/C->_yy_last_accepting_state/*130*/)=_yy_current_state;
(/*SFN*/C->_yy_last_accepting_cpos/*134*/)=_yy_cp;
}
/*FI]*/
while (!((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_chk/*142*/)))->_storage/*4*/))[(/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_base/*146*/)))->_storage/*4*/))[_yy_current_state]/*)*/)+(_yy_c)]/*)*/)==(_yy_current_state)))
{
_yy_current_state=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_def/*150*/)))->_storage/*4*/))[_yy_current_state]/*)*/;
/*[IF*/
if((((/*RF2*/(C)->_yy_meta/*158*/))!=((void*)(NULL)))&&((_yy_current_state)>=(67))){
_yy_c=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_meta/*158*/)))->_storage/*4*/))[_yy_c]/*)*/;
}
/*FI]*/
}
_yy_current_state=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_nxt/*138*/)))->_storage/*4*/))[(/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_base/*146*/)))->_storage/*4*/))[_yy_current_state]/*)*/)+(_yy_c)]/*)*/;
/*[IF*/
/*AF*//*AE*/
/*FI]*/
_yy_cp=(_yy_cp)+(1);
while (!((_yy_current_state)==(66)))
{
/*[IF*/
if(((/*RF2*/(C)->_yy_ec/*154*/))!=((void*)(NULL))){
_yy_c=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_ec/*154*/)))->_storage/*4*/))[T3code(/*(IRF4.6item*/((/*RF2*/((T7*)((/*RF2*/(C)->_yy_content/*101*/)))->_storage/*4*/))[(_yy_cp)-(1)]/*)*/)]/*)*/;
}
else{
_yy_c=T3code(/*(IRF4.6item*/((/*RF2*/((T7*)((/*RF2*/(C)->_yy_content/*101*/)))->_storage/*4*/))[(_yy_cp)-(1)]/*)*/);
}
/*FI]*/
/*[IF*/
if((!(0))&&((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_accept/*162*/)))->_storage/*4*/))[_yy_current_state]/*)*/)!=(0))){
(/*SFN*/C->_yy_last_accepting_state/*130*/)=_yy_current_state;
(/*SFN*/C->_yy_last_accepting_cpos/*134*/)=_yy_cp;
}
/*FI]*/
while (!((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_chk/*142*/)))->_storage/*4*/))[(/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_base/*146*/)))->_storage/*4*/))[_yy_current_state]/*)*/)+(_yy_c)]/*)*/)==(_yy_current_state)))
{
_yy_current_state=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_def/*150*/)))->_storage/*4*/))[_yy_current_state]/*)*/;
/*[IF*/
if((((/*RF2*/(C)->_yy_meta/*158*/))!=((void*)(NULL)))&&((_yy_current_state)>=(67))){
_yy_c=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_meta/*158*/)))->_storage/*4*/))[_yy_c]/*)*/;
}
/*FI]*/
}
_yy_current_state=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_nxt/*138*/)))->_storage/*4*/))[(/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_base/*146*/)))->_storage/*4*/))[_yy_current_state]/*)*/)+(_yy_c)]/*)*/;
/*[IF*/
/*AF*//*AE*/
/*FI]*/
_yy_cp=(_yy_cp)+(1);
}
/*[IF*/
{/*AT*/_yy_cp=(/*RF2*/(C)->_yy_last_accepting_cpos/*134*/);
_yy_current_state=(/*RF2*/(C)->_yy_last_accepting_state/*130*/);
}
/*FI]*/
_yy_goto=3;
break;
case 3:
/*[IF*/
{/*AT*/_yy_act=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_accept/*162*/)))->_storage/*4*/))[_yy_current_state]/*)*/;
_yy_goto=4;
}
/*FI]*/
break;
case 5:
_yy_found=0;
while (!(_yy_found))
{
/*[IF*/
if(r6_px_and(((/*RF2*/(C)->_yy_lp/*183*/))!=(0),((/*RF2*/(C)->_yy_lp/*183*/))<(/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_accept/*162*/)))->_storage/*4*/))[(_yy_current_state)+(1)]/*)*/))){
_yy_act=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_acclist/*166*/)))->_storage/*4*/))[(/*RF2*/(C)->_yy_lp/*183*/)]/*)*/;
/*[IF*/
/*AF*//*AE*/
(/*SFN*/C->_yy_full_match/*179*/)=_yy_cp;
_yy_found=1;
/*FI]*/
}
else{
_yy_cp=(_yy_cp)-(1);
(/*SFN*/C->_yy_state_count/*175*/)=((/*RF2*/(C)->_yy_state_count/*175*/))-(1);
_yy_current_state=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_state_stack/*171*/)))->_storage/*4*/))[(/*RF2*/(C)->_yy_state_count/*175*/)]/*)*/;
(/*SFN*/C->_yy_lp/*183*/)=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_accept/*162*/)))->_storage/*4*/))[_yy_current_state]/*)*/;
}
/*FI]*/
}
_yy_rejected_line=(/*RF2*/(C)->_yy_line/*113*/);
_yy_rejected_column=(/*RF2*/(C)->_yy_column/*117*/);
_yy_rejected_position=(/*RF2*/(C)->_yy_position/*121*/);
_yy_goto=4;
break;
default:;
_yy_bp=(_yy_bp)-((/*RF2*/(C)->_yy_more_len/*126*/));
(/*SFN*/C->_yy_start/*109*/)=_yy_bp;
(/*SFN*/C->_yy_end/*105*/)=_yy_cp;
_yy_goto=1;
/*[IF*/
if((_yy_act)==(0)){
/*[IF*/
{/*AT*/_yy_cp=(/*RF2*/(C)->_yy_last_accepting_cpos/*134*/);
_yy_bp=(_yy_bp)+((/*RF2*/(C)->_yy_more_len/*126*/));
_yy_current_state=(/*RF2*/(C)->_yy_last_accepting_state/*130*/);
_yy_goto=3;
}
/*FI]*/
}
 else if((_yy_act)==(24)){
_yy_matched_count=((_yy_cp)-(_yy_bp))-(1);
/*[IF*/
if(((/*RF2*/(C)->_yy_end/*105*/))<=((/*SSWARF2*//*X80upper*/(/*RF2*/((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))->_upper/*28*/))+(1))){
(/*SFN*/C->_yy_end/*105*/)=(_yy_bp)+(_yy_matched_count);
_yy_current_state=r43yy_previous_state(C);
_yy_next_state=r43yy_null_trans_state(C,_yy_current_state);
_yy_bp=(_yy_bp)+((/*RF2*/(C)->_yy_more_len/*126*/));
/*[IF*/
if((_yy_next_state)!=(0)){
_yy_cp=((/*RF2*/(C)->_yy_end/*105*/))+(1);
(/*SFN*/C->_yy_end/*105*/)=_yy_cp;
_yy_current_state=_yy_next_state;
_yy_goto=2;
}
else{
/*[IF*/
/*AF*//*AE*/
_yy_cp=(/*RF2*/(C)->_yy_last_accepting_cpos/*134*/);
_yy_current_state=(/*RF2*/(C)->_yy_last_accepting_state/*130*/);
/*FI]*/
_yy_goto=3;
}
/*FI]*/
}
else{
(/*SFN*/C->_yy_end/*105*/)=((/*RF2*/(C)->_yy_end/*105*/))-(1);
r43yy_refill_input_buffer(C);
/*[IF*/
if(/*SSWARF2*//*X80filled*/(/*RF2*/((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))->_filled/*33*/)){
_yy_current_state=r43yy_previous_state(C);
_yy_cp=(/*RF2*/(C)->_yy_end/*105*/);
_yy_bp=((/*RF2*/(C)->_yy_start/*109*/))+((/*RF2*/(C)->_yy_more_len/*126*/));
_yy_goto=2;
}
 else if(((((/*RF2*/(C)->_yy_end/*105*/))-((/*RF2*/(C)->_yy_start/*109*/)))-((/*RF2*/(C)->_yy_more_len/*126*/)))!=(0)){
_yy_current_state=r43yy_previous_state(C);
_yy_cp=(/*RF2*/(C)->_yy_end/*105*/);
_yy_bp=((/*RF2*/(C)->_yy_start/*109*/))+((/*RF2*/(C)->_yy_more_len/*126*/));
_yy_goto=3;
}
else{
/*[IF*/
if(r43wrap(C)){
_yy_bp=(/*RF2*/(C)->_yy_start/*109*/);
_yy_cp=(/*RF2*/(C)->_yy_end/*105*/);
/*[IRF3.6yy_execute_eof_action*/{T43* C1=C;
T2 b1=(((/*RF2*/(C)->_yy_start_state/*97*/))-(1))/(2);
/*[IRF3.3terminate*/((((T43*)(C1)))->_last_token/*77*/)=(0);
/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
else{
r43yy_execute_action(C,_yy_act);
/*[IF*/
if((/*RF2*/(C)->_yy_rejected/*170*/)){
(/*SFN*/C->_yy_rejected/*170*/)=0;
(/*SFN*/C->_yy_line/*113*/)=_yy_rejected_line;
(/*SFN*/C->_yy_column/*117*/)=_yy_rejected_column;
(/*SFN*/C->_yy_position/*121*/)=_yy_rejected_position;
_yy_cp=(/*RF2*/(C)->_yy_full_match/*179*/);
/*[IF*/
/*AF*//*AE*/
/*FI]*/
(/*SFN*/C->_yy_lp/*183*/)=((/*RF2*/(C)->_yy_lp/*183*/))+(1);
_yy_goto=5;
}
/*FI]*/
}
/*FI]*/
}
}/*INSPECT]*/
}
}
T0*oBC45yy_base_template=NULL;
int fBC45yy_base_template=0;

T0* r43yy_base_template(void){
if(fBC45yy_base_template==0){fBC45yy_base_template=1;{
oBC45yy_base_template=r43yy_fixed_array(se_ma172(75,
0,
0,
0,
5,
0,
100,
99,
101,
104,
97,
104,
18,
104,
97,
104,
0,
92,
0,
80,
93,
104,
92,
104,
0,
84,
11,
15,
79,
90,
87,
104,
0,
104,
87,
104,
78,
73,
78,
22,
78,
76,
104,
72,
73,
70,
71,
71,
66,
68,
63,
104,
65,
64,
64,
57,
61,
58,
104,
104,
48,
49,
104,
104,
104,
25,
104,
104,
36,
41,
46,
51,
56,
28,
61,
66));
}}
return oBC45yy_base_template;
}

void r43yy_build_parser_tables(T43* C){
(/*SFN*/C->_yytranslate/*8*/)=r43yytranslate_template();
if(NULL!=((/*SFN*/C->_yytranslate/*8*/))){
switch(((T0*)(/*SFN*/C->_yytranslate/*8*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yytranslate/*8*/)=NULL;
}
}(/*SFN*/C->_yyr1/*12*/)=r43yyr1_template();
if(NULL!=((/*SFN*/C->_yyr1/*12*/))){
switch(((T0*)(/*SFN*/C->_yyr1/*12*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yyr1/*12*/)=NULL;
}
}(/*SFN*/C->_yyr2/*16*/)=r43yyr2_template();
if(NULL!=((/*SFN*/C->_yyr2/*16*/))){
switch(((T0*)(/*SFN*/C->_yyr2/*16*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yyr2/*16*/)=NULL;
}
}(/*SFN*/C->_yydefact/*20*/)=r43yydefact_template();
if(NULL!=((/*SFN*/C->_yydefact/*20*/))){
switch(((T0*)(/*SFN*/C->_yydefact/*20*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yydefact/*20*/)=NULL;
}
}(/*SFN*/C->_yydefgoto/*24*/)=r43yydefgoto_template();
if(NULL!=((/*SFN*/C->_yydefgoto/*24*/))){
switch(((T0*)(/*SFN*/C->_yydefgoto/*24*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yydefgoto/*24*/)=NULL;
}
}(/*SFN*/C->_yypact/*28*/)=r43yypact_template();
if(NULL!=((/*SFN*/C->_yypact/*28*/))){
switch(((T0*)(/*SFN*/C->_yypact/*28*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yypact/*28*/)=NULL;
}
}(/*SFN*/C->_yypgoto/*32*/)=r43yypgoto_template();
if(NULL!=((/*SFN*/C->_yypgoto/*32*/))){
switch(((T0*)(/*SFN*/C->_yypgoto/*32*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yypgoto/*32*/)=NULL;
}
}(/*SFN*/C->_yytable/*36*/)=r43yytable_template();
if(NULL!=((/*SFN*/C->_yytable/*36*/))){
switch(((T0*)(/*SFN*/C->_yytable/*36*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yytable/*36*/)=NULL;
}
}(/*SFN*/C->_yycheck/*40*/)=r43yycheck_template();
if(NULL!=((/*SFN*/C->_yycheck/*40*/))){
switch(((T0*)(/*SFN*/C->_yycheck/*40*/))->id){
case 76:
break;
default:
(/*SFN*/C->_yycheck/*40*/)=NULL;
}
}}
T0*oBC43yytable_template=NULL;
int fBC43yytable_template=0;

T0* r43yytable_template(void){
if(fBC43yytable_template==0){fBC43yytable_template=1;{
oBC43yytable_template=r43yyfixed_array(se_ma172(53,
17,
18,
16,
41,
5,
4,
3,
2,
1,
22,
23,
28,
17,
5,
4,
3,
2,
1,
40,
29,
28,
33,
34,
14,
37,
36,
27,
13,
12,
25,
24,
17,
5,
4,
3,
2,
1,
25,
24,
26,
24,
32,
25,
24,
35,
21,
20,
19,
0,
38,
11,
10,
9));
}}
return oBC43yytable_template;
}

void r43set_input_buffer(T43* C,T0* a1){
/*[IF*/
if((a1)!=((void*)((/*RF2*/(C)->_input_buffer/*81*/)))){
/*SSPRF3*//*X80set_index*//*[IRF3.3set_index*/((((T79*)((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))))->_index/*24*/)=((/*RF2*/(C)->_yy_end/*105*/));
/*]*/
/*SSPRF3*//*X80set_position*/r79set_position((T79*)((/*RF2*/(C)->_input_buffer/*81*/)),(/*RF2*/(C)->_yy_position/*121*/),(/*RF2*/(C)->_yy_line/*113*/),(/*RF2*/(C)->_yy_column/*117*/));
(/*SFN*/C->_input_buffer/*81*/)=a1;
r43yy_load_input_buffer(C);
}
/*FI]*/
}

void r43make_gepp_scanner(T43* C){
r43make_with_buffer(C,r43Empty_buffer());
(/*SFN*/C->_output_file/*208*/)=r95output();
(/*SFN*/C->_line_nb/*199*/)=1;
}

T0* r43yyfixed_array(T0* a1){
T0* R=NULL;
R=r110to_fixed_array(a1);
return R;
}

void r43process_include(T43* C,T0* a1){
T0* _a_file=NULL;
T0* _cannot_read=NULL;
T0* _too_many_includes=NULL;
/*[IF*/
if(!(r106is_full((T106*)((/*RF2*/(C)->_include_stack/*229*/))))){
/*[IF*/
if((/*RF2*/(C)->_makefile_dependencies/*216*/)){
r43output(C,((T0*)ms43_6359));
r43output(C,a1);
}
/*FI]*/
_a_file=r92make_file_open_read(r148interpreted_string(a1));
/*[IF*/
if(r92is_open_read(_a_file)){
r106put((T106*)((/*RF2*/(C)->_include_stack/*229*/)),(/*RF2*/(C)->_input_buffer/*81*/));
r43set_input_buffer(C,r43new_file_buffer(_a_file));
}
else{
{T147*n=((T147*)se_malloc(sizeof(*n))/*8*/);
*n=M147;
r147make(n,a1);
_cannot_read=((T0*)n);
}
r83report_error((T83*)((/*RF2*/(C)->_error_handler/*212*/)),_cannot_read);
/*[IRF3.3abort*/((((T43*)(C)))->_yy_parsing_status/*69*/)=(13);
/*]*/
}
/*FI]*/
}
else{
{T146*n=((T146*)se_malloc(sizeof(*n))/*8*/);
*n=M146;
r146make(n,((/*RF2*/((T106*)((/*RF2*/(C)->_include_stack/*229*/)))->_count/*4*/))+(1));
_too_many_includes=((T0*)n);
}
r83report_error((T83*)((/*RF2*/(C)->_error_handler/*212*/)),_too_many_includes);
/*[IRF3.3abort*/((((T43*)(C)))->_yy_parsing_status/*69*/)=(13);
/*]*/
}
/*FI]*/
}

T2 r43yy_null_trans_state(T43* C,T2 a1){
T2 R=0;
T2 _yy_c=0;
T6 _yy_is_jam=0;
/*[IF*/
{/*AT*//*[IF*/
if((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_accept/*162*/)))->_storage/*4*/))[a1]/*)*/)!=(0)){
(/*SFN*/C->_yy_last_accepting_state/*130*/)=a1;
(/*SFN*/C->_yy_last_accepting_cpos/*134*/)=(/*RF2*/(C)->_yy_end/*105*/);
}
/*FI]*/
}
/*FI]*/
R=a1;
_yy_c=1;
while (!((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_chk/*142*/)))->_storage/*4*/))[(/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_base/*146*/)))->_storage/*4*/))[R]/*)*/)+(_yy_c)]/*)*/)==(R)))
{
R=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_def/*150*/)))->_storage/*4*/))[R]/*)*/;
/*[IF*/
if((((/*RF2*/(C)->_yy_meta/*158*/))!=((void*)(NULL)))&&((R)>=(67))){
_yy_c=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_meta/*158*/)))->_storage/*4*/))[_yy_c]/*)*/;
}
/*FI]*/
}
R=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_nxt/*138*/)))->_storage/*4*/))[(/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_base/*146*/)))->_storage/*4*/))[R]/*)*/)+(_yy_c)]/*)*/;
/*[IF*/
/*AF*//*AE*/
/*FI]*/
_yy_is_jam=(R)==(66);
/*[IF*/
if(_yy_is_jam){
R=0;
}
/*FI]*/
return R;
}
T0*oBC43yypgoto_template=NULL;
int fBC43yypgoto_template=0;

T0* r43yypgoto_template(void){
if(fBC43yypgoto_template==0){fBC43yypgoto_template=1;{
oBC43yypgoto_template=r43yyfixed_array(se_ma172(7,
-(3),
-(32768),
-(7),
-(6),
-(32768),
12,
-(32768)));
}}
return oBC43yypgoto_template;
}
T0*oBC55Empty_buffer=NULL;
int fBC55Empty_buffer=0;

T0* r43Empty_buffer(void){
if(fBC55Empty_buffer==0){fBC55Empty_buffer=1;{
{T80*n=((T80*)se_malloc(sizeof(*n))/*34*/);
*n=M80;
oBC55Empty_buffer=((T0*)n);
r80make(n,((T0*)ms55_0));
}
}}
return oBC55Empty_buffer;
}
T0*oBC19std=NULL;

void r43output(T43* C,T0* a1){
/*[IF*/
if(!(/*(IRF4.7ignored*/((/*RF2*/(C)->_ignored_level/*225*/))!=(0)/*)*/)){
X38put_string((/*RF2*/(C)->_output_file/*208*/),a1);
}
 else if((/*RF2*/(C)->_empty_lines/*207*/)){
X38put_new_line((/*RF2*/(C)->_output_file/*208*/));
}
/*FI]*/
}

void r43yy_set_content(T43* C,T0* a1){
T2 _nb=0;
(/*SFN*/C->_yy_content/*101*/)=a1;
/*[IF*/
/*AF*//*AE*/
/*FI]*/
}
T0*oBC45yy_nxt_template=NULL;
int fBC45yy_nxt_template=0;

T0* r43yy_nxt_template(void){
if(fBC45yy_nxt_template==0){fBC45yy_nxt_template=1;{
oBC45yy_nxt_template=r43yy_fixed_array(se_ma172(122,
0,
66,
66,
10,
66,
11,
12,
13,
14,
15,
12,
16,
17,
17,
17,
17,
17,
17,
17,
17,
17,
17,
18,
23,
36,
37,
38,
24,
25,
39,
26,
45,
31,
31,
27,
65,
46,
8,
8,
8,
8,
8,
9,
9,
9,
9,
9,
19,
19,
19,
19,
19,
21,
21,
21,
21,
21,
29,
64,
63,
29,
29,
33,
33,
33,
33,
33,
23,
62,
23,
23,
23,
61,
60,
59,
58,
57,
56,
55,
54,
53,
52,
51,
50,
49,
48,
47,
44,
43,
42,
34,
41,
28,
40,
35,
22,
34,
32,
30,
28,
22,
66,
20,
20,
7,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66));
}}
return oBC45yy_nxt_template;
}

void r43make(T43* C,T0* a1){
r43make_gepp_scanner(C);
r43make_parser_skeleton(C);
(/*SFN*/C->_error_handler/*212*/)=a1;
{T122*n=((T122*)se_malloc(sizeof(*n))/*76*/);
*n=M122;
r122make(n,10);
(/*SFN*/C->_defined_values/*217*/)=((T0*)n);
}
{T106*n=((T106*)se_malloc(sizeof(*n))/*20*/);
*n=M106;
r106make(n,10);
(/*SFN*/C->_include_stack/*229*/)=((T0*)n);
}
}
T0*oBC45yy_chk_template=NULL;
int fBC45yy_chk_template=0;

T0* r43yy_chk_template(void){
if(fBC45yy_chk_template==0){fBC45yy_chk_template=1;{
oBC45yy_chk_template=r43yy_fixed_array(se_ma172(122,
0,
0,
0,
2,
0,
2,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
11,
25,
25,
26,
11,
11,
26,
11,
38,
72,
72,
11,
64,
38,
67,
67,
67,
67,
67,
68,
68,
68,
68,
68,
69,
69,
69,
69,
69,
70,
70,
70,
70,
70,
71,
60,
59,
71,
71,
73,
73,
73,
73,
73,
74,
56,
74,
74,
74,
55,
54,
53,
52,
51,
49,
48,
47,
46,
45,
44,
43,
42,
40,
39,
37,
36,
35,
33,
29,
28,
27,
24,
21,
19,
18,
16,
13,
9,
7,
6,
5,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66));
}}
return oBC45yy_chk_template;
}

void r43fatal_error(T0* a1){
/*[IRF3.6put_string*/((/*UT*/(void)((T96*)(r95error()))));
{T0* b1=a1;
r96old_put_string(b1);
}/*]*/
/*[IRF3.6put_character*/((/*UT*/(void)((T96*)(r95error()))));
{T3 b1=((T3)'\n');
/*[IRF3.6old_put_character*/{T3 c1=b1;
basic_io_putc(c1,basic_io_stderr);
}/*]*/
}/*]*/
}
T0*oBC44Execution_environment=NULL;
T0*oBC43yypact_template=NULL;
int fBC43yypact_template=0;

T0* r43yypact_template(void){
if(fBC43yypact_template==0){fBC43yypact_template=1;{
oBC43yypact_template=r43yyfixed_array(se_ma172(42,
29,
40,
39,
37,
11,
11,
29,
-(32768),
29,
36,
35,
34,
11,
11,
-(32768),
28,
15,
-(32768),
10,
-(32768),
-(32768),
-(32768),
23,
-(32768),
11,
11,
-(32768),
-(32768),
33,
14,
-(32768),
29,
-(32768),
-(32768),
25,
-(32768),
-(32768),
1,
-(32768),
18,
3,
-(32768)));
}}
return oBC43yypact_template;
}

void r43echo(T43* C){
/*[IF*/
if(!((/*RF2*/(C)->_makefile_dependencies/*216*/))){
r43output(C,r43text(C));
}
/*FI]*/
}

void r43make_parser_skeleton(T43* C){
{T69*n=((T69*)se_malloc(sizeof(*n))/*4*/);
*n=M69;
(/*SFN*/C->_FIXED_ARRAY_/*73*/)=((T0*)n);
}
(/*SFN*/C->_yyvs/*44*/)=X69make((/*RF2*/(C)->_FIXED_ARRAY_/*73*/),200);
(/*SFN*/C->_yyss/*48*/)=r110make(200);
r43yy_build_parser_tables(C);
}
T0*oBC54STRING_BUFFER_=NULL;
T0*oBC43yydefact_template=NULL;
int fBC43yydefact_template=0;

T0* r43yydefact_template(void){
if(fBC43yydefact_template==0){fBC43yydefact_template=1;{
oBC43yydefact_template=r43yyfixed_array(se_ma172(42,
2,
0,
0,
0,
0,
0,
1,
3,
2,
0,
0,
0,
0,
0,
12,
0,
0,
4,
0,
8,
7,
9,
0,
16,
0,
0,
11,
10,
0,
0,
5,
2,
13,
14,
15,
17,
18,
0,
6,
0,
0,
0));
}}
return oBC43yydefact_template;
}
T0*oBC45yy_def_template=NULL;
int fBC45yy_def_template=0;

T0* r43yy_def_template(void){
if(fBC45yy_def_template==0){fBC45yy_def_template=1;{
oBC45yy_def_template=r43yy_fixed_array(se_ma172(75,
0,
67,
68,
66,
3,
69,
69,
66,
66,
70,
66,
66,
66,
66,
66,
71,
66,
72,
66,
73,
66,
70,
66,
74,
66,
66,
66,
66,
66,
71,
66,
72,
66,
73,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
66,
0,
66,
66,
66,
66,
66,
66,
66,
66));
}}
return oBC45yy_def_template;
}

T0* r43yytype1(T0* a1){
T0* R=NULL;
R=a1;
if(NULL!=(R)){
switch(((T0*)R)->id){
case 7:
break;
default:
R=NULL;
}
}return R;
}

void r43yy_clear_all(T43* C){
T0* _default_value=NULL;
/*[IRF3.4clear_all*/r43clear_stacks(C);
/*]*/
(/*SFN*/C->_yyval/*60*/)=_default_value;
}

T6 r43yytype2(T0* a1){
T6 R=0;
T0* _ref=NULL;
_ref=a1;
if(NULL!=(_ref)){
switch(((T0*)_ref)->id){
case 40:
break;
default:
_ref=NULL;
}
}R=(/*RF2*/(((T40*)_ref))->_item/*4*/);
return R;
}
T0*oBC45yy_ec_template=NULL;
int fBC45yy_ec_template=0;

T0* r43yy_ec_template(void){
if(fBC45yy_ec_template==0){fBC45yy_ec_template=1;{
oBC45yy_ec_template=r43yy_fixed_array(se_ma172(257,
0,
1,
1,
1,
1,
1,
1,
1,
1,
2,
3,
1,
1,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
1,
4,
5,
1,
1,
6,
1,
1,
1,
1,
1,
1,
7,
7,
1,
7,
7,
7,
7,
7,
7,
7,
7,
7,
7,
1,
1,
1,
1,
1,
1,
1,
7,
7,
8,
9,
10,
11,
7,
7,
12,
7,
7,
13,
7,
14,
7,
7,
7,
7,
15,
7,
16,
7,
7,
7,
7,
7,
1,
1,
1,
1,
7,
1,
7,
7,
8,
9,
10,
11,
7,
7,
12,
7,
7,
13,
7,
14,
7,
7,
7,
7,
15,
7,
16,
7,
7,
7,
7,
7,
1,
17,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1));
}}
return oBC45yy_ec_template;
}

void r43make_with_buffer(T43* C,T0* a1){
(/*SFN*/C->_input_buffer/*81*/)=a1;
r43yy_initialize(C);
r43yy_load_input_buffer(C);
}

void r43yy_execute_action(T43* C,T2 a1){
/*[IF*/
if((a1)<=(12)){
/*[IF*/
if((a1)<=(6)){
/*[IF*/
if((a1)<=(3)){
/*[IF*/
if((a1)<=(2)){
/*[IF*/
if((a1)==(1)){
r43set_start_condition(C,1);
/*[IF*/
if((/*RF2*/(C)->_empty_lines/*207*/)){
X38put_new_line((/*RF2*/(C)->_output_file/*208*/));
}
/*FI]*/
}
else{
(/*SFN*/C->_last_token/*77*/)=258;
r43set_start_condition(C,1);
/*[IF*/
if((/*RF2*/(C)->_empty_lines/*207*/)){
X38put_new_line((/*RF2*/(C)->_output_file/*208*/));
}
/*FI]*/
}
/*FI]*/
}
else{
(/*SFN*/C->_last_token/*77*/)=259;
r43set_start_condition(C,1);
/*[IF*/
if((/*RF2*/(C)->_empty_lines/*207*/)){
X38put_new_line((/*RF2*/(C)->_output_file/*208*/));
}
/*FI]*/
}
/*FI]*/
}
else{
/*[IF*/
if((a1)<=(5)){
/*[IF*/
if((a1)==(4)){
(/*SFN*/C->_last_token/*77*/)=264;
r43set_start_condition(C,1);
/*[IF*/
if((/*RF2*/(C)->_empty_lines/*207*/)){
X38put_new_line((/*RF2*/(C)->_output_file/*208*/));
}
/*FI]*/
}
else{
(/*SFN*/C->_last_token/*77*/)=265;
r43set_start_condition(C,1);
/*[IF*/
if((/*RF2*/(C)->_empty_lines/*207*/)){
X38put_new_line((/*RF2*/(C)->_output_file/*208*/));
}
/*FI]*/
}
/*FI]*/
}
else{
(/*SFN*/C->_last_token/*77*/)=260;
r43set_start_condition(C,1);
/*[IF*/
if((/*RF2*/(C)->_empty_lines/*207*/)){
X38put_new_line((/*RF2*/(C)->_output_file/*208*/));
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
else{
/*[IF*/
if((a1)<=(9)){
/*[IF*/
if((a1)<=(8)){
/*[IF*/
if((a1)==(7)){
(/*SFN*/C->_last_token/*77*/)=261;
r43set_start_condition(C,1);
/*[IF*/
if((/*RF2*/(C)->_empty_lines/*207*/)){
X38put_new_line((/*RF2*/(C)->_output_file/*208*/));
}
/*FI]*/
}
else{
(/*SFN*/C->_last_token/*77*/)=262;
r43set_start_condition(C,1);
/*[IF*/
if((/*RF2*/(C)->_empty_lines/*207*/)){
X38put_new_line((/*RF2*/(C)->_output_file/*208*/));
}
/*FI]*/
}
/*FI]*/
}
else{
r43echo(C);
r43set_start_condition(C,2);
}
/*FI]*/
}
else{
/*[IF*/
if((a1)<=(11)){
/*[IF*/
if((a1)==(10)){
r43echo(C);
(/*SFN*/C->_line_nb/*199*/)=((/*RF2*/(C)->_line_nb/*199*/))+(1);
}
else{
r43echo(C);
(/*SFN*/C->_line_nb/*199*/)=((/*RF2*/(C)->_line_nb/*199*/))+(1);
}
/*FI]*/
}
else{
r43echo(C);
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
else{
/*[IF*/
if((a1)<=(18)){
/*[IF*/
if((a1)<=(15)){
/*[IF*/
if((a1)<=(14)){
/*[IF*/
if((a1)==(13)){
r43echo(C);
(/*SFN*/C->_line_nb/*199*/)=((/*RF2*/(C)->_line_nb/*199*/))+(1);
r43set_start_condition(C,0);
}
else{
r43echo(C);
r43set_start_condition(C,0);
}
/*FI]*/
}
/*FI]*/
}
else{
/*[IF*/
if((a1)<=(17)){
/*[IF*/
if((a1)==(16)){
(/*SFN*/C->_last_token/*77*/)=268;
(/*SFN*/C->_last_value/*203*/)=r43text_substring(C,2,(r43text_count(C))-(1));
}
else{
(/*SFN*/C->_last_token/*77*/)=267;
(/*SFN*/C->_last_value/*203*/)=r43text(C);
}
/*FI]*/
}
else{
(/*SFN*/C->_last_token/*77*/)=270;
}
/*FI]*/
}
/*FI]*/
}
else{
/*[IF*/
if((a1)<=(21)){
/*[IF*/
if((a1)<=(20)){
/*[IF*/
if((a1)==(19)){
(/*SFN*/C->_last_token/*77*/)=269;
}
else{
(/*SFN*/C->_last_token/*77*/)=266;
(/*SFN*/C->_line_nb/*199*/)=((/*RF2*/(C)->_line_nb/*199*/))+(1);
r43set_start_condition(C,0);
}
/*FI]*/
}
else{
(/*SFN*/C->_last_token/*77*/)=T3code(r43text_item(C,1));
}
/*FI]*/
}
else{
/*[IF*/
if((a1)==(22)){
(/*SFN*/C->_last_token/*77*/)=T3code(r43text_item(C,1));
}
else{
(/*SFN*/C->_last_token/*77*/)=-1;
r43fatal_error(((T0*)ms45_1173251759));
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
r43yy_set_beginning_of_line(C);
}

void r43set_start_condition(T43* C,T2 a1){
(/*SFN*/C->_yy_start_state/*97*/)=((2)*(a1))+(1);
}

void r43yy_initialize(T43* C){
r43yy_build_tables(C);
(/*SFN*/C->_yy_start_state/*97*/)=1;
(/*SFN*/C->_yy_line/*113*/)=1;
(/*SFN*/C->_yy_column/*117*/)=1;
(/*SFN*/C->_yy_position/*121*/)=1;
(/*SFN*/C->_line/*85*/)=1;
(/*SFN*/C->_column/*89*/)=1;
(/*SFN*/C->_position/*93*/)=1;
/*[IF*/
/*AF*//*AE*/
/*FI]*/
}

T2 r43yy_at_beginning_of_line(T43* C){
T2 R=0;
/*[IF*/
if(/*SSWARF2*//*X80beginning_of_line*/(/*RF2*/((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))->_beginning_of_line/*32*/)){
R=1;
}
/*FI]*/
return R;
}

void r43parse_file(T43* C,T0* a1){
r43set_input_buffer(C,r43new_file_buffer(a1));
r43parse(C);
/*[IF*/
if((/*RF2*/(C)->_makefile_dependencies/*216*/)){
r43output(C,((T0*)ms43_10));
}
/*FI]*/
}
T0*oBC43yyr1_template=NULL;
int fBC43yyr1_template=0;

T0* r43yyr1_template(void){
if(fBC43yyr1_template==0){fBC43yyr1_template=1;{
oBC43yyr1_template=r43yyfixed_array(se_ma172(19,
0,
20,
21,
21,
21,
22,
22,
22,
22,
22,
23,
23,
19,
19,
19,
19,
19,
24,
25));
}}
return oBC43yyr1_template;
}

void r43parse(T43* C){
struct rescue_context rc;
T2 _yystacksize=0;
T2 _yystate=0;
T2 _yylen=0;
T2 _yyn=0;
T2 _yychar1=0;
T2 _index=0;
T2 _yyss_top=0;
T2 _yy_goto=0;
if(SETJMP(rc.jb)!=0){/*rescue*/
/*[IRF3.3abort*/((((T43*)(C)))->_yy_parsing_status/*69*/)=(13);
/*]*/
r43yy_clear_all(C);
internal_exception_handler(Routine_failure);
}
retry_tag:
rc.next = rescue_context_top;
rescue_context_top = &rc;
(/*SFN*/C->_error_count/*4*/)=0;
(/*SFN*/C->_yy_lookahead_needed/*64*/)=1;
(/*SFN*/C->_yyerrstatus/*65*/)=0;
(/*SFN*/C->_yyvsp/*52*/)=-(1);
(/*SFN*/C->_yyssp/*56*/)=-(1);
_yystacksize=/*(IRF4.6count*/((/*RF2*/((T76*)((/*RF2*/(C)->_yyss/*48*/)))->_upper/*12*/))+(1)/*)*/;
(/*SFN*/C->_yy_parsing_status/*69*/)=15;
_yy_goto=6;
while (!(((/*RF2*/(C)->_yy_parsing_status/*69*/))!=(15)))
{
/*[INSPECT*/
{int z1=_yy_goto;
switch(z1){
case 6:
(/*SFN*/C->_yyssp/*56*/)=((/*RF2*/(C)->_yyssp/*56*/))+(1);
/*[IF*/
if(((/*RF2*/(C)->_yyssp/*56*/))>=(_yystacksize)){
_yystacksize=(_yystacksize)+(200);
(/*SFN*/C->_yyvs/*44*/)=X69resize((/*RF2*/(C)->_FIXED_ARRAY_/*73*/),(/*RF2*/(C)->_yyvs/*44*/),_yystacksize);
(/*SFN*/C->_yyss/*48*/)=r110resize((/*RF2*/(C)->_yyss/*48*/),_yystacksize);
}
/*FI]*/
/*[IRF3.5put*/((/*RF2*/((T76*)((/*RF2*/(C)->_yyss/*48*/)))->_storage/*4*/))[(/*RF2*/(C)->_yyssp/*56*/)]=(_yystate);
/*]*/
_yyn=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yypact/*28*/)))->_storage/*4*/))[_yystate]/*)*/;
/*[IF*/
if((_yyn)==(-32768)){
_yy_goto=7;
}
else{
/*[IF*/
if((/*RF2*/(C)->_yy_lookahead_needed/*64*/)){
r43read_token(C);
(/*SFN*/C->_yy_lookahead_needed/*64*/)=0;
}
/*FI]*/
/*[IF*/
if(((/*RF2*/(C)->_last_token/*77*/))>(0)){
_yychar1=r43yy_translate(C,(/*RF2*/(C)->_last_token/*77*/));
_yyn=(_yyn)+(_yychar1);
}
 else if(((/*RF2*/(C)->_last_token/*77*/))==(0)){
_yychar1=0;
}
else{
(/*SFN*/C->_error_count/*4*/)=((/*RF2*/(C)->_error_count/*4*/))+(1);
r43report_error(C,((T0*)ms57_1338477769));
/*[IRF3.3abort*/((((T43*)(C)))->_yy_parsing_status/*69*/)=(13);
/*]*/
_yyn=-(1);
}
/*FI]*/
/*[IF*/
if((r6_px_or((_yyn)<(0),(_yyn)>(52)))||((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yycheck/*40*/)))->_storage/*4*/))[_yyn]/*)*/)!=(_yychar1))){
_yy_goto=7;
}
else{
_yyn=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yytable/*36*/)))->_storage/*4*/))[_yyn]/*)*/;
/*[IF*/
if((_yyn)<(0)){
/*[IF*/
if((_yyn)==(-32768)){
_yy_goto=9;
}
else{
_yyn=-(_yyn);
_yy_goto=8;
}
/*FI]*/
}
 else if((_yyn)==(0)){
_yy_goto=9;
}
 else if((_yyn)==(41)){
/*[IRF3.3accept*/((((T43*)(C)))->_yy_parsing_status/*69*/)=(12);
/*]*/
}
else{
/*[IF*/
if(((/*RF2*/(C)->_last_token/*77*/))>(0)){
(/*SFN*/C->_yy_lookahead_needed/*64*/)=1;
}
/*FI]*/
(/*SFN*/C->_yyvsp/*52*/)=((/*RF2*/(C)->_yyvsp/*52*/))+(1);
X74put((/*RF2*/(C)->_yyvs/*44*/),(/*RF2*/(C)->_last_value/*203*/),(/*RF2*/(C)->_yyvsp/*52*/));
/*[IF*/
if(((/*RF2*/(C)->_yyerrstatus/*65*/))!=(0)){
(/*SFN*/C->_yyerrstatus/*65*/)=((/*RF2*/(C)->_yyerrstatus/*65*/))-(1);
}
/*FI]*/
_yystate=_yyn;
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
break;
case 7:
_yyn=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yydefact/*20*/)))->_storage/*4*/))[_yystate]/*)*/;
/*[IF*/
if((_yyn)==(0)){
_yy_goto=9;
}
else{
_yy_goto=8;
}
/*FI]*/
break;
case 8:
_yylen=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yyr2/*16*/)))->_storage/*4*/))[_yyn]/*)*/;
r43yy_do_action(C,_yyn);
/*[INSPECT*/
{int z2=(/*RF2*/(C)->_yy_parsing_status/*69*/);
switch(z2){
case 15:
(/*SFN*/C->_yyssp/*56*/)=((/*RF2*/(C)->_yyssp/*56*/))-(_yylen);
(/*SFN*/C->_yyvsp/*52*/)=(((/*RF2*/(C)->_yyvsp/*52*/))-(_yylen))+(1);
X74put((/*RF2*/(C)->_yyvs/*44*/),(/*RF2*/(C)->_yyval/*60*/),(/*RF2*/(C)->_yyvsp/*52*/));
_yyn=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yyr1/*12*/)))->_storage/*4*/))[_yyn]/*)*/;
_yyss_top=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yyss/*48*/)))->_storage/*4*/))[(/*RF2*/(C)->_yyssp/*56*/)]/*)*/;
_index=(_yyn)-(19);
_yystate=(/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yypgoto/*32*/)))->_storage/*4*/))[_index]/*)*/)+(_yyss_top);
/*[IF*/
if((r6_px_and((_yystate)>=(0),(_yystate)<=(52)))&&((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yycheck/*40*/)))->_storage/*4*/))[_yystate]/*)*/)==(_yyss_top))){
_yystate=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yytable/*36*/)))->_storage/*4*/))[_yystate]/*)*/;
}
else{
_yystate=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yydefgoto/*24*/)))->_storage/*4*/))[_index]/*)*/;
}
/*FI]*/
_yy_goto=6;
break;
case 14:
(/*SFN*/C->_yy_parsing_status/*69*/)=15;
_yy_goto=9;
break;
}
}/*INSPECT]*/
break;
case 9:
/*[IF*/
if(((/*RF2*/(C)->_yyerrstatus/*65*/))==(3)){
/*[IF*/
if(((/*RF2*/(C)->_last_token/*77*/))<=(0)){
/*[IRF3.3abort*/((((T43*)(C)))->_yy_parsing_status/*69*/)=(13);
/*]*/
}
else{
(/*SFN*/C->_yy_lookahead_needed/*64*/)=1;
_yy_goto=10;
}
/*FI]*/
}
else{
/*[IF*/
if(((/*RF2*/(C)->_yyerrstatus/*65*/))==(0)){
(/*SFN*/C->_error_count/*4*/)=((/*RF2*/(C)->_error_count/*4*/))+(1);
r43report_error(C,((T0*)ms57_1338477769a));
}
/*FI]*/
(/*SFN*/C->_yyerrstatus/*65*/)=3;
_yy_goto=10;
}
/*FI]*/
break;
case 10:
_yyn=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yypact/*28*/)))->_storage/*4*/))[_yystate]/*)*/;
/*[IF*/
if((_yyn)==(-32768)){
_yy_goto=11;
}
else{
_yyn=(_yyn)+(1);
/*[IF*/
if((r6_px_or((_yyn)<(0),(_yyn)>(52)))||((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yycheck/*40*/)))->_storage/*4*/))[_yyn]/*)*/)!=(1))){
_yy_goto=11;
}
else{
_yyn=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yytable/*36*/)))->_storage/*4*/))[_yyn]/*)*/;
/*[IF*/
if((_yyn)<(0)){
/*[IF*/
if((_yyn)==(-32768)){
_yy_goto=11;
}
else{
_yyn=-(_yyn);
_yy_goto=8;
}
/*FI]*/
}
 else if((_yyn)==(0)){
_yy_goto=11;
}
 else if((_yyn)==(41)){
/*[IRF3.3accept*/((((T43*)(C)))->_yy_parsing_status/*69*/)=(12);
/*]*/
}
else{
(/*SFN*/C->_yyvsp/*52*/)=((/*RF2*/(C)->_yyvsp/*52*/))+(1);
X74put((/*RF2*/(C)->_yyvs/*44*/),(/*RF2*/(C)->_last_value/*203*/),(/*RF2*/(C)->_yyvsp/*52*/));
_yystate=_yyn;
_yy_goto=6;
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
break;
default:;
/*[IF*/
if(((/*RF2*/(C)->_yyssp/*56*/))==(0)){
/*[IRF3.3abort*/((((T43*)(C)))->_yy_parsing_status/*69*/)=(13);
/*]*/
}
else{
(/*SFN*/C->_yyvsp/*52*/)=((/*RF2*/(C)->_yyvsp/*52*/))-(1);
(/*SFN*/C->_yyssp/*56*/)=((/*RF2*/(C)->_yyssp/*56*/))-(1);
_yystate=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yyss/*48*/)))->_storage/*4*/))[(/*RF2*/(C)->_yyssp/*56*/)]/*)*/;
_yy_goto=10;
}
/*FI]*/
}
}/*INSPECT]*/
}
r43yy_clear_all(C);
rescue_context_top = rc.next;
}

T0* r43twin(T43* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T43*)R)=*C;
return R;
}

void r43yy_do_action(T43* C,T2 a1){
T6 _yyval2=0;
/*[INSPECT*/
{int z1=a1;
switch(z1){
case 7:
(/*SFN*/C->_yyval/*60*/)=/*(IRF4.1yyval_default*/NULL/*)*/;
/*[IF*/
if(!(/*(IRF4.7ignored*/((/*RF2*/(C)->_ignored_level/*225*/))!=(0)/*)*/)){
/*[IRF3.5define_value*/r122force(((T122*)((/*RF2*/(C)->_defined_values/*217*/))),((T0*)ms43_0),r43yytype1(X74item((/*RF2*/(C)->_yyvs/*44*/),((/*RF2*/(C)->_yyvsp/*52*/))-(1))));
/*]*/
}
/*FI]*/
break;
case 8:
(/*SFN*/C->_yyval/*60*/)=/*(IRF4.1yyval_default*/NULL/*)*/;
/*[IF*/
if(!(/*(IRF4.7ignored*/((/*RF2*/(C)->_ignored_level/*225*/))!=(0)/*)*/)){
/*[IRF3.5undefine_value*/r122remove(((T122*)((/*RF2*/(C)->_defined_values/*217*/))),r43yytype1(X74item((/*RF2*/(C)->_yyvs/*44*/),((/*RF2*/(C)->_yyvsp/*52*/))-(1))));
/*]*/
}
/*FI]*/
break;
case 9:
(/*SFN*/C->_yyval/*60*/)=/*(IRF4.1yyval_default*/NULL/*)*/;
/*[IF*/
if(!(/*(IRF4.7ignored*/((/*RF2*/(C)->_ignored_level/*225*/))!=(0)/*)*/)){
r43process_include(C,r43yytype1(X74item((/*RF2*/(C)->_yyvs/*44*/),((/*RF2*/(C)->_yyvsp/*52*/))-(1))));
}
/*FI]*/
break;
case 10:
(/*SFN*/C->_yyval/*60*/)=/*(IRF4.1yyval_default*/NULL/*)*/;
(/*SFN*/C->_if_level/*221*/)=((/*RF2*/(C)->_if_level/*221*/))+(1);
/*[IF*/
if(r6_px_and(!(/*(IRF4.7ignored*/((/*RF2*/(C)->_ignored_level/*225*/))!=(0)/*)*/),!(r43yytype2(X74item((/*RF2*/(C)->_yyvs/*44*/),((/*RF2*/(C)->_yyvsp/*52*/))-(1)))))){
(/*SFN*/C->_ignored_level/*225*/)=(/*RF2*/(C)->_if_level/*221*/);
}
/*FI]*/
break;
case 11:
(/*SFN*/C->_yyval/*60*/)=/*(IRF4.1yyval_default*/NULL/*)*/;
(/*SFN*/C->_if_level/*221*/)=((/*RF2*/(C)->_if_level/*221*/))+(1);
/*[IF*/
if(r6_px_and(!(/*(IRF4.7ignored*/((/*RF2*/(C)->_ignored_level/*225*/))!=(0)/*)*/),r43yytype2(X74item((/*RF2*/(C)->_yyvs/*44*/),((/*RF2*/(C)->_yyvsp/*52*/))-(1))))){
(/*SFN*/C->_ignored_level/*225*/)=(/*RF2*/(C)->_if_level/*221*/);
}
/*FI]*/
break;
case 12:
_yyval2=/*(IRF4.6is_defined*/r122has(((T122*)((/*RF2*/(C)->_defined_values/*217*/))),r43yytype1(X74item((/*RF2*/(C)->_yyvs/*44*/),(/*RF2*/(C)->_yyvsp/*52*/))))/*)*/;
(/*SFN*/C->_yyval/*60*/)=T6toT40(_yyval2);
break;
case 13:
_yyval2=r43yytype2(X74item((/*RF2*/(C)->_yyvs/*44*/),((/*RF2*/(C)->_yyvsp/*52*/))-(1)));
(/*SFN*/C->_yyval/*60*/)=T6toT40(_yyval2);
break;
case 14:
_yyval2=r6_px_and(r43yytype2(X74item((/*RF2*/(C)->_yyvs/*44*/),((/*RF2*/(C)->_yyvsp/*52*/))-(2))),r43yytype2(X74item((/*RF2*/(C)->_yyvs/*44*/),(/*RF2*/(C)->_yyvsp/*52*/))));
(/*SFN*/C->_yyval/*60*/)=T6toT40(_yyval2);
break;
case 15:
_yyval2=r6_px_or(r43yytype2(X74item((/*RF2*/(C)->_yyvs/*44*/),((/*RF2*/(C)->_yyvsp/*52*/))-(2))),r43yytype2(X74item((/*RF2*/(C)->_yyvs/*44*/),(/*RF2*/(C)->_yyvsp/*52*/))));
(/*SFN*/C->_yyval/*60*/)=T6toT40(_yyval2);
break;
case 16:
_yyval2=!(r43yytype2(X74item((/*RF2*/(C)->_yyvs/*44*/),(/*RF2*/(C)->_yyvsp/*52*/))));
(/*SFN*/C->_yyval/*60*/)=T6toT40(_yyval2);
break;
case 17:
(/*SFN*/C->_yyval/*60*/)=/*(IRF4.1yyval_default*/NULL/*)*/;
/*[IF*/
if(((/*RF2*/(C)->_ignored_level/*225*/))==((/*RF2*/(C)->_if_level/*221*/))){
(/*SFN*/C->_ignored_level/*225*/)=0;
}
/*FI]*/
(/*SFN*/C->_if_level/*221*/)=((/*RF2*/(C)->_if_level/*221*/))-(1);
break;
case 18:
(/*SFN*/C->_yyval/*60*/)=/*(IRF4.1yyval_default*/NULL/*)*/;
/*[IF*/
if(!(/*(IRF4.7ignored*/((/*RF2*/(C)->_ignored_level/*225*/))!=(0)/*)*/)){
(/*SFN*/C->_ignored_level/*225*/)=(/*RF2*/(C)->_if_level/*221*/);
}
 else if(((/*RF2*/(C)->_ignored_level/*225*/))==((/*RF2*/(C)->_if_level/*221*/))){
(/*SFN*/C->_ignored_level/*225*/)=0;
}
/*FI]*/
break;
default:;
(/*SFN*/C->_yyval/*60*/)=/*(IRF4.1yyval_default*/NULL/*)*/;
}
}/*INSPECT]*/
}

void r43yy_load_input_buffer(T43* C){
r43yy_set_content(C,/*SSWARF2*//*X80content*/(/*RF2*/((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))->_content/*4*/));
(/*SFN*/C->_yy_end/*105*/)=/*SSWARF2*//*X80index*/(/*RF2*/((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))->_index/*24*/);
(/*SFN*/C->_yy_start/*109*/)=(/*RF2*/(C)->_yy_end/*105*/);
(/*SFN*/C->_yy_line/*113*/)=/*SSWARF2*//*X80line*/(/*RF2*/((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))->_line/*20*/);
(/*SFN*/C->_yy_column/*117*/)=/*SSWARF2*//*X80column*/(/*RF2*/((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))->_column/*16*/);
(/*SFN*/C->_yy_position/*121*/)=/*SSWARF2*//*X80position*/(/*RF2*/((T79*)((/*RF2*/(C)->_input_buffer/*81*/)))->_position/*12*/);
}
T0*oBC43yytranslate_template=NULL;
int fBC43yytranslate_template=0;

T0* r43yytranslate_template(void){
if(fBC43yytranslate_template==0){fBC43yytranslate_template=1;{
oBC43yytranslate_template=r43yyfixed_array(se_ma172(271,
0,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
16,
2,
2,
2,
2,
2,
2,
17,
18,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15));
}}
return oBC43yytranslate_template;
}

T0* r43yy_fixed_array(T0* a1){
T0* R=NULL;
R=r110to_fixed_array(a1);
return R;
}
T0*oBC20INPUT_STREAM_=NULL;

T0* r43text(T43* C){
T0* R=NULL;
/*[IF*/
if(((/*RF2*/(C)->_yy_start/*109*/))<((/*RF2*/(C)->_yy_end/*105*/))){
R=r112substring((/*RF2*/(C)->_yy_content/*101*/),(/*RF2*/(C)->_yy_start/*109*/),((/*RF2*/(C)->_yy_end/*105*/))-(1));
}
else{
{T7*n=((T7*)se_malloc(sizeof(*n))/*16*/);
*n=M7;
r7make(n,0);
R=((T0*)n);
}
}
/*FI]*/
return R;
}

T2 r43text_count(T43* C){
T2 R=0;
R=((/*RF2*/(C)->_yy_end/*105*/))-((/*RF2*/(C)->_yy_start/*109*/));
return R;
}

T2 r43yy_previous_state(T43* C){
T2 R=0;
T2 _yy_cp=0;
T2 _yy_nb=0;
T2 _yy_c=0;
R=((/*RF2*/(C)->_yy_start_state/*97*/))+(r43yy_at_beginning_of_line(C));
/*[IF*/
/*AF*//*AE*/
/*FI]*/
_yy_cp=((/*RF2*/(C)->_yy_start/*109*/))+((/*RF2*/(C)->_yy_more_len/*126*/));
_yy_nb=(/*RF2*/(C)->_yy_end/*105*/);
while (!((_yy_cp)>=(_yy_nb)))
{
_yy_c=T3code(/*(IRF4.6item*/((/*RF2*/((T7*)((/*RF2*/(C)->_yy_content/*101*/)))->_storage/*4*/))[(_yy_cp)-(1)]/*)*/);
/*[IF*/
if((_yy_c)==(0)){
_yy_c=1;
}
 else if(((/*RF2*/(C)->_yy_ec/*154*/))!=((void*)(NULL))){
_yy_c=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_ec/*154*/)))->_storage/*4*/))[_yy_c]/*)*/;
}
/*FI]*/
/*[IF*/
{/*AT*//*[IF*/
if((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_accept/*162*/)))->_storage/*4*/))[R]/*)*/)!=(0)){
(/*SFN*/C->_yy_last_accepting_state/*130*/)=R;
(/*SFN*/C->_yy_last_accepting_cpos/*134*/)=_yy_cp;
}
/*FI]*/
}
/*FI]*/
while (!((/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_chk/*142*/)))->_storage/*4*/))[(/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_base/*146*/)))->_storage/*4*/))[R]/*)*/)+(_yy_c)]/*)*/)==(R)))
{
R=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_def/*150*/)))->_storage/*4*/))[R]/*)*/;
/*[IF*/
if((((/*RF2*/(C)->_yy_meta/*158*/))!=((void*)(NULL)))&&((R)>=(67))){
_yy_c=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_meta/*158*/)))->_storage/*4*/))[_yy_c]/*)*/;
}
/*FI]*/
}
R=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_nxt/*138*/)))->_storage/*4*/))[(/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yy_base/*146*/)))->_storage/*4*/))[R]/*)*/)+(_yy_c)]/*)*/;
/*[IF*/
/*AF*//*AE*/
/*FI]*/
_yy_cp=(_yy_cp)+(1);
}
return R;
}

T6 r43wrap(T43* C){
T6 R=0;
T0* _old_buffer=NULL;
/*[IF*/
if(!(/*(IRF4.7is_empty*/((/*RF2*/((T106*)((/*RF2*/(C)->_include_stack/*229*/)))->_count/*4*/))==(0)/*)*/)){
_old_buffer=(/*RF2*/(C)->_input_buffer/*81*/);
if(NULL!=(_old_buffer)){
switch(((T0*)_old_buffer)->id){
case 79:
break;
default:
_old_buffer=NULL;
}
}r43set_input_buffer(C,r106item((T106*)((/*RF2*/(C)->_include_stack/*229*/))));
r106remove((T106*)((/*RF2*/(C)->_include_stack/*229*/)));
/*[IF*/
if((_old_buffer)!=((void*)(NULL))){
r92close((/*RF2*/(((T79*)_old_buffer))->_file/*35*/));
}
/*FI]*/
r43set_start_condition(C,0);
}
else{
R=1;
}
/*FI]*/
return R;
}

T2 r43yy_translate(T43* C,T2 a1){
T2 R=0;
/*[IF*/
if((a1)<=(270)){
R=/*(IRF4.6item*/((/*RF2*/((T76*)((/*RF2*/(C)->_yytranslate/*8*/)))->_storage/*4*/))[a1]/*)*/;
}
else{
R=26;
}
/*FI]*/
return R;
}

void r43report_error(T43* C,T0* a1){
T0* _an_error=NULL;
T0* _file_buffer=NULL;
T0* _filename=NULL;
_file_buffer=(/*RF2*/(C)->_input_buffer/*81*/);
if(NULL!=(_file_buffer)){
switch(((T0*)_file_buffer)->id){
case 79:
break;
default:
_file_buffer=NULL;
}
}/*[IF*/
if((_file_buffer)!=((void*)(NULL))){
_filename=r92name((/*RF2*/(((T79*)_file_buffer))->_file/*35*/));
}
else{
_filename=((T0*)ms43_449403);
}
/*FI]*/
{T81*n=((T81*)se_malloc(sizeof(*n))/*8*/);
*n=M81;
r81make(n,_filename,(/*RF2*/(C)->_line_nb/*199*/));
_an_error=((T0*)n);
}
r83report_error((T83*)((/*RF2*/(C)->_error_handler/*212*/)),_an_error);
}
T0*oBC43yyr2_template=NULL;
int fBC43yyr2_template=0;

T0* r43yyr2_template(void){
if(fBC43yyr2_template==0){fBC43yyr2_template=1;{
oBC43yyr2_template=r43yyfixed_array(se_ma172(19,
0,
1,
0,
1,
2,
3,
5,
3,
3,
3,
3,
3,
1,
3,
3,
3,
2,
2,
2));
}}
return oBC43yyr2_template;
}
T0*oBC43yydefgoto_template=NULL;
int fBC43yydefgoto_template=0;

T0* r43yydefgoto_template(void){
if(fBC43yydefgoto_template==0){fBC43yydefgoto_template=1;{
oBC43yydefgoto_template=r43yyfixed_array(se_ma172(7,
15,
39,
6,
7,
8,
30,
31));
}}
return oBC43yydefgoto_template;
}

T0* r43new_file_buffer(T0* a1){
T0* R=NULL;
{T79*n=((T79*)se_malloc(sizeof(*n))/*40*/);
*n=M79;
/*[IRF3.6make*/{T79* C1=n;
T0* b1=a1;
r79make_with_size(C1,b1,16384);
}/*]*/
R=((T0*)n);
}
return R;
}

T3 r43text_item(T43* C,T2 a1){
T3 R=0;
R=/*(IRF4.6item*/((/*RF2*/((T7*)((/*RF2*/(C)->_yy_content/*101*/)))->_storage/*4*/))[((((/*RF2*/(C)->_yy_start/*109*/))+(a1))-(1))-(1)]/*)*/;
return R;
}

void r43clear_stacks(T43* C){
X69clear_all((/*RF2*/(C)->_FIXED_ARRAY_/*73*/),(/*RF2*/(C)->_yyvs/*44*/));
}
T0*oBC17Arguments=NULL;
int fBC17Arguments=0;

T0* r167Arguments(void){
if(fBC17Arguments==0){fBC17Arguments=1;{
{T88*n=((T88*)se_malloc(sizeof(*n))/*8*/);
*n=M88;
oBC17Arguments=((T0*)n);
/*[IRF3.3make*/((((T88*)(n)))->_program_name/*4*/)=(r88argument(0));
/*]*/
}
}}
return oBC17Arguments;
}

void r167make(T167* C,T0* a1){
{T86*n=((T86*)se_malloc(sizeof(*n))/*20*/);
*n=M86;
r86make(n,1,1);
(/*SFN*/C->_parameters/*4*/)=((T0*)n);
}
/*[IRF3.6put*/{T86* C1=(T86*)((/*RF2*/(C)->_parameters/*4*/));
T0* b1=a1;
T2 b2=1;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}

T0* r167message(T167* C,T0* a1){
T0* R=NULL;
T0* _str=NULL;
T2 _i=0;
T2 _j=0;
T2 _nb=0;
T3 _c=0;
T6 _stop=0;
T6 _lb=0;
T6 _rb=0;
_i=1;
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
R=r84make(_nb);
while (!((_i)>(_nb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
_i=(_i)+(1);
/*[IF*/
if((_c)!=(((T3)'\44'))){
r7append_character(((T7*)R),_c);
}
 else if((_i)>(_nb)){
r7append_character(((T7*)R),((T3)'\44'));
}
else{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\44'))){
r7append_character(((T7*)R),((T3)'\44'));
_i=(_i)+(1);
}
else{
_str=r84make(5);
/*[IF*/
if((_c)==(((T3)'\173'))){
_lb=1;
_rb=0;
_i=(_i)+(1);
while (!(r6_px_or((_i)>(_nb),_rb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\175'))){
_rb=1;
}
else{
r7append_character(((T7*)_str),_c);
}
/*FI]*/
_i=(_i)+(1);
}
}
else{
_lb=0;
_rb=0;
_stop=0;
while (!(r6_px_or((_i)>(_nb),_stop)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[INSPECT*/
{int z1=_c;
switch(z1){
case 48:
case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
r7append_character(((T7*)_str),_c);
_i=(_i)+(1);
break;
default:;
_stop=1;
}
}/*INSPECT]*/
}
}
/*FI]*/
/*[IF*/
if(r84is_integer(_str)){
_j=r7to_integer(((T7*)_str));
/*[IF*/
if(r86valid_index((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j)){
r7append_string(((T7*)R),r86item((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j));
}
 else if((_j)==(0)){
r7append_string(((T7*)R),(/*RF2*/((T88*)(r167Arguments()))->_program_name/*4*/));
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
return R;
}

T0* r167twin(T167* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T167*)R)=*C;
return R;
}

T0* r167default_message(T167* C){
T0* R=NULL;
R=r167message(C,((T0*)ms167_1158552108));
return R;
}
T0*oBC35STRING_=NULL;

T0* r149current_working_directory(T149* C){
T0* R=NULL;
r156connect_to_current_working_directory(&((/*RF2*/(C)->_basic_directory/*5*/)));
R=r149clone(oBC156last_entry);
r156disconnect(&((/*RF2*/(C)->_basic_directory/*5*/)));
return R;
}

T0* r149clone(T0* a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((void*)(NULL))){
R=X10twin(a1);
}
/*FI]*/
return R;
}

void r149old_read_character(T149* C){
/*[IF*/
if((/*RF2*/(C)->_push_back_flag/*4*/)){
(/*SFN*/C->_push_back_flag/*4*/)=0;
}
else{
(/*SFN*/C->_memory/*13*/)=basic_io_getc(basic_io_stdin);
}
/*FI]*/
}
T6 oBC98is_windows=0;
int fBC98is_windows=0;

T6 r149is_windows(T149* C){
if(fBC98is_windows==0){fBC98is_windows=1;{
T0* _cwd=NULL;
_cwd=r149current_working_directory(C);
/*[IF*/
if(((/*RF2*/(((T7*)_cwd))->_count/*8*/))>=(3)){
oBC98is_windows=r6_px_and((/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(2)-(1)]/*)*/)==(((T3)'\72')),(/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(3)-(1)]/*)*/)==(((T3)'\134')));
}
/*FI]*/
}}
return oBC98is_windows;
}

T6 r149old_end_of_file(T149* C){
T6 R=0;
/*[IF*/
if(!((/*RF2*/(C)->_push_back_flag/*4*/))){
R=((/*RF2*/(C)->_memory/*13*/))==(basic_io_eof);
}
/*FI]*/
return R;
}

void r149make(T149* C){
(/*SFN*/C->_name/*17*/)=((T0*)ms149_89510);
/*[IRF3.1old_make*//*]*/
(/*SFN*/C->_end_of_file/*21*/)=0;
}
T6 oBC98is_unix=0;
int fBC98is_unix=0;

T6 r149is_unix(T149* C){
if(fBC98is_unix==0){fBC98is_unix=1;{
T0* _cwd=NULL;
_cwd=r149current_working_directory(C);
/*[IF*/
if(((/*RF2*/(((T7*)_cwd))->_count/*8*/))>(0)){
oBC98is_unix=(/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(1)-(1)]/*)*/)==(((T3)'\57'));
}
/*FI]*/
}}
return oBC98is_unix;
}

T0* r149twin(T149* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T149*)R)=*C;
return R;
}

void r83report_message(T83* C,T0* a1){
/*[IF*/
if(((/*RF2*/(C)->_message_file/*12*/))!=((void*)(NULL))){
X26put_string((/*RF2*/(C)->_message_file/*12*/),r83message(a1));
X26put_character((/*RF2*/(C)->_message_file/*12*/),((T3)'\n'));
}
/*FI]*/
}

T0* r83message(T0* a1){
T0* R=NULL;
R=X82default_message(a1);
return R;
}

T0* r83twin(T83* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T83*)R)=*C;
return R;
}

void r83make_standard(T83* C){
(/*SFN*/C->_error_file/*4*/)=r95error();
(/*SFN*/C->_warning_file/*8*/)=r95error();
(/*SFN*/C->_message_file/*12*/)=r95output();
}

void r83report_error(T83* C,T0* a1){
/*[IF*/
if(((/*RF2*/(C)->_error_file/*4*/))!=((void*)(NULL))){
X26put_string((/*RF2*/(C)->_error_file/*4*/),r83message(a1));
X26put_character((/*RF2*/(C)->_error_file/*4*/),((T3)'\n'));
}
/*FI]*/
}
T0*oBC29unix_file_system=NULL;

T6 r23is_closed(T23* C){
T6 R=0;
R=!(/*(IRF4.5is_open_write*//*(IRF4.7old_is_open_write*/((/*RF2*/(C)->_path/*8*/))!=(NULL)/*)*//*)*/);
return R;
}

void r23old_close(T23* C){
basic_io_fclose((/*RF2*/(C)->_output_stream/*12*/));
(/*SFN*/C->_path/*8*/)=NULL;
}
T0*oBC29file_system=NULL;
int fBC29file_system=0;

T0* r23file_system(void){
if(fBC29file_system==0){fBC29file_system=1;{
/*[IF*/
if(X98is_windows(oBC30operating_system)){
oBC29file_system=oBC29windows_file_system;
}
 else if(X98is_unix(oBC30operating_system)){
oBC29file_system=oBC29unix_file_system;
}
else{
oBC29file_system=oBC29unix_file_system;
}
/*FI]*/
}}
return oBC29file_system;
}

void r23close(T23* C){
struct rescue_context rc;
T6 _rescued=0;
if(SETJMP(rc.jb)!=0){/*rescue*/
/*[IF*/
if(!(_rescued)){
_rescued=1;
goto retry_tag;
}
/*FI]*/
internal_exception_handler(Routine_failure);
}
retry_tag:
rc.next = rescue_context_top;
rescue_context_top = &rc;
/*[IF*/
if(!(_rescued)){
r23old_close(C);
}
/*FI]*/
rescue_context_top = rc.next;
}

void r23make(T23* C,T0* a1){
(/*SFN*/C->_name/*4*/)=a1;
/*[IRF3.1old_make*//*]*/
}
T0*oBC30operating_system=NULL;

void r23old_put_string(T23* C,T0* a1){
T2 _i=0;
_i=1;
while (!((_i)>((/*RF2*/(((T7*)a1))->_count/*8*/))))
{
/*[IRF3.6old_put_character*/{T23* C1=C;
T3 b1=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
basic_io_putc(b1,(/*RF2*/(C1)->_output_stream/*12*/));
}/*]*/
_i=(_i)+(1);
}
}

void r23connect_to(T23* C,T0* a1){
T8 _p=NULL;
_p=r7to_external(((T7*)a1));
(/*SFN*/C->_output_stream/*12*/)=basic_io_text_file_write_open(_p);
/*[IF*/
if((NULL!=(/*RF2*/(C)->_output_stream/*12*/))){
(/*SFN*/C->_path/*8*/)=a1;
}
/*FI]*/
}

void r23recursive_open_write(T23* C){
T0* _a_dirname=NULL;
T0* _a_pathname=NULL;
T0* _a_dir=NULL;
r23open_write(C);
/*[IF*/
if(!(/*(IRF4.5is_open_write*//*(IRF4.7old_is_open_write*/((/*RF2*/(C)->_path/*8*/))!=(NULL)/*)*//*)*/)){
_a_pathname=X159canonical_pathname(r23file_system(),(/*RF2*/(C)->_name/*4*/));
_a_dirname=X159dirname(r23file_system(),_a_pathname);
{T154*n=((T154*)se_malloc(sizeof(*n))/*25*/);
*n=M154;
/*[IRF3.3make*/((((T154*)(n)))->_name/*4*/)=(_a_dirname);
/*]*/
_a_dir=((T0*)n);
}
/*[IF*/
if(!(r154exists(((T154*)_a_dir)))){
r154recursive_create_directory(((T154*)_a_dir));
/*[IF*/
if(r154exists(((T154*)_a_dir))){
r23open_write(C);
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r23twin(T23* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T23*)R)=*C;
return R;
}

void r23open_write(T23* C){
struct rescue_context rc;
T6 _rescued=0;
if(SETJMP(rc.jb)!=0){/*rescue*/
/*[IF*/
if(!(_rescued)){
_rescued=1;
goto retry_tag;
}
/*FI]*/
internal_exception_handler(Routine_failure);
}
retry_tag:
rc.next = rescue_context_top;
rescue_context_top = &rc;
/*[IF*/
if(!(_rescued)){
/*[IF*/
if(((/*RF2*/((T7*)((/*RF2*/(C)->_name/*4*/)))->_count/*8*/))>(0)){
/*[IRF3.6old_open_write*/{T23* C1=C;
r23connect_to(C1,(/*RF2*/(C1)->_name/*4*/));
}/*]*/
}
/*FI]*/
}
 else if(!(r23is_closed(C))){
r23close(C);
}
/*FI]*/
rescue_context_top = rc.next;
}
T0*oBC29windows_file_system=NULL;

T0* r166Arguments(void){
if(fBC17Arguments==0){fBC17Arguments=1;{
{T88*n=((T88*)se_malloc(sizeof(*n))/*8*/);
*n=M88;
oBC17Arguments=((T0*)n);
/*[IRF3.3make*/((((T88*)(n)))->_program_name/*4*/)=(r88argument(0));
/*]*/
}
}}
return oBC17Arguments;
}

void r166make(T166* C,T0* a1){
{T86*n=((T86*)se_malloc(sizeof(*n))/*20*/);
*n=M86;
r86make(n,1,1);
(/*SFN*/C->_parameters/*4*/)=((T0*)n);
}
/*[IRF3.6put*/{T86* C1=(T86*)((/*RF2*/(C)->_parameters/*4*/));
T0* b1=a1;
T2 b2=1;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}

T0* r166message(T166* C,T0* a1){
T0* R=NULL;
T0* _str=NULL;
T2 _i=0;
T2 _j=0;
T2 _nb=0;
T3 _c=0;
T6 _stop=0;
T6 _lb=0;
T6 _rb=0;
_i=1;
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
R=r84make(_nb);
while (!((_i)>(_nb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
_i=(_i)+(1);
/*[IF*/
if((_c)!=(((T3)'\44'))){
r7append_character(((T7*)R),_c);
}
 else if((_i)>(_nb)){
r7append_character(((T7*)R),((T3)'\44'));
}
else{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\44'))){
r7append_character(((T7*)R),((T3)'\44'));
_i=(_i)+(1);
}
else{
_str=r84make(5);
/*[IF*/
if((_c)==(((T3)'\173'))){
_lb=1;
_rb=0;
_i=(_i)+(1);
while (!(r6_px_or((_i)>(_nb),_rb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\175'))){
_rb=1;
}
else{
r7append_character(((T7*)_str),_c);
}
/*FI]*/
_i=(_i)+(1);
}
}
else{
_lb=0;
_rb=0;
_stop=0;
while (!(r6_px_or((_i)>(_nb),_stop)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[INSPECT*/
{int z1=_c;
switch(z1){
case 48:
case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
r7append_character(((T7*)_str),_c);
_i=(_i)+(1);
break;
default:;
_stop=1;
}
}/*INSPECT]*/
}
}
/*FI]*/
/*[IF*/
if(r84is_integer(_str)){
_j=r7to_integer(((T7*)_str));
/*[IF*/
if(r86valid_index((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j)){
r7append_string(((T7*)R),r86item((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j));
}
 else if((_j)==(0)){
r7append_string(((T7*)R),(/*RF2*/((T88*)(r166Arguments()))->_program_name/*4*/));
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
return R;
}

T0* r166twin(T166* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T166*)R)=*C;
return R;
}

T0* r166default_message(T166* C){
T0* R=NULL;
R=r166message(C,((T0*)ms166_1515383187));
return R;
}

T0* r161dirname(T0* a1){
T0* R=NULL;
T2 _i=0;
/*[IF*/
if(r161is_root_directory(a1)){
R=a1;
}
else{
_i=(/*RF2*/(((T7*)a1))->_count/*8*/);
while (!(((_i)<(1))||((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)!=(((T3)'\134')))))
{
_i=(_i)-(1);
}
while (!(((_i)<(1))||((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)==(((T3)'\134')))))
{
_i=(_i)-(1);
}
/*[IF*/
if((_i)<(1)){
R=((T0*)ms161_46);
}
else{
while (!(((_i)<(1))||((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)!=(((T3)'\134')))))
{
_i=(_i)-(1);
}
/*[IF*/
if((_i)<(1)){
R=oBC161root_directory;
}
else{
R=r7substring(((T7*)a1),1,_i);
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
return R;
}

T0* r161string_to_pathname(T0* a1){
T0* R=NULL;
T2 _i=0;
T2 _nb=0;
T2 _j=0;
T2 _k=0;
T0* _str=NULL;
T6 _has_hostname=0;
T6 _has_drive=0;
{T174*n=((T174*)se_malloc(sizeof(*n))/*21*/);
*n=M174;
r174make(n);
R=((T0*)n);
}
/*[IRF3.3set_relative*/((((T174*)(((T174*)R))))->_is_relative/*4*/)=(1);
/*]*/
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
/*[IF*/
if(((_nb)>(2))&&(r6_px_and((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(1)-(1)]/*)*/)==(((T3)'\134')),(/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(2)-(1)]/*)*/)==(((T3)'\134'))))){
_has_hostname=1;
/*[IRF3.3set_relative*/((((T174*)(((T174*)R))))->_is_relative/*4*/)=(0);
/*]*/
_i=3;
}
 else if(((_nb)>(0))&&((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(1)-(1)]/*)*/)==(((T3)'\134')))){
/*[IRF3.3set_relative*/((((T174*)(((T174*)R))))->_is_relative/*4*/)=(0);
/*]*/
_i=2;
}
else{
_has_drive=1;
_i=1;
}
/*FI]*/
while (!((_i)>(_nb)))
{
while (!(((_i)>(_nb))||((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)!=(((T3)'\134')))))
{
_i=(_i)+(1);
}
/*[IF*/
if((_i)<=(_nb)){
_j=_i;
while (!(((_i)>(_nb))||((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)==(((T3)'\134')))))
{
_i=(_i)+(1);
}
_k=(_i)-(1);
_str=r7substring(((T7*)a1),_j,_k);
/*[IF*/
if(r7is_equal(((T7*)_str),((T0*)ms161_46))){
/*[IRF3.6append_current*/{T174* C1=((T174*)R);
r174append_name(C1,((T0*)ms174_46));
}/*]*/
}
 else if(r7is_equal(((T7*)_str),((T0*)ms161_276))){
/*[IRF3.6append_parent*/{T174* C1=((T174*)R);
r174append_name(C1,((T0*)ms174_276));
}/*]*/
}
 else if(_has_hostname){
/*[IRF3.3set_hostname*/((((T174*)(((T174*)R))))->_hostname/*9*/)=(_str);
/*]*/
}
 else if(_has_drive){
/*[IF*/
if((/*(IRF4.6item*/((/*RF2*/(((T7*)_str))->_storage/*4*/))[((/*RF2*/(((T7*)_str))->_count/*8*/))-(1)]/*)*/)==(((T3)'\72'))){
/*[IRF3.3set_drive*/((((T174*)(((T174*)R))))->_drive/*5*/)=(_str);
/*]*/
/*[IRF3.3set_relative*/((((T174*)(((T174*)R))))->_is_relative/*4*/)=(0);
/*]*/
}
else{
r174append_name(((T174*)R),_str);
}
/*FI]*/
}
else{
r174append_name(((T174*)R),_str);
}
/*FI]*/
_has_hostname=0;
_has_drive=0;
}
/*FI]*/
}
return R;
}
T0*oBC161root_directory=NULL;

T6 r161is_root_directory(T0* a1){
T6 R=0;
T2 _i=0;
T2 _nb=0;
T6 _stop=0;
T6 _found=0;
T3 _c=0;
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
/*[IF*/
if(((_nb)>=(4))&&((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(1)-(1)]/*)*/)==(((T3)'\134')))){
/*[IF*/
if(r6_px_and((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(2)-(1)]/*)*/)==(((T3)'\134')),(/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(3)-(1)]/*)*/)!=(((T3)'\134')))){
_i=4;
while (!(r6_px_or((_i)>(_nb),_found)))
{
/*[IF*/
if((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)==(((T3)'\134'))){
_found=1;
}
else{
_i=(_i)+(1);
}
/*FI]*/
}
R=r6_px_and(_found,(_i)==(_nb));
}
/*FI]*/
}
 else if((_nb)>=(3)){
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(1)-(1)]/*)*/;
/*[IF*/
if(r6_px_and((_c)!=(((T3)'\134')),(_c)!=(((T3)'\72')))){
_i=2;
while (!(r6_px_or(r6_px_or((_i)>(_nb),_stop),_found)))
{
/*[INSPECT*/
{int z1=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
switch(z1){
case 92:
_stop=1;
break;
case 58:
_found=1;
break;
default:;
_i=(_i)+(1);
}
}/*INSPECT]*/
}
/*[IF*/
if(r6_px_and(_found,((_i)+(1))==(_nb))){
R=(/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_nb)-(1)]/*)*/)==(((T3)'\134'));
}
/*FI]*/
}
/*FI]*/
}
 else if((_nb)==(1)){
R=(/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(1)-(1)]/*)*/)==(((T3)'\134'));
}
/*FI]*/
return R;
}

T0* r161pathname_to_string(T0* a1){
T0* R=NULL;
T2 _i=0;
T2 _nb=0;
T0* _a_drive=NULL;
T0* _a_hostname=NULL;
R=r84make(50);
_a_drive=(/*RF2*/(((T174*)a1))->_drive/*5*/);
/*[IF*/
if((_a_drive)!=((void*)(NULL))){
r7append_string(((T7*)R),_a_drive);
r7append_character(((T7*)R),((T3)'\134'));
}
else{
_a_hostname=(/*RF2*/(((T174*)a1))->_hostname/*9*/);
/*[IF*/
if((_a_hostname)!=((void*)(NULL))){
r7append_character(((T7*)R),((T3)'\134'));
r7append_character(((T7*)R),((T3)'\134'));
r7append_string(((T7*)R),_a_hostname);
r7append_character(((T7*)R),((T3)'\134'));
}
 else if(!((/*RF2*/(((T174*)a1))->_is_relative/*4*/))){
r7append_string(((T7*)R),oBC161root_directory);
}
/*FI]*/
}
/*FI]*/
_nb=(/*RF2*/(((T174*)a1))->_count/*13*/);
_i=1;
while (!((_i)>=(_nb)))
{
/*[IF*/
if(r174is_current(((T174*)a1),_i)){
r7append_string(((T7*)R),((T0*)ms161_46));
}
 else if(r174is_parent(((T174*)a1),_i)){
r7append_string(((T7*)R),((T0*)ms161_276));
}
else{
r7append_string(((T7*)R),/*(IRF4.6item*/r86item(((T86*)((/*RF2*/(((T174*)a1))->_components/*17*/))),_i)/*)*/);
}
/*FI]*/
r7append_character(((T7*)R),((T3)'\134'));
_i=(_i)+(1);
}
/*[IF*/
if((_i)==(_nb)){
/*[IF*/
if(r174is_current(((T174*)a1),_i)){
r7append_string(((T7*)R),((T0*)ms161_46));
}
 else if(r174is_parent(((T174*)a1),_i)){
r7append_string(((T7*)R),((T0*)ms161_276));
}
else{
r7append_string(((T7*)R),/*(IRF4.6item*/r86item(((T86*)((/*RF2*/(((T174*)a1))->_components/*17*/))),_i)/*)*/);
}
/*FI]*/
}
/*FI]*/
return R;
}

T0* r161twin(T161* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T161*)R)=*C;
return R;
}

T0* r161canonical_pathname(T0* a1){
T0* R=NULL;
T0* _p=NULL;
_p=r161string_to_pathname(a1);
r174set_canonical(((T174*)_p));
R=r161pathname_to_string(_p);
return R;
}

T0* r153Arguments(void){
if(fBC17Arguments==0){fBC17Arguments=1;{
{T88*n=((T88*)se_malloc(sizeof(*n))/*8*/);
*n=M88;
oBC17Arguments=((T0*)n);
/*[IRF3.3make*/((((T88*)(n)))->_program_name/*4*/)=(r88argument(0));
/*]*/
}
}}
return oBC17Arguments;
}

void r153make(T153* C,T0* a1){
{T86*n=((T86*)se_malloc(sizeof(*n))/*20*/);
*n=M86;
r86make(n,1,1);
(/*SFN*/C->_parameters/*4*/)=((T0*)n);
}
/*[IRF3.6put*/{T86* C1=(T86*)((/*RF2*/(C)->_parameters/*4*/));
T0* b1=a1;
T2 b2=1;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}

T0* r153message(T153* C,T0* a1){
T0* R=NULL;
T0* _str=NULL;
T2 _i=0;
T2 _j=0;
T2 _nb=0;
T3 _c=0;
T6 _stop=0;
T6 _lb=0;
T6 _rb=0;
_i=1;
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
R=r84make(_nb);
while (!((_i)>(_nb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
_i=(_i)+(1);
/*[IF*/
if((_c)!=(((T3)'\44'))){
r7append_character(((T7*)R),_c);
}
 else if((_i)>(_nb)){
r7append_character(((T7*)R),((T3)'\44'));
}
else{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\44'))){
r7append_character(((T7*)R),((T3)'\44'));
_i=(_i)+(1);
}
else{
_str=r84make(5);
/*[IF*/
if((_c)==(((T3)'\173'))){
_lb=1;
_rb=0;
_i=(_i)+(1);
while (!(r6_px_or((_i)>(_nb),_rb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\175'))){
_rb=1;
}
else{
r7append_character(((T7*)_str),_c);
}
/*FI]*/
_i=(_i)+(1);
}
}
else{
_lb=0;
_rb=0;
_stop=0;
while (!(r6_px_or((_i)>(_nb),_stop)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[INSPECT*/
{int z1=_c;
switch(z1){
case 48:
case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
r7append_character(((T7*)_str),_c);
_i=(_i)+(1);
break;
default:;
_stop=1;
}
}/*INSPECT]*/
}
}
/*FI]*/
/*[IF*/
if(r84is_integer(_str)){
_j=r7to_integer(((T7*)_str));
/*[IF*/
if(r86valid_index((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j)){
r7append_string(((T7*)R),r86item((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j));
}
 else if((_j)==(0)){
r7append_string(((T7*)R),(/*RF2*/((T88*)(r153Arguments()))->_program_name/*4*/));
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
return R;
}

T0* r153twin(T153* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T153*)R)=*C;
return R;
}

T0* r153default_message(T153* C){
T0* R=NULL;
R=r153message(C,((T0*)ms153_1606053737));
return R;
}

void r94disconnect(T94* C){
basic_io_fclose((/*RF2*/(C)->_input_stream/*9*/));
(/*SFN*/C->_path/*5*/)=NULL;
}

void r94read_character(T94* C){
/*[IF*/
if((/*RF2*/(C)->_push_back_flag/*4*/)){
(/*SFN*/C->_push_back_flag/*4*/)=0;
}
else{
(/*SFN*/C->_memory/*13*/)=basic_io_getc((/*RF2*/(C)->_input_stream/*9*/));
}
/*FI]*/
}

T6 r94end_of_input(T94* C){
T6 R=0;
/*[IF*/
if(!((/*RF2*/(C)->_push_back_flag/*4*/))){
R=((/*RF2*/(C)->_memory/*13*/))==(basic_io_eof);
}
/*FI]*/
return R;
}

void r94connect_to(T94* C,T0* a1){
T8 _p=NULL;
_p=r7to_external(((T7*)a1));
(/*SFN*/C->_input_stream/*9*/)=basic_io_text_file_read_open(_p);
/*[IF*/
if((NULL!=(/*RF2*/(C)->_input_stream/*9*/))){
(/*SFN*/C->_push_back_flag/*4*/)=0;
(/*SFN*/C->_memory/*13*/)=T3code(((T3)'\40'));
(/*SFN*/C->_path/*5*/)=a1;
}
/*FI]*/
}

T0* r94twin(T94* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T94*)R)=*C;
return R;
}

T6 r154is_closed(T154* C){
T6 R=0;
R=!(/*(IRF4.6is_connected*/(NULL!=(/*RF2*/((/*RF2*/(C)->_basic_directory/*17*/))._directory_stream/*0*/))/*)*/);
return R;
}

void r154open_read(T154* C){
struct rescue_context rc;
T6 _rescued=0;
if(SETJMP(rc.jb)!=0){/*rescue*/
/*[IF*/
if(!(_rescued)){
_rescued=1;
goto retry_tag;
}
/*FI]*/
internal_exception_handler(Routine_failure);
}
retry_tag:
rc.next = rescue_context_top;
rescue_context_top = &rc;
/*[IF*/
if(!(_rescued)){
/*[IF*/
if(((/*RF2*/((T7*)((/*RF2*/(C)->_name/*4*/)))->_count/*8*/))>(0)){
(/*SFN*/C->_entry_buffer/*13*/)=NULL;
(/*SFN*/C->_end_of_input/*12*/)=0;
r156connect_to(&((/*RF2*/(C)->_basic_directory/*17*/)),(/*RF2*/(C)->_name/*4*/));
}
/*FI]*/
}
 else if(!(r154is_closed(C))){
r154close(C);
}
/*FI]*/
rescue_context_top = rc.next;
}

T0* r154file_system(void){
if(fBC29file_system==0){fBC29file_system=1;{
/*[IF*/
if(X98is_windows(oBC30operating_system)){
oBC29file_system=oBC29windows_file_system;
}
 else if(X98is_unix(oBC30operating_system)){
oBC29file_system=oBC29unix_file_system;
}
else{
oBC29file_system=oBC29unix_file_system;
}
/*FI]*/
}}
return oBC29file_system;
}

void r154create_directory(T154* C){
struct rescue_context rc;
T6 _rescued=0;
T6 _b=0;
if(SETJMP(rc.jb)!=0){/*rescue*/
/*[IF*/
if(!(_rescued)){
_rescued=1;
goto retry_tag;
}
/*FI]*/
internal_exception_handler(Routine_failure);
}
retry_tag:
rc.next = rescue_context_top;
rescue_context_top = &rc;
/*[IF*/
if(!(_rescued)){
/*[IF*/
if(((/*RF2*/((T7*)((/*RF2*/(C)->_name/*4*/)))->_count/*8*/))>(0)){
_b=r156create_new_directory((/*RF2*/(C)->_name/*4*/));
}
/*FI]*/
}
/*FI]*/
rescue_context_top = rc.next;
}

T6 r154is_open_read(T154* C){
T6 R=0;
R=/*(IRF4.6is_connected*/(NULL!=(/*RF2*/((/*RF2*/(C)->_basic_directory/*17*/))._directory_stream/*0*/))/*)*/;
return R;
}

void r154close(T154* C){
struct rescue_context rc;
T6 _rescued=0;
if(SETJMP(rc.jb)!=0){/*rescue*/
/*[IF*/
if(!(_rescued)){
_rescued=1;
goto retry_tag;
}
/*FI]*/
internal_exception_handler(Routine_failure);
}
retry_tag:
rc.next = rescue_context_top;
rescue_context_top = &rc;
/*[IF*/
if(!(_rescued)){
r156disconnect(&((/*RF2*/(C)->_basic_directory/*17*/)));
(/*SFN*/C->_entry_buffer/*13*/)=NULL;
(/*SFN*/C->_last_entry/*8*/)=NULL;
}
/*FI]*/
rescue_context_top = rc.next;
}

T6 r154exists(T154* C){
T6 R=0;
/*[IF*/
if(((/*RF2*/((T7*)((/*RF2*/(C)->_name/*4*/)))->_count/*8*/))>(0)){
R=r154is_readable(C);
}
/*FI]*/
return R;
}

void r154recursive_create_directory(T154* C){
T0* _a_dirname=NULL;
T0* _a_pathname=NULL;
T0* _a_dir=NULL;
r154create_directory(C);
/*[IF*/
if(!(r154exists(C))){
_a_pathname=X159canonical_pathname(r154file_system(),(/*RF2*/(C)->_name/*4*/));
_a_dirname=X159dirname(r154file_system(),_a_pathname);
/*[IF*/
if(!(r7is_equal(((T7*)_a_dirname),_a_pathname))){
{T154*n=((T154*)se_malloc(sizeof(*n))/*25*/);
*n=M154;
/*[IRF3.3make*/((((T154*)(n)))->_name/*4*/)=(_a_dirname);
/*]*/
_a_dir=((T0*)n);
}
/*[IF*/
if(!(r154exists(((T154*)_a_dir)))){
r154recursive_create_directory(((T154*)_a_dir));
/*[IF*/
if(r154exists(((T154*)_a_dir))){
r154create_directory(C);
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r154twin(T154* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T154*)R)=*C;
return R;
}

T6 r154is_readable(T154* C){
T6 R=0;
/*[IF*/
if(((/*RF2*/((T7*)((/*RF2*/(C)->_name/*4*/)))->_count/*8*/))>(0)){
/*[IF*/
if(r154is_open_read(C)){
R=1;
}
else{
r154open_read(C);
/*[IF*/
if(r154is_open_read(C)){
R=1;
r154close(C);
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
return R;
}

void r80set_position(T80* C,T2 a1,T2 a2,T2 a3){
(/*SFN*/C->_position/*12*/)=a1;
(/*SFN*/C->_line/*20*/)=a2;
(/*SFN*/C->_column/*16*/)=a3;
}
T2 oBC80lower=0;
int fBC80lower=0;

T2 r80lower(void){
if(fBC80lower==0){fBC80lower=1;{
oBC80lower=1;
}}
return oBC80lower;
}

void r80make(T80* C,T0* a1){
T0* _buff=NULL;
T2 _nb=0;
_nb=((/*RF2*/(((T7*)a1))->_count/*8*/))+(2);
_buff=r112make(_nb);
r112copy_from_string(_buff,r80lower(),a1);
_nb=(_nb)+((r80lower())-(1));
/*[IRF3.5put*/((/*RF2*/(((T7*)_buff))->_storage/*4*/))[((_nb)-(1))-(1)]=(((T3)'\0'));
/*]*/
/*[IRF3.5put*/((/*RF2*/(((T7*)_buff))->_storage/*4*/))[(_nb)-(1)]=(((T3)'\0'));
/*]*/
r80make_from_buffer(C,_buff);
}

void r80make_from_buffer(T80* C,T0* a1){
T2 _l=0;
_l=r80lower();
(/*SFN*/C->_capacity/*8*/)=((/*RF2*/(((T7*)a1))->_count/*8*/))-(2);
(/*SFN*/C->_upper/*28*/)=((/*RF2*/(C)->_capacity/*8*/))+((_l)-(1));
(/*SFN*/C->_content/*4*/)=a1;
(/*SFN*/C->_index/*24*/)=_l;
(/*SFN*/C->_line/*20*/)=1;
(/*SFN*/C->_column/*16*/)=1;
(/*SFN*/C->_position/*12*/)=1;
(/*SFN*/C->_beginning_of_line/*32*/)=1;
}

T0* r80twin(T80* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T80*)R)=*C;
return R;
}

T0* r146Arguments(void){
if(fBC17Arguments==0){fBC17Arguments=1;{
{T88*n=((T88*)se_malloc(sizeof(*n))/*8*/);
*n=M88;
oBC17Arguments=((T0*)n);
/*[IRF3.3make*/((((T88*)(n)))->_program_name/*4*/)=(r88argument(0));
/*]*/
}
}}
return oBC17Arguments;
}

void r146make(T146* C,T2 a1){
{T86*n=((T86*)se_malloc(sizeof(*n))/*20*/);
*n=M86;
r86make(n,1,1);
(/*SFN*/C->_parameters/*4*/)=((T0*)n);
}
/*[IRF3.6put*/{T86* C1=(T86*)((/*RF2*/(C)->_parameters/*4*/));
T0* b1=r2out(a1);
T2 b2=1;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}

T0* r146message(T146* C,T0* a1){
T0* R=NULL;
T0* _str=NULL;
T2 _i=0;
T2 _j=0;
T2 _nb=0;
T3 _c=0;
T6 _stop=0;
T6 _lb=0;
T6 _rb=0;
_i=1;
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
R=r84make(_nb);
while (!((_i)>(_nb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
_i=(_i)+(1);
/*[IF*/
if((_c)!=(((T3)'\44'))){
r7append_character(((T7*)R),_c);
}
 else if((_i)>(_nb)){
r7append_character(((T7*)R),((T3)'\44'));
}
else{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\44'))){
r7append_character(((T7*)R),((T3)'\44'));
_i=(_i)+(1);
}
else{
_str=r84make(5);
/*[IF*/
if((_c)==(((T3)'\173'))){
_lb=1;
_rb=0;
_i=(_i)+(1);
while (!(r6_px_or((_i)>(_nb),_rb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\175'))){
_rb=1;
}
else{
r7append_character(((T7*)_str),_c);
}
/*FI]*/
_i=(_i)+(1);
}
}
else{
_lb=0;
_rb=0;
_stop=0;
while (!(r6_px_or((_i)>(_nb),_stop)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[INSPECT*/
{int z1=_c;
switch(z1){
case 48:
case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
r7append_character(((T7*)_str),_c);
_i=(_i)+(1);
break;
default:;
_stop=1;
}
}/*INSPECT]*/
}
}
/*FI]*/
/*[IF*/
if(r84is_integer(_str)){
_j=r7to_integer(((T7*)_str));
/*[IF*/
if(r86valid_index((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j)){
r7append_string(((T7*)R),r86item((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j));
}
 else if((_j)==(0)){
r7append_string(((T7*)R),(/*RF2*/((T88*)(r146Arguments()))->_program_name/*4*/));
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
return R;
}

T0* r146twin(T146* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T146*)R)=*C;
return R;
}

T0* r146default_message(T146* C){
T0* R=NULL;
R=r146message(C,((T0*)ms146_434195944));
return R;
}

T0* r147Arguments(void){
if(fBC17Arguments==0){fBC17Arguments=1;{
{T88*n=((T88*)se_malloc(sizeof(*n))/*8*/);
*n=M88;
oBC17Arguments=((T0*)n);
/*[IRF3.3make*/((((T88*)(n)))->_program_name/*4*/)=(r88argument(0));
/*]*/
}
}}
return oBC17Arguments;
}

void r147make(T147* C,T0* a1){
{T86*n=((T86*)se_malloc(sizeof(*n))/*20*/);
*n=M86;
r86make(n,1,1);
(/*SFN*/C->_parameters/*4*/)=((T0*)n);
}
/*[IRF3.6put*/{T86* C1=(T86*)((/*RF2*/(C)->_parameters/*4*/));
T0* b1=a1;
T2 b2=1;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}

T0* r147message(T147* C,T0* a1){
T0* R=NULL;
T0* _str=NULL;
T2 _i=0;
T2 _j=0;
T2 _nb=0;
T3 _c=0;
T6 _stop=0;
T6 _lb=0;
T6 _rb=0;
_i=1;
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
R=r84make(_nb);
while (!((_i)>(_nb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
_i=(_i)+(1);
/*[IF*/
if((_c)!=(((T3)'\44'))){
r7append_character(((T7*)R),_c);
}
 else if((_i)>(_nb)){
r7append_character(((T7*)R),((T3)'\44'));
}
else{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\44'))){
r7append_character(((T7*)R),((T3)'\44'));
_i=(_i)+(1);
}
else{
_str=r84make(5);
/*[IF*/
if((_c)==(((T3)'\173'))){
_lb=1;
_rb=0;
_i=(_i)+(1);
while (!(r6_px_or((_i)>(_nb),_rb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\175'))){
_rb=1;
}
else{
r7append_character(((T7*)_str),_c);
}
/*FI]*/
_i=(_i)+(1);
}
}
else{
_lb=0;
_rb=0;
_stop=0;
while (!(r6_px_or((_i)>(_nb),_stop)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[INSPECT*/
{int z1=_c;
switch(z1){
case 48:
case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
r7append_character(((T7*)_str),_c);
_i=(_i)+(1);
break;
default:;
_stop=1;
}
}/*INSPECT]*/
}
}
/*FI]*/
/*[IF*/
if(r84is_integer(_str)){
_j=r7to_integer(((T7*)_str));
/*[IF*/
if(r86valid_index((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j)){
r7append_string(((T7*)R),r86item((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j));
}
 else if((_j)==(0)){
r7append_string(((T7*)R),(/*RF2*/((T88*)(r147Arguments()))->_program_name/*4*/));
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
return R;
}

T0* r147twin(T147* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T147*)R)=*C;
return R;
}

T0* r147default_message(T147* C){
T0* R=NULL;
R=r147message(C,((T0*)ms147_988446515));
return R;
}

void r79fill(T79* C){
T2 _nb=0;
T2 _nb2=0;
T0* _buff=NULL;
/*[IF*/
if(r6_px_and((/*RF2*/(C)->_filled/*33*/),!((/*RF2*/(C)->_end_of_file/*39*/)))){
r79compact_left(C);
_buff=(/*RF2*/(C)->_content/*4*/);
_nb=((/*RF2*/(C)->_capacity/*8*/))-(r79count(C));
/*[IF*/
if((/*RF2*/(C)->_interactive/*34*/)){
X39read_character((/*RF2*/(C)->_file/*35*/));
/*[IF*/
if(!(r92end_of_input((/*RF2*/(C)->_file/*35*/)))){
(/*SFN*/C->_upper/*28*/)=((/*RF2*/(C)->_upper/*28*/))+(1);
/*[IRF3.5put*/((/*RF2*/(((T7*)_buff))->_storage/*4*/))[((/*RF2*/(C)->_upper/*28*/))-(1)]=(X39last_character((/*RF2*/(C)->_file/*35*/)));
/*]*/
(/*SFN*/C->_filled/*33*/)=1;
}
else{
(/*SFN*/C->_filled/*33*/)=0;
(/*SFN*/C->_end_of_file/*39*/)=1;
}
/*FI]*/
}
else{
_nb2=r112copy_from_stream(_buff,((/*RF2*/(C)->_upper/*28*/))+(1),(/*RF2*/(C)->_file/*35*/),_nb);
/*[IF*/
if((_nb2)<(_nb)){
(/*SFN*/C->_end_of_file/*39*/)=r92end_of_input((/*RF2*/(C)->_file/*35*/));
}
/*FI]*/
/*[IF*/
if((_nb2)>(0)){
(/*SFN*/C->_filled/*33*/)=1;
}
else{
(/*SFN*/C->_filled/*33*/)=0;
}
/*FI]*/
(/*SFN*/C->_upper/*28*/)=((/*RF2*/(C)->_upper/*28*/))+(_nb2);
}
/*FI]*/
/*[IRF3.5put*/((/*RF2*/(((T7*)_buff))->_storage/*4*/))[(((/*RF2*/(C)->_upper/*28*/))+(1))-(1)]=(((T3)'\0'));
/*]*/
/*[IRF3.5put*/((/*RF2*/(((T7*)_buff))->_storage/*4*/))[(((/*RF2*/(C)->_upper/*28*/))+(2))-(1)]=(((T3)'\0'));
/*]*/
}
else{
(/*SFN*/C->_filled/*33*/)=0;
}
/*FI]*/
}

void r79compact_left(T79* C){
T2 _new_index=0;
T2 _nb=0;
_nb=(((/*RF2*/(C)->_upper/*28*/))-((/*RF2*/(C)->_index/*24*/)))+(1);
/*[IF*/
if((_nb)>=((/*RF2*/(C)->_capacity/*8*/))){
r79resize(C);
}
/*FI]*/
_new_index=r79lower();
/*[IF*/
if(((/*RF2*/(C)->_index/*24*/))!=(_new_index)){
r112move_left((/*RF2*/(C)->_content/*4*/),(/*RF2*/(C)->_index/*24*/),_new_index,(_nb)+(2));
(/*SFN*/C->_index/*24*/)=_new_index;
(/*SFN*/C->_upper/*28*/)=((_new_index)+(_nb))-(1);
}
/*FI]*/
}

T2 r79count(T79* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*28*/))-(r79lower()))+(1);
return R;
}

void r79set_position(T79* C,T2 a1,T2 a2,T2 a3){
(/*SFN*/C->_position/*12*/)=a1;
(/*SFN*/C->_line/*20*/)=a2;
(/*SFN*/C->_column/*16*/)=a3;
}

T2 r79lower(void){
if(fBC80lower==0){fBC80lower=1;{
oBC80lower=1;
}}
return oBC80lower;
}

void r79make_from_string(T79* C,T0* a1){
T0* _buff=NULL;
T2 _nb=0;
_nb=((/*RF2*/(((T7*)a1))->_count/*8*/))+(2);
_buff=r112make(_nb);
r112copy_from_string(_buff,r79lower(),a1);
_nb=(_nb)+((r79lower())-(1));
/*[IRF3.5put*/((/*RF2*/(((T7*)_buff))->_storage/*4*/))[((_nb)-(1))-(1)]=(((T3)'\0'));
/*]*/
/*[IRF3.5put*/((/*RF2*/(((T7*)_buff))->_storage/*4*/))[(_nb)-(1)]=(((T3)'\0'));
/*]*/
r79make_from_buffer(C,_buff);
}

void r79make_from_buffer(T79* C,T0* a1){
T2 _l=0;
_l=r79lower();
(/*SFN*/C->_capacity/*8*/)=((/*RF2*/(((T7*)a1))->_count/*8*/))-(2);
(/*SFN*/C->_upper/*28*/)=((/*RF2*/(C)->_capacity/*8*/))+((_l)-(1));
(/*SFN*/C->_content/*4*/)=a1;
(/*SFN*/C->_index/*24*/)=_l;
(/*SFN*/C->_line/*20*/)=1;
(/*SFN*/C->_column/*16*/)=1;
(/*SFN*/C->_position/*12*/)=1;
(/*SFN*/C->_beginning_of_line/*32*/)=1;
}

void r79resize(T79* C){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
(/*SFN*/C->_capacity/*8*/)=16384;
}
else{
(/*SFN*/C->_capacity/*8*/)=((/*RF2*/(C)->_capacity/*8*/))*(2);
}
/*FI]*/
/*[IF*/
if((((/*RF2*/(C)->_capacity/*8*/))+(2))>((/*RF2*/((T7*)((/*RF2*/(C)->_content/*4*/)))->_count/*8*/))){
(/*SFN*/C->_content/*4*/)=r112resize((/*RF2*/(C)->_content/*4*/),((/*RF2*/(C)->_capacity/*8*/))+(2));
}
/*FI]*/
}

void r79make_with_size(T79* C,T0* a1,T2 a2){
(/*SFN*/C->_capacity/*8*/)=a2;
(/*SFN*/C->_content/*4*/)=r112make((a2)+(2));
r79set_file(C,a1);
}

T0* r79twin(T79* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T79*)R)=*C;
return R;
}

void r79set_file(T79* C,T0* a1){
(/*SFN*/C->_end_of_file/*39*/)=0;
r79flush(C);
(/*SFN*/C->_file/*35*/)=a1;
}

void r79flush(T79* C){
T2 _l=0;
_l=r79lower();
/*[IRF3.5put*/((/*RF2*/((T7*)((/*RF2*/(C)->_content/*4*/)))->_storage/*4*/))[(_l)-(1)]=(((T3)'\0'));
/*]*/
/*[IRF3.5put*/((/*RF2*/((T7*)((/*RF2*/(C)->_content/*4*/)))->_storage/*4*/))[((_l)+(1))-(1)]=(((T3)'\0'));
/*]*/
(/*SFN*/C->_upper/*28*/)=(_l)-(1);
(/*SFN*/C->_index/*24*/)=_l;
(/*SFN*/C->_line/*20*/)=1;
(/*SFN*/C->_column/*16*/)=1;
(/*SFN*/C->_position/*12*/)=1;
(/*SFN*/C->_beginning_of_line/*32*/)=1;
(/*SFN*/C->_filled/*33*/)=1;
}

T0* r164current_working_directory(T164* C){
T0* R=NULL;
r156connect_to_current_working_directory(&((/*RF2*/(C)->_basic_directory/*4*/)));
R=r164clone(oBC156last_entry);
r156disconnect(&((/*RF2*/(C)->_basic_directory/*4*/)));
return R;
}

T0* r164clone(T0* a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((void*)(NULL))){
R=X10twin(a1);
}
/*FI]*/
return R;
}

T6 r164is_windows(T164* C){
if(fBC98is_windows==0){fBC98is_windows=1;{
T0* _cwd=NULL;
_cwd=r164current_working_directory(C);
/*[IF*/
if(((/*RF2*/(((T7*)_cwd))->_count/*8*/))>=(3)){
oBC98is_windows=r6_px_and((/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(2)-(1)]/*)*/)==(((T3)'\72')),(/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(3)-(1)]/*)*/)==(((T3)'\134')));
}
/*FI]*/
}}
return oBC98is_windows;
}

void r164make(T164* C){
(/*SFN*/C->_name/*12*/)=((T0*)ms164_447851);
/*[IRF3.1old_make*//*]*/
}

void r164old_put_string(T0* a1){
T2 _i=0;
_i=1;
while (!((_i)>((/*RF2*/(((T7*)a1))->_count/*8*/))))
{
/*[IRF3.6old_put_character*/{T3 b1=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
basic_io_putc(b1,basic_io_stdout);
}/*]*/
_i=(_i)+(1);
}
}

T6 r164is_unix(T164* C){
if(fBC98is_unix==0){fBC98is_unix=1;{
T0* _cwd=NULL;
_cwd=r164current_working_directory(C);
/*[IF*/
if(((/*RF2*/(((T7*)_cwd))->_count/*8*/))>(0)){
oBC98is_unix=(/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(1)-(1)]/*)*/)==(((T3)'\57'));
}
/*FI]*/
}}
return oBC98is_unix;
}

T0* r164twin(T164* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T164*)R)=*C;
return R;
}

T0* r96current_working_directory(T96* C){
T0* R=NULL;
r156connect_to_current_working_directory(&((/*RF2*/(C)->_basic_directory/*4*/)));
R=r96clone(oBC156last_entry);
r156disconnect(&((/*RF2*/(C)->_basic_directory/*4*/)));
return R;
}

T0* r96clone(T0* a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((void*)(NULL))){
R=X10twin(a1);
}
/*FI]*/
return R;
}

T6 r96is_windows(T96* C){
if(fBC98is_windows==0){fBC98is_windows=1;{
T0* _cwd=NULL;
_cwd=r96current_working_directory(C);
/*[IF*/
if(((/*RF2*/(((T7*)_cwd))->_count/*8*/))>=(3)){
oBC98is_windows=r6_px_and((/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(2)-(1)]/*)*/)==(((T3)'\72')),(/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(3)-(1)]/*)*/)==(((T3)'\134')));
}
/*FI]*/
}}
return oBC98is_windows;
}

void r96make(T96* C){
(/*SFN*/C->_name/*12*/)=((T0*)ms96_447584);
/*[IRF3.1old_make*//*]*/
}

void r96old_put_string(T0* a1){
T2 _i=0;
_i=1;
while (!((_i)>((/*RF2*/(((T7*)a1))->_count/*8*/))))
{
/*[IRF3.6old_put_character*/{T3 b1=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
basic_io_putc(b1,basic_io_stderr);
}/*]*/
_i=(_i)+(1);
}
}

T6 r96is_unix(T96* C){
if(fBC98is_unix==0){fBC98is_unix=1;{
T0* _cwd=NULL;
_cwd=r96current_working_directory(C);
/*[IF*/
if(((/*RF2*/(((T7*)_cwd))->_count/*8*/))>(0)){
oBC98is_unix=(/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(1)-(1)]/*)*/)==(((T3)'\57'));
}
/*FI]*/
}}
return oBC98is_unix;
}

T0* r96twin(T96* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T96*)R)=*C;
return R;
}

T0* r162dirname(T0* a1){
T0* R=NULL;
T2 _i=0;
/*[IF*/
if(r162is_root_directory(a1)){
R=oBC162root_directory;
}
else{
_i=(/*RF2*/(((T7*)a1))->_count/*8*/);
while (!(((_i)<(1))||((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)!=(((T3)'\57')))))
{
_i=(_i)-(1);
}
while (!(((_i)<(1))||((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)==(((T3)'\57')))))
{
_i=(_i)-(1);
}
/*[IF*/
if((_i)<(1)){
R=((T0*)ms162_46);
}
else{
while (!(((_i)<(1))||((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)!=(((T3)'\57')))))
{
_i=(_i)-(1);
}
/*[IF*/
if((_i)<(1)){
R=oBC162root_directory;
}
else{
R=r7substring(((T7*)a1),1,_i);
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
return R;
}

T0* r162string_to_pathname(T0* a1){
T0* R=NULL;
T2 _i=0;
T2 _nb=0;
T2 _j=0;
T2 _k=0;
T0* _str=NULL;
{T174*n=((T174*)se_malloc(sizeof(*n))/*21*/);
*n=M174;
r174make(n);
R=((T0*)n);
}
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
/*[IF*/
if((_nb)>(0)){
/*[IF*/
if((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(1)-(1)]/*)*/)!=(((T3)'\57'))){
/*[IRF3.3set_relative*/((((T174*)(((T174*)R))))->_is_relative/*4*/)=(1);
/*]*/
}
/*FI]*/
}
else{
/*[IRF3.3set_relative*/((((T174*)(((T174*)R))))->_is_relative/*4*/)=(1);
/*]*/
}
/*FI]*/
_i=1;
while (!((_i)>(_nb)))
{
while (!(((_i)>(_nb))||((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)!=(((T3)'\57')))))
{
_i=(_i)+(1);
}
/*[IF*/
if((_i)<=(_nb)){
_j=_i;
while (!(((_i)>(_nb))||((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)==(((T3)'\57')))))
{
_i=(_i)+(1);
}
_k=(_i)-(1);
_str=r7substring(((T7*)a1),_j,_k);
/*[IF*/
if(r7is_equal(((T7*)_str),((T0*)ms162_46))){
/*[IRF3.6append_current*/{T174* C1=((T174*)R);
r174append_name(C1,((T0*)ms174_46));
}/*]*/
}
 else if(r7is_equal(((T7*)_str),((T0*)ms162_276))){
/*[IRF3.6append_parent*/{T174* C1=((T174*)R);
r174append_name(C1,((T0*)ms174_276));
}/*]*/
}
else{
r174append_name(((T174*)R),_str);
}
/*FI]*/
}
/*FI]*/
}
return R;
}
T0*oBC162root_directory=NULL;

T6 r162is_root_directory(T0* a1){
T6 R=0;
T2 _i=0;
T2 _nb=0;
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
/*[IF*/
if((_nb)>(0)){
R=1;
_i=1;
while (!((_i)>(_nb)))
{
/*[IF*/
if((/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/)!=(((T3)'\57'))){
R=0;
_i=(_nb)+(1);
}
else{
_i=(_i)+(1);
}
/*FI]*/
}
}
/*FI]*/
return R;
}

T0* r162pathname_to_string(T0* a1){
T0* R=NULL;
T2 _i=0;
T2 _nb=0;
R=r84make(50);
/*[IF*/
if(!((/*RF2*/(((T174*)a1))->_is_relative/*4*/))){
r7append_string(((T7*)R),oBC162root_directory);
}
/*FI]*/
_nb=(/*RF2*/(((T174*)a1))->_count/*13*/);
_i=1;
while (!((_i)>=(_nb)))
{
/*[IF*/
if(r174is_current(((T174*)a1),_i)){
r7append_string(((T7*)R),((T0*)ms162_46));
}
 else if(r174is_parent(((T174*)a1),_i)){
r7append_string(((T7*)R),((T0*)ms162_276));
}
else{
r7append_string(((T7*)R),/*(IRF4.6item*/r86item(((T86*)((/*RF2*/(((T174*)a1))->_components/*17*/))),_i)/*)*/);
}
/*FI]*/
r7append_character(((T7*)R),((T3)'\57'));
_i=(_i)+(1);
}
/*[IF*/
if((_i)==(_nb)){
/*[IF*/
if(r174is_current(((T174*)a1),_i)){
r7append_string(((T7*)R),((T0*)ms162_46));
}
 else if(r174is_parent(((T174*)a1),_i)){
r7append_string(((T7*)R),((T0*)ms162_276));
}
else{
r7append_string(((T7*)R),/*(IRF4.6item*/r86item(((T86*)((/*RF2*/(((T174*)a1))->_components/*17*/))),_i)/*)*/);
}
/*FI]*/
}
/*FI]*/
return R;
}

T0* r162twin(T162* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T162*)R)=*C;
return R;
}

T0* r162canonical_pathname(T0* a1){
T0* R=NULL;
T0* _p=NULL;
_p=r162string_to_pathname(a1);
r174set_canonical(((T174*)_p));
R=r162pathname_to_string(_p);
return R;
}

void r174copy(T174* C,T0* a1){
*((T174*)(C))=*((T174*)(a1));
(/*SFN*/C->_components/*17*/)=r174clone((/*RF2*/(C)->_components/*17*/));
}

void r174append_name(T174* C,T0* a1){
(/*SFN*/C->_count/*13*/)=((/*RF2*/(C)->_count/*13*/))+(1);
r86force((T86*)((/*RF2*/(C)->_components/*17*/)),a1,(/*RF2*/(C)->_count/*13*/));
}

T0* r174clone(T0* a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((void*)(NULL))){
R=X10twin(a1);
}
/*FI]*/
return R;
}

T6 r174is_parent(T174* C,T2 a1){
T6 R=0;
R=(/*(IRF4.6item*/r86item(((T86*)((/*RF2*/(C)->_components/*17*/))),a1)/*)*/)==((void*)(((T0*)ms174_276)));
return R;
}

void r174make(T174* C){
{T86*n=((T86*)se_malloc(sizeof(*n))/*20*/);
*n=M86;
r86make(n,1,10);
(/*SFN*/C->_components/*17*/)=((T0*)n);
}
}

void r174set_canonical(T174* C){
T2 _i=0;
T2 _j=0;
T2 _nb=0;
_nb=(/*RF2*/(C)->_count/*13*/);
/*[IF*/
if(r6_px_and(((_nb)==(1))&&(r174is_current(C,1)),(/*RF2*/(C)->_is_relative/*4*/))){
}
else{
_j=1;
_i=1;
while (!((_i)>(_nb)))
{
/*[IF*/
if(r174is_current(C,_i)){
}
 else if(r174is_parent(C,_i)){
/*[IF*/
if(((_i)==(1))||(r174is_parent(C,(_i)-(1)))){
_j=(_j)+(1);
}
else{
_j=(_j)-(1);
}
/*FI]*/
}
else{
/*[IRF3.6put*/{T86* C1=(T86*)((/*RF2*/(C)->_components/*17*/));
T0* b1=/*(IRF4.6item*/r86item(((T86*)((/*RF2*/(C)->_components/*17*/))),_i)/*)*/;
T2 b2=_j;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
_j=(_j)+(1);
}
/*FI]*/
_i=(_i)+(1);
}
(/*SFN*/C->_count/*13*/)=(_j)-(1);
while (!((_j)>(_nb)))
{
/*[IRF3.6put*/{T86* C1=(T86*)((/*RF2*/(C)->_components/*17*/));
T0* b1=NULL;
T2 b2=_j;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
_j=(_j)+(1);
}
}
/*FI]*/
}

T0* r174twin(T174* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T174*)R)=M174;
r174copy(((T174*)R),((T0*)C));
return R;
}

T6 r174is_current(T174* C,T2 a1){
T6 R=0;
R=(/*(IRF4.6item*/r86item(((T86*)((/*RF2*/(C)->_components/*17*/))),a1)/*)*/)==((void*)(((T0*)ms174_46)));
return R;
}

T0* r81Arguments(void){
if(fBC17Arguments==0){fBC17Arguments=1;{
{T88*n=((T88*)se_malloc(sizeof(*n))/*8*/);
*n=M88;
oBC17Arguments=((T0*)n);
/*[IRF3.3make*/((((T88*)(n)))->_program_name/*4*/)=(r88argument(0));
/*]*/
}
}}
return oBC17Arguments;
}

void r81make(T81* C,T0* a1,T2 a2){
{T86*n=((T86*)se_malloc(sizeof(*n))/*20*/);
*n=M86;
r86make(n,1,2);
(/*SFN*/C->_parameters/*4*/)=((T0*)n);
}
/*[IRF3.6put*/{T86* C1=(T86*)((/*RF2*/(C)->_parameters/*4*/));
T0* b1=a1;
T2 b2=1;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
/*[IRF3.6put*/{T86* C1=(T86*)((/*RF2*/(C)->_parameters/*4*/));
T0* b1=r2out(a2);
T2 b2=2;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}

T0* r81message(T81* C,T0* a1){
T0* R=NULL;
T0* _str=NULL;
T2 _i=0;
T2 _j=0;
T2 _nb=0;
T3 _c=0;
T6 _stop=0;
T6 _lb=0;
T6 _rb=0;
_i=1;
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
R=r84make(_nb);
while (!((_i)>(_nb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
_i=(_i)+(1);
/*[IF*/
if((_c)!=(((T3)'\44'))){
r7append_character(((T7*)R),_c);
}
 else if((_i)>(_nb)){
r7append_character(((T7*)R),((T3)'\44'));
}
else{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\44'))){
r7append_character(((T7*)R),((T3)'\44'));
_i=(_i)+(1);
}
else{
_str=r84make(5);
/*[IF*/
if((_c)==(((T3)'\173'))){
_lb=1;
_rb=0;
_i=(_i)+(1);
while (!(r6_px_or((_i)>(_nb),_rb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\175'))){
_rb=1;
}
else{
r7append_character(((T7*)_str),_c);
}
/*FI]*/
_i=(_i)+(1);
}
}
else{
_lb=0;
_rb=0;
_stop=0;
while (!(r6_px_or((_i)>(_nb),_stop)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[INSPECT*/
{int z1=_c;
switch(z1){
case 48:
case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
r7append_character(((T7*)_str),_c);
_i=(_i)+(1);
break;
default:;
_stop=1;
}
}/*INSPECT]*/
}
}
/*FI]*/
/*[IF*/
if(r84is_integer(_str)){
_j=r7to_integer(((T7*)_str));
/*[IF*/
if(r86valid_index((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j)){
r7append_string(((T7*)R),r86item((T86*)((/*RF2*/(C)->_parameters/*4*/)),_j));
}
 else if((_j)==(0)){
r7append_string(((T7*)R),(/*RF2*/((T88*)(r81Arguments()))->_program_name/*4*/));
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
else{
r7append_character(((T7*)R),((T3)'\44'));
/*[IF*/
if(_lb){
r7append_character(((T7*)R),((T3)'\173'));
}
/*FI]*/
r7append_string(((T7*)R),_str);
/*[IF*/
if(_rb){
r7append_character(((T7*)R),((T3)'\175'));
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
return R;
}

T0* r81twin(T81* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T81*)R)=*C;
return R;
}

T0* r81default_message(T81* C){
T0* R=NULL;
R=r81message(C,((T0*)ms81_1449702436));
return R;
}
T0*oBC1command_arguments=NULL;
int fBC1command_arguments=0;

T0* r88command_arguments(void){
if(fBC1command_arguments==0){fBC1command_arguments=1;{
T2 _i=0;
T0* _arg=NULL;
_i=se_argc;
{T90*n=((T90*)se_malloc(sizeof(*n))/*16*/);
*n=M90;
oBC1command_arguments=((T0*)n);
r90make(n,_i);
}
while (!((_i)==(0)))
{
_i=(_i)-(1);
_arg=((T0*)se_string(se_argv[_i]));
/*[IRF3.5put*/((/*RF2*/(((T90*)oBC1command_arguments))->_storage/*4*/))[_i]=(_arg);
/*]*/
}
}}
return oBC1command_arguments;
}

T0* r88twin(T88* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T88*)R)=*C;
return R;
}

T0* r88argument(T2 a1){
T0* R=NULL;
R=/*(IRF4.6item*/((/*RF2*/((T90*)(r88command_arguments()))->_storage/*4*/))[a1]/*)*/;
return R;
}
T0*oBC95error=NULL;
int fBC95error=0;

T0* r95error(void){
if(fBC95error==0){fBC95error=1;{
{T96*n=((T96*)se_malloc(sizeof(*n))/*16*/);
*n=M96;
oBC95error=((T0*)n);
r96make(n);
}
}}
return oBC95error;
}
T0*oBC95input=NULL;
int fBC95input=0;

T0* r95input(void){
if(fBC95input==0){fBC95input=1;{
{T149*n=((T149*)se_malloc(sizeof(*n))/*22*/);
*n=M149;
oBC95input=((T0*)n);
r149make(n);
}
}}
return oBC95input;
}
T0*oBC95output=NULL;
int fBC95output=0;

T0* r95output(void){
if(fBC95output==0){fBC95output=1;{
{T164*n=((T164*)se_malloc(sizeof(*n))/*16*/);
*n=M164;
oBC95output=((T0*)n);
r164make(n);
}
}}
return oBC95output;
}

T0* r95twin(T95* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T95*)R)=*C;
return R;
}

T0* r63twin(T63* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T63*)R)=*C;
return R;
}

T0* r60twin(T60* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T60*)R)=*C;
return R;
}

T0* r41twin(T41* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T41*)R)=*C;
return R;
}

T0* r176twin(T176* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T176*)R)=*C;
return R;
}

void r16preprocess(T16* C){
T0* _in_file=NULL;
T0* _out_file=NULL;
/*[IF*/
if(!(r7is_equal((T7*)((/*RF2*/(C)->_out_filename/*8*/)),((T0*)ms16_45a)))){
{T23*n=((T23*)se_malloc(sizeof(*n))/*16*/);
*n=M23;
r23make(n,(/*RF2*/(C)->_out_filename/*8*/));
_out_file=((T0*)n);
}
r23recursive_open_write(((T23*)_out_file));
/*[IF*/
if(/*(IRF4.5is_open_write*//*(IRF4.7old_is_open_write*/((/*RF2*/(((T23*)_out_file))->_path/*8*/))!=(NULL)/*)*//*)*/){
/*[IRF3.3set_output_file*/((((T43*)((T43*)((/*RF2*/(C)->_parser/*12*/)))))->_output_file/*208*/)=(_out_file);
/*]*/
}
else{
r16report_cannot_write_error(C,(/*RF2*/(C)->_out_filename/*8*/));
/*[IRF3.6die*/{T63* C1=(T63*)(oBC18Exceptions);
T2 b1=1;
exit(b1);
}/*]*/
}
/*FI]*/
}
else{
/*[IRF3.3set_output_file*/((((T43*)((T43*)((/*RF2*/(C)->_parser/*12*/)))))->_output_file/*208*/)=(r95output());
/*]*/
}
/*FI]*/
/*[IF*/
if(r7is_equal((T7*)((/*RF2*/(C)->_in_filename/*4*/)),((T0*)ms16_45))){
r43parse_file((T43*)((/*RF2*/(C)->_parser/*12*/)),r95input());
}
else{
_in_file=r92make_file_open_read((/*RF2*/(C)->_in_filename/*4*/));
/*[IF*/
if(r92is_open_read(_in_file)){
r43parse_file((T43*)((/*RF2*/(C)->_parser/*12*/)),_in_file);
r92close(_in_file);
}
else{
r16report_cannot_read_error(C,(/*RF2*/(C)->_in_filename/*4*/));
/*[IRF3.6die*/{T63* C1=(T63*)(oBC18Exceptions);
T2 b1=1;
exit(b1);
}/*]*/
}
/*FI]*/
}
/*FI]*/
/*[IF*/
if(r43syntax_error((T43*)((/*RF2*/(C)->_parser/*12*/)))){
/*[IRF3.6die*/{T63* C1=(T63*)(oBC18Exceptions);
T2 b1=1;
exit(b1);
}/*]*/
}
/*FI]*/
/*[IF*/
if(((_out_file)!=((void*)(NULL)))&&(!(r23is_closed(((T23*)_out_file))))){
r23close(((T23*)_out_file));
}
/*FI]*/
}

void r16read_arguments(T16* C){
T0* _an_arg=NULL;
T6 _stop=0;
T2 _i=0;
T2 _nb=0;
T2 _args_count=0;
_args_count=/*(IRF4.9argument_count*/((/*UT*/(void)((T88*)(r16Arguments()))),(/*RF2*/((T90*)(r88command_arguments()))->_upper/*12*/))/*)*/;
/*[IF*/
if((_args_count)==(1)){
_an_arg=((/*UT*/(void)((T88*)(r16Arguments()))),r88argument(1));
/*[IF*/
if(r6_px_or(r7is_equal(((T7*)_an_arg),((T0*)ms16_311)),r7is_equal(((T7*)_an_arg),((T0*)ms16_23342040)))){
r16report_version_number(C);
/*[IRF3.6die*/{T63* C1=(T63*)(oBC18Exceptions);
T2 b1=0;
exit(b1);
}/*]*/
}
 else if(r6_px_or(r6_px_or(r7is_equal(((T7*)_an_arg),((T0*)ms16_329)),r7is_equal(((T7*)_an_arg),((T0*)ms16_288))),r7is_equal(((T7*)_an_arg),((T0*)ms16_184927)))){
/*[IRF3.6report_usage_message*/{T16* C1=C;
r83report_message((T83*)((/*RF2*/(C1)->_error_handler/*16*/)),r16Usage_message());
}/*]*/
/*[IRF3.6die*/{T63* C1=(T63*)(oBC18Exceptions);
T2 b1=0;
exit(b1);
}/*]*/
}
/*FI]*/
}
/*FI]*/
_i=1;
while (!(r6_px_or((_i)>(_args_count),_stop)))
{
_an_arg=((/*UT*/(void)((T88*)(r16Arguments()))),r88argument(_i));
_nb=(/*RF2*/(((T7*)_an_arg))->_count/*8*/);
/*[IF*/
if(((_nb)>=(2))&&((/*(IRF4.6item*/((/*RF2*/(((T7*)_an_arg))->_storage/*4*/))[(1)-(1)]/*)*/)==(((T3)'\55')))){
/*[IF*/
if((/*(IRF4.6item*/((/*RF2*/(((T7*)_an_arg))->_storage/*4*/))[(2)-(1)]/*)*/)==(((T3)'D'))){
/*[IF*/
if((_nb)>(2)){
/*[IRF3.5define_value*/r122force(((T122*)((/*RF2*/((T43*)((/*RF2*/(C)->_parser/*12*/)))->_defined_values/*217*/))),((T0*)ms16_0),r7substring(((T7*)_an_arg),3,_nb));
/*]*/
}
/*FI]*/
_i=(_i)+(1);
}
 else if(r6_px_and((_nb)==(2),(/*(IRF4.6item*/((/*RF2*/(((T7*)_an_arg))->_storage/*4*/))[(2)-(1)]/*)*/)==(((T3)'M')))){
/*[IRF3.3set_makefile_dependencies*/((((T43*)((T43*)((/*RF2*/(C)->_parser/*12*/)))))->_makefile_dependencies/*216*/)=(1);
/*]*/
_i=(_i)+(1);
}
 else if(r6_px_and((_nb)==(2),(/*(IRF4.6item*/((/*RF2*/(((T7*)_an_arg))->_storage/*4*/))[(2)-(1)]/*)*/)==(((T3)'l')))){
/*[IRF3.3set_empty_lines*/((((T43*)((T43*)((/*RF2*/(C)->_parser/*12*/)))))->_empty_lines/*207*/)=(1);
/*]*/
_i=(_i)+(1);
}
 else if(r7is_equal(((T7*)_an_arg),((T0*)ms16_927745))){
/*[IRF3.3set_empty_lines*/((((T43*)((T43*)((/*RF2*/(C)->_parser/*12*/)))))->_empty_lines/*207*/)=(1);
/*]*/
_i=(_i)+(1);
}
else{
_stop=1;
}
/*FI]*/
}
else{
_stop=1;
}
/*FI]*/
}
/*[INSPECT*/
{int z1=((_args_count)-(_i))+(1);
switch(z1){
case 0:
break;
case 1:
(/*SFN*/C->_in_filename/*4*/)=((/*UT*/(void)((T88*)(r16Arguments()))),r88argument(_i));
break;
case 2:
(/*SFN*/C->_in_filename/*4*/)=((/*UT*/(void)((T88*)(r16Arguments()))),r88argument(_i));
(/*SFN*/C->_out_filename/*8*/)=((/*UT*/(void)((T88*)(r16Arguments()))),r88argument((_i)+(1)));
break;
default:;
/*[IRF3.6report_usage_error*/{T16* C1=C;
r83report_error((T83*)((/*RF2*/(C1)->_error_handler/*16*/)),r16Usage_message());
}/*]*/
/*[IRF3.6die*/{T63* C1=(T63*)(oBC18Exceptions);
T2 b1=1;
exit(b1);
}/*]*/
}
}/*INSPECT]*/
}
T0*oBC18Exceptions=NULL;

void r16report_cannot_read_error(T16* C,T0* a1){
T0* _an_error=NULL;
{T147*n=((T147*)se_malloc(sizeof(*n))/*8*/);
*n=M147;
r147make(n,a1);
_an_error=((T0*)n);
}
r83report_error((T83*)((/*RF2*/(C)->_error_handler/*16*/)),_an_error);
}

T0* r16Arguments(void){
if(fBC17Arguments==0){fBC17Arguments=1;{
{T88*n=((T88*)se_malloc(sizeof(*n))/*8*/);
*n=M88;
oBC17Arguments=((T0*)n);
/*[IRF3.3make*/((((T88*)(n)))->_program_name/*4*/)=(r88argument(0));
/*]*/
}
}}
return oBC17Arguments;
}

void r16execute(T16* C){
/*[IF*/
/*AF*//*AE*/
/*FI]*/
/*[IRF3.3set_program_name*/((((T88*)((T88*)(r16Arguments()))))->_program_name/*4*/)=(((T0*)ms16_16072));
/*]*/
{T83*n=((T83*)se_malloc(sizeof(*n))/*16*/);
*n=M83;
r83make_standard(n);
(/*SFN*/C->_error_handler/*16*/)=((T0*)n);
}
{T43*n=((T43*)se_malloc(sizeof(*n))/*233*/);
*n=M43;
r43make(n,(/*RF2*/(C)->_error_handler/*16*/));
(/*SFN*/C->_parser/*12*/)=((T0*)n);
}
(/*SFN*/C->_in_filename/*4*/)=((T0*)ms16_45aaa);
(/*SFN*/C->_out_filename/*8*/)=((T0*)ms16_45aa);
r16read_arguments(C);
r16preprocess(C);
}

void r16report_version_number(T16* C){
T0* _a_message=NULL;
{T167*n=((T167*)se_malloc(sizeof(*n))/*8*/);
*n=M167;
r167make(n,((T0*)ms21_1529));
_a_message=((T0*)n);
}
r83report_message((T83*)((/*RF2*/(C)->_error_handler/*16*/)),_a_message);
}

void r16report_cannot_write_error(T16* C,T0* a1){
T0* _an_error=NULL;
{T153*n=((T153*)se_malloc(sizeof(*n))/*8*/);
*n=M153;
r153make(n,a1);
_an_error=((T0*)n);
}
r83report_error((T83*)((/*RF2*/(C)->_error_handler/*16*/)),_an_error);
}

T0* r16twin(T16* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T16*)R)=*C;
return R;
}
T0*oBC16Usage_message=NULL;
int fBC16Usage_message=0;

T0* r16Usage_message(void){
if(fBC16Usage_message==0){fBC16Usage_message=1;{
{T166*n=((T166*)se_malloc(sizeof(*n))/*8*/);
*n=M166;
oBC16Usage_message=((T0*)n);
r166make(n,((T0*)ms16_78124153));
}
}}
return oBC16Usage_message;
}

T0* r40twin(T40* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T40*)R)=*C;
return R;
}

T0* r92name(T0* a1){
T0* R=NULL;
T0* _a_file=NULL;
T0* _a_std_input=NULL;
_a_std_input=a1;
if(NULL!=(_a_std_input)){
switch(((T0*)_a_std_input)->id){
case 149:
break;
default:
_a_std_input=NULL;
}
}/*[IF*/
if((_a_std_input)!=((void*)(NULL))){
R=((T0*)ms92_1338085634);
}
else{
_a_file=a1;
if(NULL!=(_a_file)){
switch(((T0*)_a_file)->id){
case 94:
break;
default:
_a_file=NULL;
}
}/*[IF*/
if(((_a_file)!=((void*)(NULL)))&&(((/*RF2*/(((T94*)_a_file))->_path/*5*/))!=((void*)(NULL)))){
R=(/*RF2*/(((T94*)_a_file))->_path/*5*/);
}
else{
R=((T0*)ms92_0);
}
/*FI]*/
}
/*FI]*/
return R;
}

T0* r92make_file_open_read(T0* a1){
struct rescue_context rc;
T0* R=NULL;
T6 _rescued=0;
T0* _a_file=NULL;
if(SETJMP(rc.jb)!=0){/*rescue*/
/*[IF*/
if(!(_rescued)){
_rescued=1;
goto retry_tag;
}
/*FI]*/
internal_exception_handler(Routine_failure);
}
retry_tag:
rc.next = rescue_context_top;
rescue_context_top = &rc;
/*[IF*/
if(!(_rescued)){
{T94*n=((T94*)se_malloc(sizeof(*n))/*17*/);
*n=M94;
/*[IRF3.1make*//*]*/
_a_file=((T0*)n);
}
R=_a_file;
r94connect_to(((T94*)_a_file),a1);
}
 else if(/*(IRF4.7is_connected*/((/*RF2*/(((T94*)_a_file))->_path/*5*/))!=(NULL)/*)*/){
r94disconnect(((T94*)_a_file));
}
/*FI]*/
rescue_context_top = rc.next;
return R;
}

T6 r92is_open_read(T0* a1){
T6 R=0;
R=X39is_connected(a1);
return R;
}

void r92close(T0* a1){
T0* _a_file=NULL;
_a_file=a1;
if(NULL!=(_a_file)){
switch(((T0*)_a_file)->id){
case 94:
break;
default:
_a_file=NULL;
}
}/*[IF*/
if((_a_file)!=((void*)(NULL))){
r94disconnect(((T94*)_a_file));
}
/*FI]*/
}

T6 r92end_of_input(T0* a1){
T6 R=0;
R=X39end_of_input(a1);
return R;
}

T2 r92read_stream(T0* a1,T0* a2,T2 a3,T2 a4){
T2 R=0;
T2 _i=0;
T2 _j=0;
/*[IF*/
if(!(X39end_of_input(a1))){
R=a4;
_j=a3;
_i=1;
while (!((_i)>(R)))
{
X39read_character(a1);
/*[IF*/
if(!(X39end_of_input(a1))){
/*[IRF3.5put*/((/*RF2*/(((T7*)a2))->_storage/*4*/))[(_j)-(1)]=(X39last_character(a1));
/*]*/
_j=(_j)+(1);
_i=(_i)+(1);
}
else{
R=(_i)-(1);
}
/*FI]*/
}
}
/*FI]*/
return R;
}

T0* r92twin(T92* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T92*)R)=*C;
return R;
}

void r156connect_to_current_working_directory(T156* C){
T8 _path=NULL;
_path=basic_directory_current_working_directory;
/*[IF*/
if((NULL!=_path)){
r7from_external_copy((T7*)(oBC156last_entry),_path);
(/*SFN*/C->_directory_stream/*0*/)=basic_directory_open(_path);
(/*SFN*/C->_current_entry/*4*/)=(/*RF2*/(*C)._directory_stream/*0*/);
/*[IF*/
if(r8is_null((/*RF2*/(*C)._directory_stream/*0*/))){
/*[IRF3.3clear*/((((T7*)((T7*)(oBC156last_entry))))->_count/*8*/)=(0);
/*]*/
}
/*FI]*/
}
else{
/*[IRF3.3clear*/((((T7*)((T7*)(oBC156last_entry))))->_count/*8*/)=(0);
/*]*/
}
/*FI]*/
}

void r156disconnect(T156* C){
T8 _null=NULL;
/*[IF*/
if(basic_directory_close((/*RF2*/(*C)._directory_stream/*0*/))){
(/*SFN*/C->_directory_stream/*0*/)=_null;
(/*SFN*/C->_current_entry/*4*/)=_null;
}
/*FI]*/
}
T0*oBC156last_entry=NULL;

void r156connect_to(T156* C,T0* a1){
T8 _path_pointer=NULL;
_path_pointer=r7to_external(((T7*)a1));
(/*SFN*/C->_directory_stream/*0*/)=basic_directory_open(_path_pointer);
(/*SFN*/C->_current_entry/*4*/)=(/*RF2*/(*C)._directory_stream/*0*/);
/*[IRF3.3clear*/((((T7*)((T7*)(oBC156last_entry))))->_count/*8*/)=(0);
/*]*/
}

T6 r156create_new_directory(T0* a1){
T6 R=0;
T8 _p=NULL;
_p=r7to_external(((T7*)a1));
R=basic_directory_mkdir(_p);
return R;
}

T6 r84is_integer(T0* a1){
T6 R=0;
R=r7is_integer(((T7*)a1));
return R;
}

T0* r84make(T2 a1){
T0* R=NULL;
{T7*n=((T7*)se_malloc(sizeof(*n))/*16*/);
*n=M7;
r7make(n,a1);
R=((T0*)n);
}
return R;
}

T0* r84twin(T84* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T84*)R)=*C;
return R;
}

T0* r148variable_value(T0* a1){
T0* R=NULL;
R=r148get_environment_variable(a1);
return R;
}

T0* r148get_environment_variable(T0* a1){
T0* R=NULL;
T8 _p=NULL;
T8 _null=NULL;
_p=r7to_external(((T7*)a1));
_p=basic_getenv(_p);
/*[IF*/
if((_p)!=(_null)){
{T7*n=((T7*)se_malloc(sizeof(*n))/*16*/);
*n=M7;
r7from_external_copy(n,_p);
R=((T0*)n);
}
}
/*FI]*/
return R;
}

T0* r148interpreted_string(T0* a1){
T0* R=NULL;
T0* _str=NULL;
T2 _i=0;
T2 _nb=0;
T3 _c=0;
T6 _stop=0;
_i=1;
_nb=(/*RF2*/(((T7*)a1))->_count/*8*/);
R=r84make(_nb);
while (!((_i)>(_nb)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
_i=(_i)+(1);
/*[IF*/
if((_c)!=(((T3)'\44'))){
r7append_character(((T7*)R),_c);
}
 else if((_i)>(_nb)){
r7append_character(((T7*)R),((T3)'\44'));
}
else{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\44'))){
r7append_character(((T7*)R),((T3)'\44'));
_i=(_i)+(1);
}
else{
_str=r84make(5);
/*[IF*/
if((_c)==(((T3)'\173'))){
_i=(_i)+(1);
_stop=0;
while (!(r6_px_or((_i)>(_nb),_stop)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[IF*/
if((_c)==(((T3)'\175'))){
_stop=1;
}
else{
r7append_character(((T7*)_str),_c);
}
/*FI]*/
_i=(_i)+(1);
}
}
else{
_stop=0;
while (!(r6_px_or((_i)>(_nb),_stop)))
{
_c=/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/;
/*[INSPECT*/
{int z1=_c;
switch(z1){
case 48:
case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
case 65:
case 66:
case 67:
case 68:
case 69:
case 70:
case 71:
case 72:
case 73:
case 74:
case 75:
case 76:
case 77:
case 78:
case 79:
case 80:
case 81:
case 82:
case 83:
case 84:
case 85:
case 86:
case 87:
case 88:
case 89:
case 90:
case 95:
case 97:
case 98:
case 99:
case 100:
case 101:
case 102:
case 103:
case 104:
case 105:
case 106:
case 107:
case 108:
case 109:
case 110:
case 111:
case 112:
case 113:
case 114:
case 115:
case 116:
case 117:
case 118:
case 119:
case 120:
case 121:
case 122:
r7append_character(((T7*)_str),_c);
_i=(_i)+(1);
break;
default:;
_stop=1;
}
}/*INSPECT]*/
}
}
/*FI]*/
_str=r148variable_value(_str);
/*[IF*/
if((_str)!=((void*)(NULL))){
r7append_string(((T7*)R),_str);
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}
return R;
}

T0* r148twin(T148* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T148*)R)=*C;
return R;
}

T0* r65twin(T65* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T65*)R)=*C;
return R;
}

T0* r112substring(T0* a1,T2 a2,T2 a3){
T0* R=NULL;
/*[IF*/
if((a3)<(a2)){
{T7*n=((T7*)se_malloc(sizeof(*n))/*16*/);
*n=M7;
r7make(n,0);
R=((T0*)n);
}
}
else{
R=r7substring(((T7*)a1),a2,a3);
}
/*FI]*/
return R;
}

void r112move_left(T0* a1,T2 a2,T2 a3,T2 a4){
T2 _i=0;
T2 _j=0;
T2 _nb2=0;
/*[IF*/
if((a4)>(0)){
_j=a3;
_nb2=((a2)+(a4))-(1);
_i=a2;
while (!((_i)>(_nb2)))
{
/*[IRF3.5put*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_j)-(1)]=(/*(IRF4.6item*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_i)-(1)]/*)*/);
/*]*/
_j=(_j)+(1);
_i=(_i)+(1);
}
}
/*FI]*/
}

T0* r112make(T2 a1){
T0* R=NULL;
{T7*n=((T7*)se_malloc(sizeof(*n))/*16*/);
*n=M7;
/*[IRF3.6blank*/{T7* C1=n;
T2 b1=a1;
r7make_filled(C1,((T3)'\40'),b1);
}/*]*/
R=((T0*)n);
}
return R;
}

void r112copy_from_string(T0* a1,T2 a2,T0* a3){
T2 _nb=0;
T2 _i=0;
T2 _j=0;
_nb=(/*RF2*/(((T7*)a3))->_count/*8*/);
/*[IF*/
if((_nb)>(0)){
_j=a2;
_i=1;
while (!((_i)>(_nb)))
{
/*[IRF3.5put*/((/*RF2*/(((T7*)a1))->_storage/*4*/))[(_j)-(1)]=(/*(IRF4.6item*/((/*RF2*/(((T7*)a3))->_storage/*4*/))[(_i)-(1)]/*)*/);
/*]*/
_j=(_j)+(1);
_i=(_i)+(1);
}
}
/*FI]*/
}

T0* r112resize(T0* a1,T2 a2){
T0* R=NULL;
T2 _i=0;
_i=(a2)-((/*RF2*/(((T7*)a1))->_count/*8*/));
while (!((_i)==(0)))
{
r7append_character(((T7*)a1),((T3)'\43'));
_i=(_i)-(1);
}
R=a1;
return R;
}

T2 r112copy_from_stream(T0* a1,T2 a2,T0* a3,T2 a4){
T2 R=0;
R=r92read_stream(a3,a1,a2,a4);
return R;
}

T0* r112twin(T112* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T112*)R)=*C;
return R;
}

T0* r98current_working_directory(T98* C){
T0* R=NULL;
r156connect_to_current_working_directory(&((/*RF2*/(C)->_basic_directory/*4*/)));
R=r98clone(oBC156last_entry);
r156disconnect(&((/*RF2*/(C)->_basic_directory/*4*/)));
return R;
}

T0* r98clone(T0* a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((void*)(NULL))){
R=X10twin(a1);
}
/*FI]*/
return R;
}

T6 r98is_windows(T98* C){
if(fBC98is_windows==0){fBC98is_windows=1;{
T0* _cwd=NULL;
_cwd=r98current_working_directory(C);
/*[IF*/
if(((/*RF2*/(((T7*)_cwd))->_count/*8*/))>=(3)){
oBC98is_windows=r6_px_and((/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(2)-(1)]/*)*/)==(((T3)'\72')),(/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(3)-(1)]/*)*/)==(((T3)'\134')));
}
/*FI]*/
}}
return oBC98is_windows;
}

T6 r98is_unix(T98* C){
if(fBC98is_unix==0){fBC98is_unix=1;{
T0* _cwd=NULL;
_cwd=r98current_working_directory(C);
/*[IF*/
if(((/*RF2*/(((T7*)_cwd))->_count/*8*/))>(0)){
oBC98is_unix=(/*(IRF4.6item*/((/*RF2*/(((T7*)_cwd))->_storage/*4*/))[(1)-(1)]/*)*/)==(((T3)'\57'));
}
/*FI]*/
}}
return oBC98is_unix;
}

T0* r98twin(T98* C){
T0* R=NULL;
R=se_malloc(sizeof(*C));
*((T98*)R)=*C;
return R;
}
T16*eiffel_root_object=NULL;
int se_argc;
char**se_argv;

void initialize_eiffel_runtime(int argc,char*argv[]){
se_argc=argc;
se_argv=argv;
setup_signal_handler();
se_msi1();
/*PCO*/
{T92*n=((T92*)se_malloc(sizeof(*n))/*4*/);
*n=M92;
oBC20INPUT_STREAM_=((T0*)n);
}
/*PCO*/
{T84*n=((T84*)se_malloc(sizeof(*n))/*4*/);
*n=M84;
oBC35STRING_=((T0*)n);
}
/*PCO*/
oBC161root_directory=((T0*)ms161_92);
/*PCO*/
oBC162root_directory=((T0*)ms162_47);
/*PCO*/
{T95*n=((T95*)se_malloc(sizeof(*n))/*4*/);
*n=M95;
oBC19std=((T0*)n);
}
/*PCO*/
{T112*n=((T112*)se_malloc(sizeof(*n))/*4*/);
*n=M112;
oBC54STRING_BUFFER_=((T0*)n);
}
/*PCO*/
{T162*n=((T162*)se_malloc(sizeof(*n))/*4*/);
*n=M162;
oBC29unix_file_system=((T0*)n);
/*[IRF3.1make*//*]*/
}
/*PCO*/
{T161*n=((T161*)se_malloc(sizeof(*n))/*4*/);
*n=M161;
oBC29windows_file_system=((T0*)n);
/*[IRF3.1make*//*]*/
}
/*PCO*/
{T98*n=((T98*)se_malloc(sizeof(*n))/*12*/);
*n=M98;
oBC30operating_system=((T0*)n);
}
/*PCO*/
{T7*n=((T7*)se_malloc(sizeof(*n))/*16*/);
*n=M7;
oBC156last_entry=((T0*)n);
r7make(n,256);
}
/*PCO*/
{T148*n=((T148*)se_malloc(sizeof(*n))/*4*/);
*n=M148;
oBC44Execution_environment=((T0*)n);
}
/*PCO*/
{T110*n=((T110*)se_malloc(sizeof(*n))/*4*/);
*n=M110;
oBC53FIXED_INTEGER_ARRAY_=((T0*)n);
}
/*PCO*/
{T7*n=((T7*)se_malloc(sizeof(*n))/*16*/);
*n=M7;
oBC1tagged_out_memory=((T0*)n);
r7make(n,1024);
}
/*PCO*/
{T63*n=((T63*)se_malloc(sizeof(*n))/*4*/);
*n=M63;
oBC18Exceptions=((T0*)n);
}
/*PCO*/
eiffel_root_object=((T16*)se_malloc(sizeof(*eiffel_root_object))/*20*/);
*eiffel_root_object=M16;
}
int main(int argc,char*argv[]){
initialize_eiffel_runtime(argc,argv);
{T16*n=eiffel_root_object;
r16execute(n);
}
exit(0);
return 0;}
T7*ms149_89510;
T7*ms16_16072;
T7*ms92_1338085634;
T7*ms43_10;
T7*ms81_1449702436;
T7*ms43_449403;
T7*ms16_311;
T7*ms16_329;
T7*ms16_288;
T7*ms16_45a;
T7*ms164_447851;
T7*ms153_1606053737;
T7*ms16_0;
T7*ms161_46;
T7*ms161_92;
T7*ms162_46;
T7*ms162_47;
T7*ms43_0;
T7*ms57_1338477769;
T7*ms164_10;
T7*ms55_0;
T7*ms16_184927;
T7*ms45_1173251759;
T7*ms147_988446515;
T7*ms92_0;
T7*ms174_46;
T7*ms16_45aaa;
T7*ms167_1158552108;
T7*ms21_1529;
T7*ms96_10;
T7*ms146_434195944;
T7*ms174_276;
T7*ms96_447584;
T7*ms16_45aa;
T7*ms43_6359;
T7*ms50_195717202;
T7*ms16_45;
T7*ms161_276;
T7*ms23_10;
T7*ms57_1338477769a;
T7*ms166_1515383187;
T7*ms16_78124153;
T7*ms162_276;
T7*ms16_23342040;
T7*ms16_927745;

T7*se_ms(int c,char*e){
/* Allocation of a Manifest STRING.*/
T7*s=((T7*)se_malloc(sizeof(T7)));
s->id=7;
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)se_malloc(c+1));
memcpy(s->_storage,e,c+1);
return s;}

T7*se_string(char*e){
/* Creation of an Eiffel STRING by copying C char*e */
int c=strlen(e);
T7*s=((T7*)se_malloc(sizeof(*s))/*16*/);
*s=M7;
s->_count=c;
s->_capacity=c+1;
s->_storage=((T9)se_malloc(c+1));
memcpy(s->_storage,e,c+1);
return s;}

void se_msi1(void){
ms149_89510=se_ms(5,"stdin");
ms16_16072=se_ms(4,"gepp");
ms92_1338085634=se_ms(14,"standard input");
ms43_10=se_ms(1,"\n");
ms81_1449702436=se_ms(31,"Syntax error in \"$1\" at line $2");
ms43_449403=se_ms(6,"string");
ms16_311=se_ms(2,"-V");
ms16_329=se_ms(2,"-h");
ms16_288=se_ms(2,"-?");
ms16_45a=se_ms(1,"-");
ms164_447851=se_ms(6,"stdout");
ms153_1606053737=se_ms(24,"$0: cannot write to \'$1\'");
ms16_0=se_ms(0,"");
ms161_46=se_ms(1,".");
ms161_92=se_ms(1,"\\");
ms162_46=se_ms(1,".");
ms162_47=se_ms(1,"/");
ms43_0=se_ms(0,"");
ms57_1338477769=se_ms(11,"parse error");
ms164_10=se_ms(1,"\n");
ms55_0=se_ms(0,"");
ms16_184927=se_ms(6,"--help");
ms45_1173251759=se_ms(14,"scanner jammed");
ms147_988446515=se_ms(20,"$0: cannot read \'$1\'");
ms92_0=se_ms(0,"");
ms174_46=se_ms(1,".");
ms16_45aaa=se_ms(1,"-");
ms167_1158552108=se_ms(13,"$0 version $1");
ms21_1529=se_ms(3,"2.1");
ms96_10=se_ms(1,"\n");
ms146_434195944=se_ms(43,"$0: too many (i.e. $1) nested include files");
ms174_276=se_ms(2,"..");
ms96_447584=se_ms(6,"stderr");
ms16_45aa=se_ms(1,"-");
ms43_6359=se_ms(4," \\\n\11""");
ms50_195717202=se_ms(45,"fatal scanner internal error: no action found");
ms16_45=se_ms(1,"-");
ms161_276=se_ms(2,"..");
ms23_10=se_ms(1,"\n");
ms57_1338477769a=se_ms(11,"parse error");
ms166_1515383187=se_ms(12,"usage: $0 $1");
ms16_78124153=se_ms(78,"[--version][--help][-hV?lM]\n\11""[-Dname ...][--lines][filename \174"" -][filename \174"" -]");
ms162_276=se_ms(2,"..");
ms16_23342040=se_ms(9,"--version");
ms16_927745=se_ms(7,"--lines");
}

void*se_ma172(int argc,...){
T172*m;
va_list pa;
T2*s;
m=se_malloc(sizeof(*m));
*m=M172;
if(argc){
s=se_malloc(argc*sizeof(*s));
m->_storage=s;
m->_capacity=argc;
m->_lower=1;
m->_upper=argc;
va_start(pa,argc);
while(argc--){
*(s++)=va_arg(pa,int);
}
va_end(pa);
}
else{
m->_storage=NULL;
m->_capacity=0;
m->_lower=1;
m->_upper=0;
}
return m;
}

void X26put_character(T0*C,T3 a1){
{Tid id=((T0*)C)->id;
if(id<=96){
if(id<=23){
/*[IRF3.6old_put_character*/{T23* C1=((T23*)C);
T3 b1=a1;
basic_io_putc(b1,(/*RF2*/(C1)->_output_stream/*12*/));
}/*]*/
}
else{
/*[IRF3.6old_put_character*/{T3 b1=a1;
basic_io_putc(b1,basic_io_stderr);
}/*]*/
}}
else{
/*[IRF3.6old_put_character*/{T3 b1=a1;
basic_io_putc(b1,basic_io_stdout);
}/*]*/
}}
}

void X26put_string(T0*C,T0* a1){
{Tid id=((T0*)C)->id;
if(id<=96){
if(id<=23){
r23old_put_string(((T23*)C),a1);
}
else{
r96old_put_string(a1);
}}
else{
r164old_put_string(a1);
}}
}

T0* X10twin(T0*C){
T0* R;
{Tid id=((T0*)C)->id;
if(id<=96){
if(id<=76){
if(id<=43){
if(id<=23){
if(id<=16){
if(id<=7){
R=(r7twin(((T7*)C)));
}
else{
R=(r16twin(((T16*)C)));
}}
else{
R=(r23twin(((T23*)C)));
}}
else{
if(id<=41){
if(id<=40){
R=(r40twin(((T40*)C)));
}
else{
R=(r41twin(((T41*)C)));
}}
else{
R=(r43twin(((T43*)C)));
}}}
else{
if(id<=65){
if(id<=63){
if(id<=60){
R=(r60twin(((T60*)C)));
}
else{
R=(r63twin(((T63*)C)));
}}
else{
R=(r65twin(((T65*)C)));
}}
else{
if(id<=74){
if(id<=69){
R=(r69twin(((T69*)C)));
}
else{
R=(r74twin(((T74*)C)));
}}
else{
R=(r76twin(((T76*)C)));
}}}}
else{
if(id<=86){
if(id<=81){
if(id<=80){
if(id<=79){
R=(r79twin(((T79*)C)));
}
else{
R=(r80twin(((T80*)C)));
}}
else{
R=(r81twin(((T81*)C)));
}}
else{
if(id<=84){
if(id<=83){
R=(r83twin(((T83*)C)));
}
else{
R=(r84twin(((T84*)C)));
}}
else{
R=(r86twin(((T86*)C)));
}}}
else{
if(id<=92){
if(id<=90){
if(id<=88){
R=(r88twin(((T88*)C)));
}
else{
R=(r90twin(((T90*)C)));
}}
else{
R=(r92twin(((T92*)C)));
}}
else{
if(id<=95){
if(id<=94){
R=(r94twin(((T94*)C)));
}
else{
R=(r95twin(((T95*)C)));
}}
else{
R=(r96twin(((T96*)C)));
}}}}}
else{
if(id<=148){
if(id<=122){
if(id<=107){
if(id<=106){
if(id<=98){
R=(r98twin(((T98*)C)));
}
else{
R=(r106twin(((T106*)C)));
}}
else{
R=(r107twin(((T107*)C)));
}}
else{
if(id<=112){
if(id<=110){
R=(r110twin(((T110*)C)));
}
else{
R=(r112twin(((T112*)C)));
}}
else{
R=(r122twin(((T122*)C)));
}}}
else{
if(id<=143){
if(id<=128){
if(id<=125){
R=(r125twin(((T125*)C)));
}
else{
R=(r128twin(((T128*)C)));
}}
else{
R=(r143twin(((T143*)C)));
}}
else{
if(id<=147){
if(id<=146){
R=(r146twin(((T146*)C)));
}
else{
R=(r147twin(((T147*)C)));
}}
else{
R=(r148twin(((T148*)C)));
}}}}
else{
if(id<=164){
if(id<=154){
if(id<=153){
if(id<=149){
R=(r149twin(((T149*)C)));
}
else{
R=(r153twin(((T153*)C)));
}}
else{
R=(r154twin(((T154*)C)));
}}
else{
if(id<=162){
if(id<=161){
R=(r161twin(((T161*)C)));
}
else{
R=(r162twin(((T162*)C)));
}}
else{
R=(r164twin(((T164*)C)));
}}}
else{
if(id<=168){
if(id<=167){
if(id<=166){
R=(r166twin(((T166*)C)));
}
else{
R=(r167twin(((T167*)C)));
}}
else{
R=(r168twin(((T168*)C)));
}}
else{
if(id<=174){
if(id<=172){
R=(r172twin(((T172*)C)));
}
else{
R=(r174twin(((T174*)C)));
}}
else{
R=(r176twin(((T176*)C)));
}}}}}}
return R;
}

void X69clear_all(T0*C,T0* a1){
{Tid id=((T0*)C)->id;
if(id<=110){
if(id<=69){
r69clear_all(a1);
}
else{
/*[IRF3.6clear_all*/{T0* b1=a1;
T2 __v=0;
/*[IRF3.6set_all_with*/{T76* C2=((T76*)b1);
T2 c1=__v;
r78set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,(/*RF2*/(C2)->_upper/*12*/));
}/*]*/
}/*]*/
}}
else{
if(id<=125){
/*[IRF3.6clear_all*/{T0* b1=a1;
T0* __v=NULL;
/*[IRF3.6set_all_with*/{T90* C2=((T90*)b1);
T0* c1=__v;
r87set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,(/*RF2*/(C2)->_upper/*12*/));
}/*]*/
}/*]*/
}
else{
/*[IRF3.6clear_all*/{T0* b1=a1;
T0* __v=NULL;
/*[IRF3.6set_all_with*/{T107* C2=((T107*)b1);
T0* c1=__v;
r109set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,(/*RF2*/(C2)->_upper/*12*/));
}/*]*/
}/*]*/
}}}
}

T0* X69make(T0*C,T2 a1){
T0* R;
{Tid id=((T0*)C)->id;
if(id<=110){
if(id<=69){
R=(r69make(a1));
}
else{
R=(r110make(a1));
}}
else{
if(id<=125){
R=(r125make(a1));
}
else{
R=(r168make(a1));
}}}
return R;
}

T0* X69resize(T0*C,T0* a1,T2 a2){
T0* R;
{Tid id=((T0*)C)->id;
if(id<=110){
if(id<=69){
R=(r69resize(a1,a2));
}
else{
R=(r110resize(a1,a2));
}}
else{
if(id<=125){
R=(r125resize(a1,a2));
}
else{
R=(r168resize(a1,a2));
}}}
return R;
}

void X38put_new_line(T0*C){
{Tid id=((T0*)C)->id;
if(id<=96){
if(id<=23){
/*[IRF3.6put_new_line*/{T23* C1=((T23*)C);
/*[IRF3.6put_string*/{T23* C2=C1;
T0* c1=((T0*)ms23_10);
r23old_put_string(C2,c1);
}/*]*/
}/*]*/
}
else{
/*[IRF3.2put_new_line*//*[IRF3.6put_string*/{T0* b1=((T0*)ms96_10);
r96old_put_string(b1);
}/*]*/
/*]*/
}}
else{
/*[IRF3.2put_new_line*//*[IRF3.6put_string*/{T0* b1=((T0*)ms164_10);
r164old_put_string(b1);
}/*]*/
/*]*/
}}
}

void X38put_string(T0*C,T0* a1){
{Tid id=((T0*)C)->id;
if(id<=96){
if(id<=23){
/*[IRF3.6put_string*/{T23* C1=((T23*)C);
T0* b1=a1;
r23old_put_string(C1,b1);
}/*]*/
}
else{
/*[IRF3.6put_string*/{T0* b1=a1;
r96old_put_string(b1);
}/*]*/
}}
else{
/*[IRF3.6put_string*/{T0* b1=a1;
r164old_put_string(b1);
}/*]*/
}}
}

void X80fill(T0*C){
{Tid id=((T0*)C)->id;
if(id<=79){
r79fill(((T79*)C));
}
else{
/*[IRF3.3fill*/((((T80*)(((T80*)C))))->_filled/*33*/)=(0);
/*]*/
}}
}

T2 X171count(T0*C){
T2 R;
{Tid id=((T0*)C)->id;
if(id<=76){
R=(/*(IRF4.6count*/((/*RF2*/(((T76*)C))->_upper/*12*/))+(1)/*)*/);
}
else{
R=(r172count(((T172*)C)));
}}
return R;
}

T2 X171item(T0*C,T2 a1){
T2 R;
{Tid id=((T0*)C)->id;
if(id<=76){
R=(/*(IRF4.6item*/((/*RF2*/(((T76*)C))->_storage/*4*/))[a1]/*)*/);
}
else{
R=(r172item(((T172*)C),a1));
}}
return R;
}

T2 X171lower(T0*C){
T2 R;
{Tid id=((T0*)C)->id;
if(id<=76){
R=(0);
}
else{
R=((/*RF2*/(((T172*)C))->_lower/*16*/));
}}
return R;
}

void X74put(T0*C,T0* a1,T2 a2){
{Tid id=((T0*)C)->id;
if(id<=76){
if(id<=74){
/*[IRF3.6put*/{T74* C1=((T74*)C);
T0* b1=a1;
T2 b2=a2;
((/*RF2*/(C1)->_storage/*4*/))[b2]=(b1);
}/*]*/
}
else{
/*[IRF3.5put*/((/*RF2*/(((T76*)C))->_storage/*4*/))[a2]=(T60toT2(a1));
/*]*/
}}
else{
if(id<=90){
/*[IRF3.5put*/((/*RF2*/(((T90*)C))->_storage/*4*/))[a2]=(a1);
/*]*/
}
else{
/*[IRF3.5put*/((/*RF2*/(((T107*)C))->_storage/*4*/))[a2]=(a1);
/*]*/
}}}
}

T0* X74item(T0*C,T2 a1){
T0* R;
{Tid id=((T0*)C)->id;
if(id<=76){
if(id<=74){
R=(r74item(((T74*)C),a1));
}
else{
R=(T2toT60(/*(IRF4.6item*/((/*RF2*/(((T76*)C))->_storage/*4*/))[a1]/*)*/));
}}
else{
if(id<=90){
R=(/*(IRF4.6item*/((/*RF2*/(((T90*)C))->_storage/*4*/))[a1]/*)*/);
}
else{
R=(/*(IRF4.6item*/((/*RF2*/(((T107*)C))->_storage/*4*/))[a1]/*)*/);
}}}
return R;
}

void X74set_all_with(T0*C,T0* a1){
{Tid id=((T0*)C)->id;
if(id<=76){
if(id<=74){
/*[IRF3.6set_all_with*/{T74* C1=((T74*)C);
T0* b1=a1;
r75set_all_with((/*RF2*/(C1)->_storage/*4*/),b1,(/*RF2*/(C1)->_upper/*12*/));
}/*]*/
}
else{
/*[IRF3.6set_all_with*/{T76* C1=((T76*)C);
T2 b1=T60toT2(a1);
r78set_all_with((/*RF2*/(C1)->_storage/*4*/),b1,(/*RF2*/(C1)->_upper/*12*/));
}/*]*/
}}
else{
if(id<=90){
/*[IRF3.6set_all_with*/{T90* C1=((T90*)C);
T0* b1=a1;
r87set_all_with((/*RF2*/(C1)->_storage/*4*/),b1,(/*RF2*/(C1)->_upper/*12*/));
}/*]*/
}
else{
/*[IRF3.6set_all_with*/{T107* C1=((T107*)C);
T0* b1=a1;
r109set_all_with((/*RF2*/(C1)->_storage/*4*/),b1,(/*RF2*/(C1)->_upper/*12*/));
}/*]*/
}}}
}

void X74resize(T0*C,T2 a1){
{Tid id=((T0*)C)->id;
if(id<=76){
if(id<=74){
r74resize(((T74*)C),a1);
}
else{
r76resize(((T76*)C),a1);
}}
else{
if(id<=90){
r90resize(((T90*)C),a1);
}
else{
r107resize(((T107*)C),a1);
}}}
}

T6 X39is_connected(T0*C){
T6 R;
{Tid id=((T0*)C)->id;
if(id<=94){
R=(/*(IRF4.7is_connected*/((/*RF2*/(((T94*)C))->_path/*5*/))!=(NULL)/*)*/);
}
else{
R=(1);
}}
return R;
}

void X39read_character(T0*C){
{Tid id=((T0*)C)->id;
if(id<=94){
r94read_character(((T94*)C));
}
else{
r149old_read_character(((T149*)C));
}}
}

T6 X39end_of_input(T0*C){
T6 R;
{Tid id=((T0*)C)->id;
if(id<=94){
R=(r94end_of_input(((T94*)C)));
}
else{
R=(r149old_end_of_file(((T149*)C)));
}}
return R;
}

T3 X39last_character(T0*C){
T3 R;
{Tid id=((T0*)C)->id;
if(id<=94){
R=(/*(IRF4.6last_character*/((T3)((/*RF2*/(((T94*)C))->_memory/*13*/)))/*)*/);
}
else{
R=(/*(IRF4.6old_last_character*/((T3)((/*RF2*/(((T149*)C))->_memory/*13*/)))/*)*/);
}}
return R;
}

T0* X82default_message(T0*C){
T0* R;
{Tid id=((T0*)C)->id;
if(id<=147){
if(id<=146){
if(id<=81){
R=(r81default_message(((T81*)C)));
}
else{
R=(r146default_message(((T146*)C)));
}}
else{
R=(r147default_message(((T147*)C)));
}}
else{
if(id<=166){
if(id<=153){
R=(r153default_message(((T153*)C)));
}
else{
R=(r166default_message(((T166*)C)));
}}
else{
R=(r167default_message(((T167*)C)));
}}}
return R;
}

T6 X98is_windows(T0*C){
T6 R;
{Tid id=((T0*)C)->id;
if(id<=98){
if(id<=96){
R=(r96is_windows(((T96*)C)));
}
else{
R=(r98is_windows(((T98*)C)));
}}
else{
if(id<=149){
R=(r149is_windows(((T149*)C)));
}
else{
R=(r164is_windows(((T164*)C)));
}}}
return R;
}

T6 X98is_unix(T0*C){
T6 R;
{Tid id=((T0*)C)->id;
if(id<=98){
if(id<=96){
R=(r96is_unix(((T96*)C)));
}
else{
R=(r98is_unix(((T98*)C)));
}}
else{
if(id<=149){
R=(r149is_unix(((T149*)C)));
}
else{
R=(r164is_unix(((T164*)C)));
}}}
return R;
}

T0* X159dirname(T0*C,T0* a1){
T0* R;
{Tid id=((T0*)C)->id;
if(id<=161){
R=(r161dirname(a1));
}
else{
R=(r162dirname(a1));
}}
return R;
}

T0* X159canonical_pathname(T0*C,T0* a1){
T0* R;
{Tid id=((T0*)C)->id;
if(id<=161){
R=(r161canonical_pathname(a1));
}
else{
R=(r162canonical_pathname(a1));
}}
return R;
}

T0* T2toT60(T2 source){
T60*destination=((T60*)se_malloc(sizeof(*destination))/*8*/);
*destination=M60;
destination->_item=source;
return ((T0*)destination);
}

T2 T60toT2(T0* source){
return (((T60*)source)->_item);
}

T0* T6toT40(T6 source){
T40*destination=((T40*)se_malloc(sizeof(*destination))/*5*/);
*destination=M40;
destination->_item=source;
return ((T0*)destination);
}

#ifdef __cplusplus
}
#endif
