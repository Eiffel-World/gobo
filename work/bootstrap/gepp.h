#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmallEiffel The GNU Eiffel Compiler
Release -0.74 Beta #7 (Monday October 1st 2001)
Copyright (C), 1994-2001 - LORIA - UHP - INRIA - FRANCE
Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
http://SmallEiffel.loria.fr
C Compiler options used: -O2 -nologo -D"WIN32" -w
*/

/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of 
  compilation : -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifdef WIN32
#include <windows.h>
#else
#ifndef O_RDONLY
#include <sys/file.h>
#endif
#ifndef O_RDONLY
#define O_RDONLY 0000
#endif
#endif

/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0
#endif

/* 
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.
*/
#ifdef _SIGSET_H_types
#define JMP_BUF    sigjmp_buf
#define SETJMP(x)  sigsetjmp( (x), 1)
#define LONGJMP    siglongjmp
#else
#define JMP_BUF    jmp_buf
#define SETJMP(x)  setjmp( (x) )
#define LONGJMP    longjmp
#endif

/* 
   Type to store reference objects Id :
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/* 
   The default channel used to print runtime error messages :
*/
#define SE_ERR stderr

/* 
   Eiffel type INTEGER is #2 :
*/
typedef int T2;
#define EIF_INTEGER T2
#define M2 (0)
#define EIF_INTEGER_BITS (CHAR_BIT*sizeof(int))
#define EIF_MINIMUM_INTEGER (INT_MIN)
#define EIF_MAXIMUM_INTEGER (INT_MAX)

/*
  Eiffel type CHARACTER is #3 :
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T2)(x))
#define T3to_integer(x) ((T2)((char)(x)))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL is #4 :
*/
typedef float T4;
#define EIF_REAL T4
#define M4 (0.0)
#define EIF_REAL_BITS (CHAR_BIT*sizeof(float))
#define EIF_MINIMUM_REAL (-(FLT_MAX))
#define EIF_MAXIMUM_REAL (FLT_MAX)
#define T2toT4(x) ((T4)(x))

/*
  Eiffel type DOUBLE is #5 :
*/
typedef double T5;
#define EIF_DOUBLE T5
#define M5 (0.0)
#define EIF_DOUBLE_BITS (CHAR_BIT*sizeof(double))
#define EIF_MINIMUM_DOUBLE (-(DBL_MAX))
#define EIF_MAXIMUM_DOUBLE (DBL_MAX)
#define T2toT5(x) ((T5)(x))
#define T4toT5(x) ((T5)(x))

/*
  Eiffel type BOOLEAN is #6 :
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/* 
   Eiffel type POINTER is #8 :
*/
typedef void* T8;
#define EIF_POINTER T8
#define M8 (NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side :
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL :
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/* 
   Wrappers for `malloc', `calloc' and `realloc' :
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);
void* se_realloc(void *ptr, size_t size);

/*C Header Pass 1 :*/
typedef struct S43 T43;
typedef struct S167 T167;
typedef struct S95 T95;
typedef struct S172 T172;
typedef struct S63 T63;
typedef struct S80 T80;
typedef struct S69 T69;
typedef struct S110 T110;
typedef struct S143 T143;
typedef struct S149 T149;
typedef struct S83 T83;
typedef struct S60 T60;
typedef struct S168 T168;
typedef struct S41 T41;
typedef struct S23 T23;
typedef struct S176 T176;
typedef struct S166 T166;
typedef struct S161 T161;
typedef struct S16 T16;
typedef struct S107 T107;
typedef struct S153 T153;
typedef struct S40 T40;
typedef struct S90 T90;
typedef struct S94 T94;
typedef struct S7 T7;
typedef struct S154 T154;
typedef struct S92 T92;
typedef struct S156 T156;
typedef struct S84 T84;
typedef struct S146 T146;
typedef struct S147 T147;
typedef struct S76 T76;
typedef struct S122 T122;
typedef struct S148 T148;
typedef struct S79 T79;
typedef struct S164 T164;
typedef struct S96 T96;
typedef struct S162 T162;
typedef struct S125 T125;
typedef struct S86 T86;
typedef struct S74 T74;
typedef struct S65 T65;
typedef struct S128 T128;
typedef struct S112 T112;
typedef struct S98 T98;
typedef struct S106 T106;
typedef struct S174 T174;
typedef struct S81 T81;
typedef struct S88 T88;

/*C Header Pass 2 :*/
typedef T0**T109;
typedef T0**T87;
typedef T3*T9;
typedef T2*T78;
typedef T0**T75;

/*C Header Pass 3 :*/
struct S156{T8 _directory_stream;T8 _current_entry;};
int se_cmpT156(T156 o1,T156 o2);

/*C Header Pass 4 :*/
struct S43{Tid id;T2 _error_count;T0* _yytranslate;T0* _yyr1;T0* _yyr2;T0* _yydefact;T0* _yydefgoto;T0* _yypact;T0* _yypgoto;T0* _yytable;T0* _yycheck;T0* _yyvs;T0* _yyss;T2 _yyvsp;T2 _yyssp;T0* _yyval;T6 _yy_lookahead_needed;T2 _yyerrstatus;T2 _yy_parsing_status;T0* _FIXED_ARRAY_;T2 _last_token;T0* _input_buffer;T2 _line;T2 _column;T2 _position;T2 _yy_start_state;T0* _yy_content;T2 _yy_end;T2 _yy_start;T2 _yy_line;T2 _yy_column;T2 _yy_position;T6 _yy_more_flag;T2 _yy_more_len;T2 _yy_last_accepting_state;T2 _yy_last_accepting_cpos;T0* _yy_nxt;T0* _yy_chk;T0* _yy_base;T0* _yy_def;T0* _yy_ec;T0* _yy_meta;T0* _yy_accept;T0* _yy_acclist;T6 _yy_rejected;T0* _yy_state_stack;T2 _yy_state_count;T2 _yy_full_match;T2 _yy_lp;T2 _yy_looking_for_trail_begin;T2 _yy_full_lp;T2 _yy_full_state;T2 _line_nb;T0* _last_value;T6 _empty_lines;T0* _output_file;T0* _error_handler;T6 _makefile_dependencies;T0* _defined_values;T2 _if_level;T2 _ignored_level;T0* _include_stack;};
extern T43 M43;
struct S167{Tid id;T0* _parameters;};
extern T167 M167;
struct S95{Tid id;};
extern T95 M95;
struct S172{Tid id;T78 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T172 M172;
struct S63{Tid id;};
extern T63 M63;
struct S69{Tid id;};
extern T69 M69;
struct S110{Tid id;};
extern T110 M110;
struct S143{Tid id;T2 _position;T0* _container;T0* _next_cursor;};
extern T143 M143;
struct S149{Tid id;T6 _push_back_flag;T156 _basic_directory;T2 _memory;T0* _name;T6 _end_of_file;};
extern T149 M149;
struct S83{Tid id;T0* _error_file;T0* _warning_file;T0* _message_file;};
extern T83 M83;
struct S60{Tid id;T2 _item;};
extern T60 M60;
struct S168{Tid id;};
extern T168 M168;
struct S41{Tid id;T8 _item;};
extern T41 M41;
struct S23{Tid id;T0* _name;T0* _path;T8 _output_stream;};
extern T23 M23;
struct S176{Tid id;};
extern T176 M176;
struct S166{Tid id;T0* _parameters;};
extern T166 M166;
struct S161{Tid id;};
extern T161 M161;
struct S16{Tid id;T0* _in_filename;T0* _out_filename;T0* _parser;T0* _error_handler;};
extern T16 M16;
struct S107{Tid id;T109 _storage;T2 _capacity;T2 _upper;};
extern T107 M107;
struct S153{Tid id;T0* _parameters;};
extern T153 M153;
struct S40{Tid id;T6 _item;};
extern T40 M40;
struct S90{Tid id;T87 _storage;T2 _capacity;T2 _upper;};
extern T90 M90;
struct S94{Tid id;T6 _push_back_flag;T0* _path;T8 _input_stream;T2 _memory;};
extern T94 M94;
struct S154{Tid id;T0* _name;T0* _last_entry;T6 _end_of_input;T0* _entry_buffer;T156 _basic_directory;};
extern T154 M154;
struct S7{Tid id;T9 _storage;T2 _count;T2 _capacity;};
extern T7 M7;
struct S80{Tid id;T0* _content;T2 _capacity;T2 _position;T2 _column;T2 _line;T2 _index;T2 _upper;T6 _beginning_of_line;T6 _filled;};
extern T80 M80;
struct S92{Tid id;};
extern T92 M92;
extern T156 M156;
struct S84{Tid id;};
extern T84 M84;
struct S146{Tid id;T0* _parameters;};
extern T146 M146;
struct S147{Tid id;T0* _parameters;};
extern T147 M147;
struct S76{Tid id;T78 _storage;T2 _capacity;T2 _upper;};
extern T76 M76;
struct S122{Tid id;T0* _equality_tester;T0* _key_equality_tester;T2 _count;T2 _capacity;T2 _last_position;T2 _modulus;T2 _free_slot;T2 _position;T2 _slots_position;T2 _clashes_previous_position;T2 _found_position;T0* _internal_cursor;T0* _items;T0* _keys;T0* _clashes;T0* _slots;T0* _FIXED_ITEM_ARRAY_;T0* _FIXED_KEY_ARRAY_;};
extern T122 M122;
struct S148{Tid id;};
extern T148 M148;
struct S79{Tid id;T0* _content;T2 _capacity;T2 _position;T2 _column;T2 _line;T2 _index;T2 _upper;T6 _beginning_of_line;T6 _filled;T6 _interactive;T0* _file;T6 _end_of_file;};
extern T79 M79;
struct S164{Tid id;T156 _basic_directory;T0* _name;};
extern T164 M164;
struct S96{Tid id;T156 _basic_directory;T0* _name;};
extern T96 M96;
struct S162{Tid id;};
extern T162 M162;
struct S125{Tid id;};
extern T125 M125;
struct S86{Tid id;T87 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T86 M86;
struct S74{Tid id;T75 _storage;T2 _capacity;T2 _upper;};
extern T74 M74;
struct S65{Tid id;T3 _item;};
extern T65 M65;
struct S128{Tid id;};
extern T128 M128;
struct S112{Tid id;};
extern T112 M112;
struct S98{Tid id;T156 _basic_directory;};
extern T98 M98;
struct S106{Tid id;T2 _count;T2 _capacity;T0* _storage;T0* _FIXED_ARRAY_;};
extern T106 M106;
struct S174{Tid id;T6 _is_relative;T0* _drive;T0* _hostname;T2 _count;T0* _components;};
extern T174 M174;
struct S81{Tid id;T0* _parameters;};
extern T81 M81;
struct S88{Tid id;T0* _program_name;};
extern T88 M88;
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/

/*
  This file (SmallEiffel/sys/runtime/boost.h) is automatically included when
  `run_control.boost' is true (ie. only for mode -boost).
*/
#define SE_BOOST 1
void se_print_run_time_stack (void);
void se_signal_handler(int sig);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/exception.h) is automatically included 
  when exception handling is used somewhere in the live code.
*/

#define SE_EXCEPTIONS 1

/*
  Constants from Eiffel class EXCEPTIONS :
*/
#define Check_instruction 	  1
#define Class_invariant 	  2
#define Developer_exception 	  3
#define Incorrect_inspect_value   4
#define Loop_invariant 		  5
#define Loop_variant 		  6
#define No_more_memory  	  7
#define Postcondition 		  8
#define Precondition  		  9
#define Routine_failure  	  10
#define	Os_signal		  11
#define Void_attached_to_expanded 12
#define Void_call_target 	  13
#define System_level_type_error	  14

/* 
   This will be the structure of rescue contexts.  A rescue context 
   will be declared for every routine that has a rescue clause.

   The `next' pointer is the address of the next rescue context if there
   is one higher up the call chain, or NULL if there is no other
   context.
*/
struct rescue_context {
  JMP_BUF jb;
#ifdef SE_NO_CHECK
  /* To keep track of dump stack to unwind it safely
     before the LONGJMP :
  */
  struct _se_dump_stack * top_of_ds ;
#endif
  struct rescue_context *next;
};

extern struct rescue_context *rescue_context_top;
extern int internal_exception_number;
extern int original_internal_exception_number;
extern int signal_exception_number;
extern char *additional_error_message;

void setup_signal_handler(void);
void signal_exception_handler(int);
void internal_exception_handler(int);
void print_exception(void);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_directory.h) is automatically 
  included when some external "SmallEiffel" feature of class BASIC_DIRECTORY
  is live.
*/
#ifndef WIN32
#include <dirent.h>
#endif
#ifndef WIN32
#include <unistd.h>
#endif

EIF_POINTER basic_directory_open(EIF_POINTER path);
EIF_POINTER basic_directory_read_entry(EIF_POINTER dirstream);
EIF_POINTER basic_directory_get_entry_name(EIF_POINTER entry);
EIF_BOOLEAN basic_directory_close(EIF_POINTER dirstream);
#define basic_directory_current_working_directory (basic_directory_cwd())
EIF_POINTER basic_directory_cwd(void);
EIF_BOOLEAN basic_directory_chdir(EIF_POINTER destination);
EIF_BOOLEAN basic_directory_mkdir(EIF_POINTER directory_path);
EIF_BOOLEAN basic_directory_rmdir(EIF_POINTER directory_path);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_io.h) is automatically 
  included when some external "SmallEiffel" basic_io_* feature is used.
*/

#define basic_io_stdin (stdin)
#define basic_io_stdout (stdout)
#define basic_io_stderr (stderr)
#define basic_io_eof (EOF)
#define basic_io_text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define basic_io_text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define basic_io_text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define basic_io_text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define basic_io_text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define basic_io_binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define basic_io_binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define basic_io_binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define basic_io_fclose(p) (fclose((FILE*)(p)))
#define basic_io_flush(p) (fflush((FILE*)(p)))
#define basic_io_getc(f) (getc(((FILE*)(f))))
#define basic_io_putc(b, f) (putc((b),((FILE*)(f))))
#define basic_io_feof(f) (feof(((FILE*)(f))))
#define basic_io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define basic_io_remove(f) (remove(((char*)(f))))
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_getenv.h) is automatically 
  included when the GENERAL.basic_getenv feature is used (ie. in live code).
*/

EIF_POINTER basic_getenv(EIF_POINTER name);
T6 r8is_null(T8 C);
T6 r6_ix_not(T6 C);
T6 r6_px_or(T6 C,T6 a1);
T6 r6_px_and(T6 C,T6 a1);
T6 r3_px_6061(T3 C,T3 a1);
T6 r3is_digit(T3 C);
T6 r3is_separator(T3 C);
T6 r3_px_6261(T3 C,T3 a1);
T2 r3value(T3 C);
T2 r3decimal_value(T3 C);
T0* r2out(T2 C);
T2 r2max(T2 C,T2 a1);
T2 r2min(T2 C,T2 a1);
T3 r2digit(T2 C);
void r2append_in(T2 C,T0* a1);
extern T0*oBC1tagged_out_memory;
void r109clear_all(T109 C,T2 a1);
T109 r109realloc(T109 C,T2 a1,T2 a2);
void r109set_all_with(T109 C,T0* a1,T2 a2);
void r109clear(T109 C,T2 a1,T2 a2);
void r109copy_from(T109 C,T109 a1,T2 a2);
void r87clear_all(T87 C,T2 a1);
T87 r87realloc(T87 C,T2 a1,T2 a2);
void r87move(T87 C,T2 a1,T2 a2,T2 a3);
void r87set_all_with(T87 C,T0* a1,T2 a2);
void r87clear(T87 C,T2 a1,T2 a2);
void r87copy_from(T87 C,T87 a1,T2 a2);
void r9copy_slice(T9 C,T2 a1,T9 a2,T2 a3,T2 a4);
T9 r9realloc(T9 C,T2 a1,T2 a2);
void r9set_all_with(T9 C,T3 a1,T2 a2);
T6 r9fast_memcmp(T9 C,T9 a1,T2 a2);
void r9copy_at(T9 C,T2 a1,T9 a2,T2 a3);
void r9copy_from(T9 C,T9 a1,T2 a2);
void r78clear_all(T78 C,T2 a1);
T78 r78realloc(T78 C,T2 a1,T2 a2);
void r78set_all_with(T78 C,T2 a1,T2 a2);
void r78clear(T78 C,T2 a1,T2 a2);
void r78copy_from(T78 C,T78 a1,T2 a2);
void r75clear_all(T75 C,T2 a1);
T75 r75realloc(T75 C,T2 a1,T2 a2);
void r75set_all_with(T75 C,T0* a1,T2 a2);
void r75clear(T75 C,T2 a1,T2 a2);
void r75copy_from(T75 C,T75 a1,T2 a2);
void r7copy(T7* C,T0* a1);
T0* r7substring(T7* C,T2 a1,T2 a2);
T6 r7is_equal(T7* C,T0* a1);
T6 r7is_integer(T7* C);
void r7make(T7* C,T2 a1);
void r7append_string(T7* C,T0* a1);
void r7make_filled(T7* C,T3 a1,T2 a2);
void r7extend(T7* C,T3 a1);
T2 r7hash_code(T7* C);
T2 r7to_integer(T7* C);
void r7append_character(T7* C,T3 a1);
void r7from_external_copy(T7* C,T8 a1);
T8 r7to_external(T7* C);
T0* r7twin(T7* C);
void r7swap(T7* C,T2 a1,T2 a2);
void r172copy(T172* C,T0* a1);
T2 r172count(T172* C);
T2 r172item(T172* C,T2 a1);
T0* r172twin(T172* C);
void r107copy(T107* C,T0* a1);
void r107make(T107* C,T2 a1);
void r107resize(T107* C,T2 a1);
T0* r107twin(T107* C);
void r90copy(T90* C,T0* a1);
void r90make(T90* C,T2 a1);
void r90resize(T90* C,T2 a1);
T0* r90twin(T90* C);
void r76copy(T76* C,T0* a1);
void r76make(T76* C,T2 a1);
void r76resize(T76* C,T2 a1);
T0* r76twin(T76* C);
void r76with_capacity(T76* C,T2 a1);
void r76from_collection(T76* C,T0* a1);
void r86copy(T86* C,T0* a1);
void r86force(T86* C,T0* a1,T2 a2);
T2 r86count(T86* C);
T0* r86item(T86* C,T2 a1);
T6 r86valid_index(T86* C,T2 a1);
void r86make(T86* C,T2 a1,T2 a2);
void r86add_last(T86* C,T0* a1);
void r86resize(T86* C,T2 a1,T2 a2);
T0* r86twin(T86* C);
void r74copy(T74* C,T0* a1);
T2 r74count(T74* C);
T0* r74item(T74* C,T2 a1);
void r74make(T74* C,T2 a1);
void r74resize(T74* C,T2 a1);
T0* r74twin(T74* C);
void r69clear_all(T0* a1);
T0* r69make(T2 a1);
T0* r69resize(T0* a1,T2 a2);
T0* r69twin(T69* C);
T0* r110to_fixed_array(T0* a1);
T0* r110make(T2 a1);
T0* r110make_from_array(T0* a1);
T0* r110resize(T0* a1,T2 a2);
T0* r110twin(T110* C);
void r143copy(T143* C,T0* a1);
void r143make(T143* C,T0* a1);
T6 r143off(T143* C);
T0* r143twin(T143* C);
T0* r168make(T2 a1);
T0* r168resize(T0* a1,T2 a2);
T0* r168twin(T168* C);
T2 r122new_capacity(T2 a1);
void r122copy(T122* C,T0* a1);
void r122force(T122* C,T0* a1,T0* a2);
void r122make_clashes(T122* C,T2 a1);
void r122search_position(T122* C,T0* a1);
void r122remove_traversing_cursor(T122* C,T0* a1);
void r122clone_slots(T122* C);
extern T0*oBC53FIXED_INTEGER_ARRAY_;
void r122keys_resize(T122* C,T2 a1);
void r122clone_clashes(T122* C);
void r122move_all_cursors_after(T122* C);
void r122make_items(T122* C,T2 a1);
void r122add_traversing_cursor(T122* C,T0* a1);
T0* r122clone(T0* a1);
void r122remove_position(T122* C,T2 a1);
void r122make(T122* C,T2 a1);
void r122remove(T122* C,T0* a1);
void r122clone_items(T122* C);
T6 r122has(T122* C,T0* a1);
void r122make_keys(T122* C,T2 a1);
T2 r122hash_position(T122* C,T0* a1);
void r122items_resize(T122* C,T2 a1);
void r122clone_keys(T122* C);
void r122make_with_equality_testers(T122* C,T2 a1,T0* a2,T0* a3);
void r122move_cursors_after(T122* C,T2 a1);
void r122resize(T122* C,T2 a1);
void r122move_cursors_forth(T122* C,T2 a1);
void r122clashes_resize(T122* C,T2 a1);
void r122slots_resize(T122* C,T2 a1);
T0* r122twin(T122* C);
T0* r122new_cursor(T122* C);
void r122make_slots(T122* C,T2 a1);
void r122move_all_cursors(T122* C,T2 a1,T2 a2);
T2 r122new_modulus(T2 a1);
T6 r122cursor_off(T0* a1);
T0* r125make(T2 a1);
T0* r125resize(T0* a1,T2 a2);
T0* r125twin(T125* C);
T6 r128test(T0* a1,T0* a2);
T0* r128twin(T128* C);
void r106copy(T106* C,T0* a1);
void r106put(T106* C,T0* a1);
T0* r106item(T106* C);
T0* r106clone(T0* a1);
void r106make(T106* C,T2 a1);
void r106remove(T106* C);
T0* r106twin(T106* C);
T6 r106is_full(T106* C);
void r43yy_refill_input_buffer(T43* C);
T0* r43text_substring(T43* C,T2 a1,T2 a2);
void r43yy_build_tables(T43* C);
extern T0*oBC45yy_meta_template;
extern int fBC45yy_meta_template;
T0* r43yy_meta_template(void);
T6 r43syntax_error(T43* C);
extern T0*oBC43yycheck_template;
extern int fBC43yycheck_template;
T0* r43yycheck_template(void);
void r43yy_set_beginning_of_line(T43* C);
extern T0*oBC45yy_accept_template;
extern int fBC45yy_accept_template;
T0* r43yy_accept_template(void);
void r43read_token(T43* C);
extern T0*oBC45yy_base_template;
extern int fBC45yy_base_template;
T0* r43yy_base_template(void);
void r43yy_build_parser_tables(T43* C);
extern T0*oBC43yytable_template;
extern int fBC43yytable_template;
T0* r43yytable_template(void);
void r43set_input_buffer(T43* C,T0* a1);
void r43make_gepp_scanner(T43* C);
T0* r43yyfixed_array(T0* a1);
void r43process_include(T43* C,T0* a1);
T2 r43yy_null_trans_state(T43* C,T2 a1);
extern T0*oBC43yypgoto_template;
extern int fBC43yypgoto_template;
T0* r43yypgoto_template(void);
extern T0*oBC55Empty_buffer;
extern int fBC55Empty_buffer;
T0* r43Empty_buffer(void);
extern T0*oBC19std;
void r43output(T43* C,T0* a1);
void r43yy_set_content(T43* C,T0* a1);
extern T0*oBC45yy_nxt_template;
extern int fBC45yy_nxt_template;
T0* r43yy_nxt_template(void);
void r43make(T43* C,T0* a1);
extern T0*oBC45yy_chk_template;
extern int fBC45yy_chk_template;
T0* r43yy_chk_template(void);
void r43fatal_error(T0* a1);
extern T0*oBC44Execution_environment;
extern T0*oBC43yypact_template;
extern int fBC43yypact_template;
T0* r43yypact_template(void);
void r43echo(T43* C);
void r43make_parser_skeleton(T43* C);
extern T0*oBC54STRING_BUFFER_;
extern T0*oBC43yydefact_template;
extern int fBC43yydefact_template;
T0* r43yydefact_template(void);
extern T0*oBC45yy_def_template;
extern int fBC45yy_def_template;
T0* r43yy_def_template(void);
T0* r43yytype1(T0* a1);
void r43yy_clear_all(T43* C);
T6 r43yytype2(T0* a1);
extern T0*oBC45yy_ec_template;
extern int fBC45yy_ec_template;
T0* r43yy_ec_template(void);
void r43make_with_buffer(T43* C,T0* a1);
void r43yy_execute_action(T43* C,T2 a1);
void r43set_start_condition(T43* C,T2 a1);
void r43yy_initialize(T43* C);
T2 r43yy_at_beginning_of_line(T43* C);
void r43parse_file(T43* C,T0* a1);
extern T0*oBC43yyr1_template;
extern int fBC43yyr1_template;
T0* r43yyr1_template(void);
void r43parse(T43* C);
T0* r43twin(T43* C);
void r43yy_do_action(T43* C,T2 a1);
void r43yy_load_input_buffer(T43* C);
extern T0*oBC43yytranslate_template;
extern int fBC43yytranslate_template;
T0* r43yytranslate_template(void);
T0* r43yy_fixed_array(T0* a1);
extern T0*oBC20INPUT_STREAM_;
T0* r43text(T43* C);
T2 r43text_count(T43* C);
T2 r43yy_previous_state(T43* C);
T6 r43wrap(T43* C);
T2 r43yy_translate(T43* C,T2 a1);
void r43report_error(T43* C,T0* a1);
extern T0*oBC43yyr2_template;
extern int fBC43yyr2_template;
T0* r43yyr2_template(void);
extern T0*oBC43yydefgoto_template;
extern int fBC43yydefgoto_template;
T0* r43yydefgoto_template(void);
T0* r43new_file_buffer(T0* a1);
T3 r43text_item(T43* C,T2 a1);
void r43clear_stacks(T43* C);
extern T0*oBC17Arguments;
extern int fBC17Arguments;
T0* r167Arguments(void);
void r167make(T167* C,T0* a1);
T0* r167message(T167* C,T0* a1);
T0* r167twin(T167* C);
T0* r167default_message(T167* C);
extern T0*oBC35STRING_;
T0* r149current_working_directory(T149* C);
T0* r149clone(T0* a1);
void r149old_read_character(T149* C);
extern T6 oBC98is_windows;
extern int fBC98is_windows;
T6 r149is_windows(T149* C);
T6 r149old_end_of_file(T149* C);
void r149make(T149* C);
extern T6 oBC98is_unix;
extern int fBC98is_unix;
T6 r149is_unix(T149* C);
T0* r149twin(T149* C);
void r83report_message(T83* C,T0* a1);
T0* r83message(T0* a1);
T0* r83twin(T83* C);
void r83make_standard(T83* C);
void r83report_error(T83* C,T0* a1);
extern T0*oBC29unix_file_system;
T6 r23is_closed(T23* C);
void r23old_close(T23* C);
extern T0*oBC29file_system;
extern int fBC29file_system;
T0* r23file_system(void);
void r23close(T23* C);
void r23make(T23* C,T0* a1);
extern T0*oBC30operating_system;
void r23old_put_string(T23* C,T0* a1);
void r23connect_to(T23* C,T0* a1);
void r23recursive_open_write(T23* C);
T0* r23twin(T23* C);
void r23open_write(T23* C);
extern T0*oBC29windows_file_system;
T0* r166Arguments(void);
void r166make(T166* C,T0* a1);
T0* r166message(T166* C,T0* a1);
T0* r166twin(T166* C);
T0* r166default_message(T166* C);
T0* r161dirname(T0* a1);
T0* r161string_to_pathname(T0* a1);
extern T0*oBC161root_directory;
T6 r161is_root_directory(T0* a1);
T0* r161pathname_to_string(T0* a1);
T0* r161twin(T161* C);
T0* r161canonical_pathname(T0* a1);
T0* r153Arguments(void);
void r153make(T153* C,T0* a1);
T0* r153message(T153* C,T0* a1);
T0* r153twin(T153* C);
T0* r153default_message(T153* C);
void r94disconnect(T94* C);
void r94read_character(T94* C);
T6 r94end_of_input(T94* C);
void r94connect_to(T94* C,T0* a1);
T0* r94twin(T94* C);
T6 r154is_closed(T154* C);
void r154open_read(T154* C);
T0* r154file_system(void);
void r154create_directory(T154* C);
T6 r154is_open_read(T154* C);
void r154close(T154* C);
T6 r154exists(T154* C);
void r154recursive_create_directory(T154* C);
T0* r154twin(T154* C);
T6 r154is_readable(T154* C);
void r80set_position(T80* C,T2 a1,T2 a2,T2 a3);
extern T2 oBC80lower;
extern int fBC80lower;
T2 r80lower(void);
void r80make(T80* C,T0* a1);
void r80make_from_buffer(T80* C,T0* a1);
T0* r80twin(T80* C);
T0* r146Arguments(void);
void r146make(T146* C,T2 a1);
T0* r146message(T146* C,T0* a1);
T0* r146twin(T146* C);
T0* r146default_message(T146* C);
T0* r147Arguments(void);
void r147make(T147* C,T0* a1);
T0* r147message(T147* C,T0* a1);
T0* r147twin(T147* C);
T0* r147default_message(T147* C);
void r79fill(T79* C);
void r79compact_left(T79* C);
T2 r79count(T79* C);
void r79set_position(T79* C,T2 a1,T2 a2,T2 a3);
T2 r79lower(void);
void r79make_from_string(T79* C,T0* a1);
void r79make_from_buffer(T79* C,T0* a1);
void r79resize(T79* C);
void r79make_with_size(T79* C,T0* a1,T2 a2);
T0* r79twin(T79* C);
void r79set_file(T79* C,T0* a1);
void r79flush(T79* C);
T0* r164current_working_directory(T164* C);
T0* r164clone(T0* a1);
T6 r164is_windows(T164* C);
void r164make(T164* C);
void r164old_put_string(T0* a1);
T6 r164is_unix(T164* C);
T0* r164twin(T164* C);
T0* r96current_working_directory(T96* C);
T0* r96clone(T0* a1);
T6 r96is_windows(T96* C);
void r96make(T96* C);
void r96old_put_string(T0* a1);
T6 r96is_unix(T96* C);
T0* r96twin(T96* C);
T0* r162dirname(T0* a1);
T0* r162string_to_pathname(T0* a1);
extern T0*oBC162root_directory;
T6 r162is_root_directory(T0* a1);
T0* r162pathname_to_string(T0* a1);
T0* r162twin(T162* C);
T0* r162canonical_pathname(T0* a1);
void r174copy(T174* C,T0* a1);
void r174append_name(T174* C,T0* a1);
T0* r174clone(T0* a1);
T6 r174is_parent(T174* C,T2 a1);
void r174make(T174* C);
void r174set_canonical(T174* C);
T0* r174twin(T174* C);
T6 r174is_current(T174* C,T2 a1);
T0* r81Arguments(void);
void r81make(T81* C,T0* a1,T2 a2);
T0* r81message(T81* C,T0* a1);
T0* r81twin(T81* C);
T0* r81default_message(T81* C);
extern T0*oBC1command_arguments;
extern int fBC1command_arguments;
T0* r88command_arguments(void);
T0* r88twin(T88* C);
T0* r88argument(T2 a1);
extern T0*oBC95error;
extern int fBC95error;
T0* r95error(void);
extern T0*oBC95input;
extern int fBC95input;
T0* r95input(void);
extern T0*oBC95output;
extern int fBC95output;
T0* r95output(void);
T0* r95twin(T95* C);
T0* r63twin(T63* C);
T0* r60twin(T60* C);
T0* r41twin(T41* C);
T0* r176twin(T176* C);
void r16preprocess(T16* C);
void r16read_arguments(T16* C);
extern T0*oBC18Exceptions;
void r16report_cannot_read_error(T16* C,T0* a1);
T0* r16Arguments(void);
void r16execute(T16* C);
void r16report_version_number(T16* C);
void r16report_cannot_write_error(T16* C,T0* a1);
T0* r16twin(T16* C);
extern T0*oBC16Usage_message;
extern int fBC16Usage_message;
T0* r16Usage_message(void);
T0* r40twin(T40* C);
T0* r92name(T0* a1);
T0* r92make_file_open_read(T0* a1);
T6 r92is_open_read(T0* a1);
void r92close(T0* a1);
T6 r92end_of_input(T0* a1);
T2 r92read_stream(T0* a1,T0* a2,T2 a3,T2 a4);
T0* r92twin(T92* C);
void r156connect_to_current_working_directory(T156* C);
void r156disconnect(T156* C);
extern T0*oBC156last_entry;
void r156connect_to(T156* C,T0* a1);
T6 r156create_new_directory(T0* a1);
T6 r84is_integer(T0* a1);
T0* r84make(T2 a1);
T0* r84twin(T84* C);
T0* r148variable_value(T0* a1);
T0* r148get_environment_variable(T0* a1);
T0* r148interpreted_string(T0* a1);
T0* r148twin(T148* C);
T0* r65twin(T65* C);
T0* r112substring(T0* a1,T2 a2,T2 a3);
void r112move_left(T0* a1,T2 a2,T2 a3,T2 a4);
T0* r112make(T2 a1);
void r112copy_from_string(T0* a1,T2 a2,T0* a3);
T0* r112resize(T0* a1,T2 a2);
T2 r112copy_from_stream(T0* a1,T2 a2,T0* a3,T2 a4);
T0* r112twin(T112* C);
T0* r98current_working_directory(T98* C);
T0* r98clone(T0* a1);
T6 r98is_windows(T98* C);
T6 r98is_unix(T98* C);
T0* r98twin(T98* C);
extern T16*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 177
void initialize_eiffel_runtime(int argc,char*argv[]);
extern T7*ms149_89510;
extern T7*ms16_16072;
extern T7*ms92_1338085634;
extern T7*ms43_10;
extern T7*ms81_1449702436;
extern T7*ms43_449403;
extern T7*ms16_311;
extern T7*ms16_329;
extern T7*ms16_288;
extern T7*ms16_45a;
extern T7*ms164_447851;
extern T7*ms153_1606053737;
extern T7*ms16_0;
extern T7*ms161_46;
extern T7*ms161_92;
extern T7*ms162_46;
extern T7*ms162_47;
extern T7*ms43_0;
extern T7*ms57_1338477769;
extern T7*ms164_10;
extern T7*ms55_0;
extern T7*ms16_184927;
extern T7*ms45_1173251759;
extern T7*ms147_988446515;
extern T7*ms92_0;
extern T7*ms174_46;
extern T7*ms16_45aaa;
extern T7*ms167_1158552108;
extern T7*ms21_1529;
extern T7*ms96_10;
extern T7*ms146_434195944;
extern T7*ms174_276;
extern T7*ms96_447584;
extern T7*ms16_45aa;
extern T7*ms43_6359;
extern T7*ms50_195717202;
extern T7*ms16_45;
extern T7*ms161_276;
extern T7*ms23_10;
extern T7*ms57_1338477769a;
extern T7*ms166_1515383187;
extern T7*ms16_78124153;
extern T7*ms162_276;
extern T7*ms16_23342040;
extern T7*ms16_927745;
T7*se_ms(int c,char*e);
T7*se_string(char*e);
void se_msi1(void);
void*se_ma172(int argc,...);
void X26put_character(T0*C,T3 a1);
void X26put_string(T0*C,T0* a1);
T0* X10twin(T0*C);
void X69clear_all(T0*C,T0* a1);
T0* X69make(T0*C,T2 a1);
T0* X69resize(T0*C,T0* a1,T2 a2);
void X38put_new_line(T0*C);
void X38put_string(T0*C,T0* a1);
void X80fill(T0*C);
T2 X171count(T0*C);
T2 X171item(T0*C,T2 a1);
T2 X171lower(T0*C);
void X74put(T0*C,T0* a1,T2 a2);
T0* X74item(T0*C,T2 a1);
void X74set_all_with(T0*C,T0* a1);
void X74resize(T0*C,T2 a1);
T6 X39is_connected(T0*C);
void X39read_character(T0*C);
T6 X39end_of_input(T0*C);
T3 X39last_character(T0*C);
T0* X82default_message(T0*C);
T6 X98is_windows(T0*C);
T6 X98is_unix(T0*C);
T0* X159dirname(T0*C,T0* a1);
T0* X159canonical_pathname(T0*C,T0* a1);
T0* T2toT60(T2 source);
T2 T60toT2(T0* source);
T0* T6toT40(T6 source);

#ifdef __cplusplus
}
#endif
