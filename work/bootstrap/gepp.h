#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmartEiffel The GNU Eiffel Compiler, Eiffel tools and libraries
Release 1.0 (Friday December 6th 2002)
Copyright (C), 1994-2002 - LORIA - UHP - INRIA - FRANCE
Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
http://SmartEiffel.loria.fr
C Compiler options used: 
*/

/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  include <unistd.h>
#endif
#if !defined(WIN32) && \
       (defined(WINVER) || defined(_WIN32_WINNT) || defined(_WIN32) || \
	defined(__WIN32__) || defined(__TOS_WIN__) || defined(_MSC_VER))
#  define WIN32 1
#endif
#ifdef WIN32
#  include <windows.h>
#else
#  ifndef O_RDONLY
#    include <sys/file.h>
#  endif
#  ifndef O_RDONLY
#    define O_RDONLY 0000
#  endif
#endif

#if defined(_MSC_VER) /* MSVC */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed __int64 int64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "I64d"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c
#  define INT64_C(c) c ## i64
#elif defined(__WATCOMC__) && (__WATCOMC__ <= 1100) /* WATCOM 11 or lower */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "d"
#  define PRId64 "Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__BORLANDC__) && (__BORLANDC__ < 0x600) /* Borland before 6.0 */
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed __int64 int64_t;
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "Ld"
#  define PRId64 "I64Ld"
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## i64
#elif defined(__FreeBSD__) && (__FreeBSD__ < 5) /* FreeBSD before 5.0 */ && !defined (_SYS_INTTYPES_H_)
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed long int int32_t;
typedef signed long long int int64_t;
#elif defined(__CYGWIN__) && defined(__BIT_TYPES_DEFINED__) /* Cygwin defines intxx_t in sys/types.h instead of inttypes.h */
#else
#  include <inttypes.h>
#  if !defined(INT8_MAX) && defined(INT16_MAX)
/* int8_t is not mandatory */
typedef int_least8_t int8_t;
#  endif
#endif

#if !defined(PRId16)
#  define PRId8 "d"
#  define PRId16 "d"
#  define PRId32 "ld"
#  define PRId64 "lld"
#elif !defined(PRId8)
#  define PRId8 "d"
#endif
#if !defined(INT16_C)
#  define INT8_C(c) c
#  define INT16_C(c) c
#  define INT32_C(c) c ## L
#  define INT64_C(c) c ## LL
#elif !defined(INT8_C)
#  define INT8_C(c) c
#endif
#if !defined(INT16_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#  define INT8_MAX (INT8_C(127))
#  define INT16_MIN (-INT16_C(32767)-1)
#  define INT16_MAX (INT16_C(32767))
#  define INT32_MIN (-INT32_C(2147483647)-1)
#  define INT32_MAX (INT32_C(2147483647))
#  define INT64_MIN (-INT64_C(9223372036854775807)-1)
#  define INT64_MAX (INT64_C(9223372036854775807))
#elif !defined(INT8_MIN)
#  define INT8_MIN (-INT8_C(127)-1)
#endif

/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#  define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#  define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.
*/
#ifdef _SIGSET_H_types
#  define JMP_BUF    sigjmp_buf
#  define SETJMP(x)  sigsetjmp( (x), 1)
#  define LONGJMP    siglongjmp
#else
#  define JMP_BUF    jmp_buf
#  define SETJMP(x)  setjmp( (x) )
#  define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER_8 is #1:
*/
typedef int8_t T1;
#define EIF_INTEGER_8 T1
#define M1 (INT8_C(0))
#define EIF_INTEGER_8_BITS (CHAR_BIT)
#define EIF_MINIMUM_INTEGER_8 (INT8_MIN)
#define EIF_MAXIMUM_INTEGER_8 (INT8_MAX)

/*
  Eiffel type INTEGER_16 is #10:
*/
typedef int16_t T10;
#define EIF_INTEGER_16 T10
#define M10 (INT16_C(0))
#define EIF_INTEGER_16_BITS (CHAR_BIT*sizeof(T10t))
#define EIF_MINIMUM_INTEGER_16 (INT16_MIN) /*-32768*/
#define EIF_MAXIMUM_INTEGER_16 (INT16_MAX) /*+32767*/

/*
  Eiffel type INTEGER or INTEGER_32 is #2:
*/
typedef int32_t T2;
#define EIF_INTEGER T2
#define EIF_INTEGER_32 T2
#define M2 (INT32_C(0))
#define EIF_INTEGER_BITS ((T2)(CHAR_BIT*sizeof(T2)))
#define EIF_INTEGER_32_BITS EIF_INTEGER_BITS
#define EIF_MINIMUM_INTEGER (INT32_MIN)
#define EIF_MAXIMUM_INTEGER (INT32_MAX)

/*
  Eiffel type INTEGER_64 is #11:
*/
typedef int64_t T11;
#define EIF_INTEGER_64 T11
#define M11 (INT64_C(0))
#define EIF_INTEGER_64_BITS (CHAR_BIT*sizeof(T11))
#define EIF_MINIMUM_INTEGER_64 (INT64_MIN)
#define EIF_MAXIMUM_INTEGER_64 (INT64_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T2)(x))
#define T3to_integer(x) ((T2)((signed char)(x)))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL is #4:
*/
typedef float T4;
#define EIF_REAL T4
#define M4 (0.0)
#define EIF_REAL_BITS (CHAR_BIT*sizeof(float))
#define EIF_MINIMUM_REAL (-(FLT_MAX))
#define EIF_MAXIMUM_REAL (FLT_MAX)

/*
  Eiffel type DOUBLE is #5:
*/
typedef double T5;
#define EIF_DOUBLE T5
#define M5 (0.0)
#define EIF_DOUBLE_BITS (CHAR_BIT*sizeof(double))
#define EIF_MINIMUM_DOUBLE (-(DBL_MAX))
#define EIF_MAXIMUM_DOUBLE (DBL_MAX)

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
#define M8 (NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);
#define SE_BOOST 1
#define SE_EXCEPTIONS 1

/*C Header Pass 1 :*/
typedef struct S56 T56;
typedef struct S83 T83;
typedef void*T92;
typedef struct S39 T39;
typedef struct S87 T87;
typedef struct S200 T200;
typedef void*T126;
typedef struct S203 T203;
typedef void*T157;
typedef void*T208;
typedef void*T69;
typedef struct S95 T95;
typedef struct S175 T175;
typedef struct S186 T186;
typedef struct S98 T98;
typedef struct S180 T180;
typedef void*T185;
typedef void*T112;
typedef struct S21 T21;
typedef void*T116;
typedef void*T111;
typedef struct S199 T199;
typedef struct S194 T194;
typedef struct S12 T12;
typedef struct S139 T139;
typedef struct S188 T188;
typedef struct S80 T80;
typedef int T184;
typedef struct S7 T7;
typedef struct S189 T189;
typedef struct S191 T191;
typedef void*T100;
typedef struct S178 T178;
typedef struct S79 T79;
typedef struct S179 T179;
typedef struct S76 T76;
typedef struct S103 T103;
typedef struct S153 T153;
typedef struct S183 T183;
typedef struct S94 T94;
typedef struct S197 T197;
typedef struct S127 T127;
typedef struct S195 T195;
typedef struct S118 T118;
typedef void*T201;
typedef void*T143;
typedef struct S129 T129;
typedef struct S138 T138;
typedef void*T93;
typedef struct S206 T206;
typedef struct S198 T198;
typedef struct S96 T96;
typedef struct S119 T119;

/*C Header Pass 2 :*/
typedef T0**T142;
typedef T6*T78;
typedef T0**T82;
typedef T3*T9;
typedef T2*T90;
typedef T0**T86;

/*C Header Pass 3 :*/
struct S191{T8 _directory_stream;T8 _current_entry;};
int se_cmpT191(T191 o1,T191 o2);

/*C Header Pass 4 :*/
struct S56{T2 _yy_start_state;T2 _yy_column;T0* _yytable;T0* _yycheck;T0* _yytypes1;T0* _yytypes2;T6 _yy_lookahead_needed;T2 _yyerrstatus;T2 _column;T0* _yy_content;T2 _yy_last_accepting_state;T2 _yy_last_accepting_cpos;T0* _yydefgoto;T0* _yy_content_area;T2 _yy_start;T0* _yydefact;T2 _yy_more_len;T0* _yyss;T2 _yyssp;T2 _position;T0* _yyr1;T0* _yypact;T0* _yypgoto;T0* _input_buffer;T2 _yy_end;T2 _yy_position;T2 _error_count;T2 _last_token;T2 _line;T0* _yytranslate;T2 _yy_line;T6 _yy_more_flag;T2 _yy_parsing_status;T0* _yy_nxt;T0* _yy_chk;T0* _yy_def;T0* _yy_ec;T0* _yy_accept;T0* _yy_acclist;T2 _yy_state_count;T2 _yy_looking_for_trail_begin;T0* _last_string_value;T0* _yy_base;T6 _yy_rejected;T2 _yy_full_state;T0* _last_any_value;T0* _yy_meta;T0* _yy_state_stack;T2 _yy_full_match;T2 _yy_lp;T2 _yy_full_lp;T2 _line_nb;T6 _empty_lines;T0* _output_file;T0* _yyvs1;T2 _yyvsc1;T2 _yyvsp1;T0* _yyspecial_routines1;T0* _yyvs2;T2 _yyvsc2;T2 _yyvsp2;T0* _yyspecial_routines2;T0* _yyvs3;T2 _yyvsc3;T2 _yyvsp3;T0* _yyspecial_routines3;T0* _error_handler;T6 _makefile_dependencies;T0* _defined_values;T2 _if_level;T2 _ignored_level;T0* _include_stack;};
extern T56 M56;
struct S83{T86 _storage;T2 _capacity;T2 _upper;};
extern T83 M83;
struct S39{Tid id;T0* _name;T0* _string_name;T3 _last_character;T6 _end_of_file;T0* _character_buffer;T0* _path;T3 _old_last_character;T6 _old_end_of_file;T6 _push_back_flag;T8 _input_stream;T9 _buffer;T6 _end_reached;T2 _buffer_position;T2 _buffer_size;T2 _capacity;};
extern T39 M39;
struct S87{T90 _storage;T2 _capacity;T2 _upper;};
extern T87 M87;
struct S200{Tid id;T0* _parameters;};
extern T200 M200;
extern T126 M126;
struct S203{T90 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T203 M203;
extern T208 M208;
extern T69 M69;
struct S175{T2 _position;T0* _container;T0* _next_cursor;};
extern T175 M175;
struct S186{Tid id;T6 _push_back_flag;T3 _old_last_character;T6 _old_end_of_file;T9 _buffer;T6 _end_reached;T2 _buffer_position;T2 _buffer_size;T2 _capacity;T0* _name;T3 _last_character;T6 _end_of_file;T0* _character_buffer;};
extern T186 M186;
struct S98{T0* _error_file;T0* _warning_file;T0* _info_file;};
extern T98 M98;
struct S180{T2 _count;T9 _area;T0* _area_string;};
extern T180 M180;
extern T112 M112;
struct S21{Tid id;T0* _name;T0* _string_name;T0* _path;T9 _buffer;T2 _buffer_position;T2 _capacity;T8 _output_stream;};
extern T21 M21;
extern T116 M116;
extern T111 M111;
struct S199{Tid id;T0* _parameters;};
extern T199 M199;
struct S194{Tid id;};
extern T194 M194;
struct S12{T0* _in_filename;T0* _out_filename;T0* _parser;T0* _error_handler;};
extern T12 M12;
struct S139{T142 _storage;T2 _capacity;T2 _upper;};
extern T139 M139;
struct S188{Tid id;T0* _parameters;};
extern T188 M188;
struct S80{T82 _storage;T2 _capacity;T2 _upper;};
extern T80 M80;
extern T184 M184;
struct S189{T0* _name;T0* _last_entry;T6 _end_of_input;T0* _string_name;T0* _entry_buffer;T191 _basic_directory;};
extern T189 M189;
struct S7{Tid id;T9 _storage;T2 _count;T2 _capacity;};
extern T7 M7;
struct S95{Tid id;T0* _content;T2 _count;T2 _capacity;T2 _position;T2 _column;T2 _line;T2 _index;T6 _beginning_of_line;T6 _filled;};
extern T95 M95;
extern T191 M191;
extern T100 M100;
struct S178{Tid id;T0* _parameters;};
extern T178 M178;
struct S79{T82 _storage;T2 _capacity;T2 _upper;};
extern T79 M79;
struct S179{Tid id;T0* _parameters;};
extern T179 M179;
struct S76{T78 _storage;T2 _capacity;T2 _upper;};
extern T76 M76;
struct S103{Tid id;T9 _storage;T2 _count;T2 _capacity;T2 _byte_count;T2 _last_byte_index_input;T2 _last_byte_index_result;};
extern T103 M103;
struct S153{T0* _equality_tester;T2 _count;T2 _capacity;T2 _last_position;T2 _modulus;T2 _free_slot;T2 _position;T2 _slots_position;T2 _clashes_previous_position;T2 _found_position;T0* _internal_cursor;T0* _key_equality_tester;T0* _items;T0* _keys;T0* _clashes;T0* _slots;T0* _special_item_routines;T0* _special_key_routines;};
extern T153 M153;
struct S183{int _environment_impl;};
extern T183 M183;
struct S94{Tid id;T0* _content;T2 _count;T2 _capacity;T2 _position;T2 _column;T2 _line;T2 _index;T6 _beginning_of_line;T6 _filled;T6 _interactive;T0* _file;T6 _end_of_file;};
extern T94 M94;
struct S197{Tid id;T2 _buffer_position;T9 _buffer;T2 _capacity;T0* _name;};
extern T197 M197;
struct S127{Tid id;T0* _name;};
extern T127 M127;
struct S195{Tid id;};
extern T195 M195;
struct S118{T82 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T118 M118;
struct S129{T191 _basic_directory;int _environment_impl;};
extern T129 M129;
struct S138{T2 _count;T2 _capacity;T0* _storage;T0* _special_;};
extern T138 M138;
struct S206{T6 _is_relative;T0* _drive;T0* _hostname;T2 _count;T0* _components;};
extern T206 M206;
struct S198{T2 _buffer_position;T9 _buffer;T2 _capacity;};
extern T198 M198;
struct S96{Tid id;T0* _parameters;};
extern T96 M96;
struct S119{T0* _program_name;};
extern T119 M119;
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/

/*
  This file (SmartEiffel/sys/runtime/boost.h) is automatically included when
  `run_control.boost' is true (ie. only for mode -boost).
*/
#define SE_BOOST 1
void se_print_run_time_stack (void);
void se_signal_handler(int sig);
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/exception.h) is automatically included
  when exception handling is used somewhere in the live code.
*/

#define SE_EXCEPTIONS 1

/*
  Constants from Eiffel class EXCEPTIONS :
*/
#define Check_instruction 	  1
#define Class_invariant 	  2
#define Developer_exception 	  3
#define Incorrect_inspect_value   4
#define Loop_invariant 		  5
#define Loop_variant 		  6
#define No_more_memory  	  7
#define Postcondition 		  8
#define Precondition  		  9
#define Routine_failure  	  10
#define	Os_signal		  11
#define Void_attached_to_expanded 12
#define Void_call_target 	  13
#define System_level_type_error	  14

/*
   This will be the structure of rescue contexts.  A rescue context
   will be declared for every routine that has a rescue clause.

   The `next' pointer is the address of the next rescue context if there
   is one higher up the call chain, or NULL if there is no other
   context.
*/
struct rescue_context {
  JMP_BUF jb;
#ifndef SE_BOOST
    /* To keep track of dump stack to unwind it safely
       before the LONGJMP :
    */
    struct _se_dump_stack * top_of_ds ;
#endif
  struct rescue_context *next;
};

extern struct rescue_context *rescue_context_top;
extern int internal_exception_number;
extern int original_internal_exception_number;
extern int signal_exception_number;
extern char *additional_error_message;

void setup_signal_handler(void);
void signal_exception_handler(int);
void internal_exception_handler(int);
void print_exception(void);
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/basic_directory.h) is automatically
  included when some external "SmartEiffel" feature of class BASIC_DIRECTORY
  is live.
*/
#ifndef WIN32
#  include <dirent.h>
#endif
#ifndef WIN32
#  include <unistd.h>
#endif

EIF_POINTER basic_directory_open(EIF_POINTER path);
EIF_POINTER basic_directory_read_entry(EIF_POINTER dirstream);
EIF_POINTER basic_directory_get_entry_name(EIF_POINTER entry);
EIF_BOOLEAN basic_directory_close(EIF_POINTER dirstream);
#define basic_directory_current_working_directory (basic_directory_cwd())
EIF_POINTER basic_directory_cwd(void);
EIF_BOOLEAN basic_directory_chdir(EIF_POINTER destination);
EIF_BOOLEAN basic_directory_mkdir(EIF_POINTER directory_path);
EIF_BOOLEAN basic_directory_rmdir(EIF_POINTER directory_path);
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/basic_io.h) is automatically
  included when some external "SmartEiffel" basic_io_* feature is used.
*/

#define basic_io_stdin (stdin)
#define basic_io_stdout (stdout)
#define basic_io_stderr (stderr)
#define basic_io_eof (EOF)
#define basic_io_text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define basic_io_text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define basic_io_text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define basic_io_text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define basic_io_text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define basic_io_binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define basic_io_binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define basic_io_binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define basic_io_fclose(p) (fclose((FILE*)(p)))
#define basic_io_flush(p) (fflush((FILE*)(p)))
#define basic_io_getc(f) (getc(((FILE*)(f))))
#define basic_io_putc(b, f) (putc((b),((FILE*)(f))))
#define basic_io_fread(b, n, f) (fread((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define basic_io_fwrite(b, n, f) (fwrite((void *)(b),(size_t)(1), (size_t)(n),(FILE*)(f)))
#define basic_io_feof(f) (feof(((FILE*)(f))))
#define basic_io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define basic_io_remove(f) (remove(((char*)(f))))

#if defined __USE_POSIX || defined __unix__ || defined _POSIX_C_SOURCE
#  define basic_io_read_stdin(b, s) (read(STDIN_FILENO, b, s))
#else
  extern int basic_io_read_stdin(char *buffer, int size);
#endif

/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/basic_getenv.h) is automatically
  included when the GENERAL.basic_getenv feature is used (ie. in live code).
*/

#define basic_getenv(v) (getenv((char*)v))
/*POINTER*/
T6 r8is_null(T8 C);
/*BOOLEAN*/
T6 r6_ix_and(T6 C,T6 a1);
/*BOOLEAN*/
T6 r6_px_not(T6 C);
/*BOOLEAN*/
T6 r6_ix_or(T6 C,T6 a1);
/*CHARACTER*/
T6 r3is_digit(T3 C);
/*CHARACTER*/
T6 r3is_separator(T3 C);
/*CHARACTER*/
T6 r3_ix_6061(T3 C,T3 a1);
/*CHARACTER*/
T1 r3value(T3 C);
/*CHARACTER*/
T1 r3decimal_value(T3 C);
/*CHARACTER*/
T6 r3_ix_6261(T3 C,T3 a1);
/*CHARACTER*/
T6 r3_ix_60(T3 C,T3 a1);
/*CHARACTER*/
T6 r3_ix_62(T3 C,T3 a1);
/*INTEGER*/
T0* r2out(T2 C);
/*INTEGER*/
T2 r2max(T2 C,T2 a1);
/*INTEGER*/
T2 r2min(T2 C,T2 a1);
/*INTEGER*/
void r2append_in(T2 C,T0* a1);
extern T0*oBC20tagged_out_memory;
/*INTEGER_64*/
T3 r11digit(T11 C);
/*NATIVE_ARRAY[YY_BUFFER]*/
void r142clear(T142 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[BOOLEAN]*/
T78 r78realloc(T78 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[BOOLEAN]*/
void r78set_all_with(T78 C,T6 a1,T2 a2);
/*NATIVE_ARRAY[BOOLEAN]*/
void r78clear(T78 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[BOOLEAN]*/
void r78copy_from(T78 C,T78 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/
T82 r82realloc(T82 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/
void r82move(T82 C,T2 a1,T2 a2,T2 a3);
/*NATIVE_ARRAY[STRING]*/
void r82set_all_with(T82 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/
void r82clear(T82 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[STRING]*/
void r82copy_from(T82 C,T82 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/
void r9copy_slice(T9 C,T2 a1,T9 a2,T2 a3,T2 a4);
/*NATIVE_ARRAY[CHARACTER]*/
T9 r9realloc(T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/
void r9set_all_with(T9 C,T3 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/
T6 r9fast_memcmp(T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/
void r9copy_at(T9 C,T2 a1,T9 a2,T2 a3);
/*NATIVE_ARRAY[CHARACTER]*/
void r9clear(T9 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[CHARACTER]*/
void r9copy_from(T9 C,T9 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER]*/
T90 r90realloc(T90 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER]*/
void r90clear(T90 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[INTEGER]*/
void r90copy_from(T90 C,T90 a1,T2 a2);
/*NATIVE_ARRAY[ANY]*/
T86 r86realloc(T86 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[ANY]*/
void r86set_all_with(T86 C,T0* a1,T2 a2);
/*NATIVE_ARRAY[ANY]*/
void r86clear(T86 C,T2 a1,T2 a2);
/*NATIVE_ARRAY[ANY]*/
void r86copy_from(T86 C,T86 a1,T2 a2);
/*STRING*/
void r7copy(T7* C,T0* a1);
/*STRING*/
T0* r7substring(T7* C,T2 a1,T2 a2);
/*STRING*/
T2 r7item_code(T7* C,T2 a1);
/*STRING*/
T6 r7is_equal(T7* C,T0* a1);
/*STRING*/
T3 r7item(T7* C,T2 a1);
/*STRING*/
T6 r7valid_index(T7* C,T2 a1);
/*STRING*/
void r7append(T7* C,T0* a1);
/*STRING*/
T6 r7se_assigned_from(T0* a1);
/*STRING*/
void r7make_from_string(T7* C,T0* a1);
/*STRING*/
T6 r7same_type(T7* C,T0* a1);
/*STRING*/
void r7remove_tail(T7* C,T2 a1);
/*STRING*/
void r7make(T7* C,T2 a1);
/*STRING*/
void r7append_string(T7* C,T0* a1);
/*STRING*/
void r7make_filled(T7* C,T3 a1,T2 a2);
/*STRING*/
T0* r7string(T7* C);
/*STRING*/
void r7extend(T7* C,T3 a1);
/*STRING*/
T2 r7hash_code(T7* C);
/*STRING*/
T6 r7conforms_to(T7* C,T0* a1);
/*STRING*/
T2 r7to_integer(T7* C);
/*STRING*/
void r7append_character(T7* C,T3 a1);
/*STRING*/
void r7resize(T7* C,T2 a1);
/*STRING*/
void r7from_external_copy(T7* C,T8 a1);
/*STRING*/
T8 r7to_external(T7* C);
/*STRING*/
T6 r7same_string(T7* C,T0* a1);
/*STRING*/
T0* r7twin(T7* C);
/*STRING*/
T0* r7_ix_43(T7* C,T0* a1);
/*STRING*/
void r7swap(T7* C,T2 a1,T2 a2);
/*ARRAY[INTEGER]*/
T2 r203count(T203* C);
/*ARRAY[INTEGER]*/
T2 r203item(T203* C,T2 a1);
/*FIXED_ARRAY[STRING]*/
T6 r80valid_index(T80* C,T2 a1);
/*FIXED_ARRAY[STRING]*/
void r80make(T80* C,T2 a1);
/*ARRAY[STRING]*/
void r118force(T118* C,T0* a1,T2 a2);
/*ARRAY[STRING]*/
T2 r118count(T118* C);
/*ARRAY[STRING]*/
T0* r118item(T118* C,T2 a1);
/*ARRAY[STRING]*/
T6 r118valid_index(T118* C,T2 a1);
/*ARRAY[STRING]*/
void r118make(T118* C,T2 a1,T2 a2);
/*ARRAY[STRING]*/
void r118add_last(T118* C,T0* a1);
/*ARRAY[STRING]*/
void r118resize(T118* C,T2 a1,T2 a2);
/*SPECIAL[ANY]*/
T6 r83valid_index(T83* C,T2 a1);
/*SPECIAL[ANY]*/
void r83make(T83* C,T2 a1);
/*SPECIAL[ANY]*/
T0* r83resize(T83* C,T2 a1);
/*SPECIAL[ANY]*/
void r83array_resize(T83* C,T2 a1);
/*KL_SPECIAL_ROUTINES[ANY]*/
T0* r92make(T2 a1);
/*KL_SPECIAL_ROUTINES[ANY]*/
T0* r92resize(T0* a1,T2 a2);
/*SPECIAL[INTEGER]*/
T6 r87valid_index(T87* C,T2 a1);
/*SPECIAL[INTEGER]*/
void r87make(T87* C,T2 a1);
/*SPECIAL[INTEGER]*/
T0* r87resize(T87* C,T2 a1);
/*SPECIAL[INTEGER]*/
void r87array_resize(T87* C,T2 a1);
/*SPECIAL[INTEGER]*/
void r87with_capacity(T87* C,T2 a1);
/*SPECIAL[INTEGER]*/
void r87from_collection(T87* C,T0* a1);
/*KL_EQUALITY_TESTER[STRING]*/
T6 r157test(T0* a1,T0* a2);
/*DS_HASH_TABLE_CURSOR[STRING,STRING]*/
T6 r175valid_position(T175* C,T2 a1);
/*DS_HASH_TABLE_CURSOR[STRING,STRING]*/
void r175make(T175* C,T0* a1);
/*KL_SPECIAL_ROUTINES[BOOLEAN]*/
T0* r185make(T2 a1);
/*KL_SPECIAL_ROUTINES[BOOLEAN]*/
T0* r185resize(T0* a1,T2 a2);
/*SPECIAL[YY_BUFFER]*/
T6 r139valid_index(T139* C,T2 a1);
/*SPECIAL[YY_BUFFER]*/
void r139make(T139* C,T2 a1);
/*SPECIAL[STRING]*/
T6 r79valid_index(T79* C,T2 a1);
/*SPECIAL[STRING]*/
void r79make(T79* C,T2 a1);
/*SPECIAL[STRING]*/
T0* r79resize(T79* C,T2 a1);
/*SPECIAL[STRING]*/
void r79array_resize(T79* C,T2 a1);
/*SPECIAL[BOOLEAN]*/
T6 r76valid_index(T76* C,T2 a1);
/*SPECIAL[BOOLEAN]*/
void r76make(T76* C,T2 a1);
/*SPECIAL[BOOLEAN]*/
T0* r76resize(T76* C,T2 a1);
/*SPECIAL[BOOLEAN]*/
void r76array_resize(T76* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
T2 r153new_capacity(T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153force(T153* C,T0* a1,T0* a2);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153make_clashes(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
T6 r153valid_slot(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
T6 r153valid_position(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153search_position(T153* C,T0* a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153keys_resize(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153make_items(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153remove_position(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153make(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153remove(T153* C,T0* a1);
extern T0*oBC65special_integer_;
/*DS_HASH_TABLE[STRING,STRING]*/
T6 r153has(T153* C,T0* a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153make_keys(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
T2 r153hash_position(T153* C,T0* a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153items_resize(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153make_with_equality_testers(T153* C,T2 a1,T0* a2,T0* a3);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153move_cursors_after(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153resize(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153make_sparse_container(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153move_cursors_forth(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153clashes_resize(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153slots_resize(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
T0* r153new_cursor(T153* C);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153make_slots(T153* C,T2 a1);
/*DS_HASH_TABLE[STRING,STRING]*/
void r153move_all_cursors(T153* C,T2 a1,T2 a2);
/*DS_HASH_TABLE[STRING,STRING]*/
T2 r153new_modulus(T2 a1);
/*KL_SPECIAL_ROUTINES[YY_BUFFER]*/
T0* r201make(T2 a1);
/*KL_SPECIAL_ROUTINES[INTEGER]*/
T0* r143make(T2 a1);
/*KL_SPECIAL_ROUTINES[INTEGER]*/
T0* r143make_from_array(T0* a1);
/*KL_SPECIAL_ROUTINES[INTEGER]*/
T0* r143resize(T0* a1,T2 a2);
/*KL_SPECIAL_ROUTINES[INTEGER]*/
T0* r143to_special(T0* a1);
/*DS_ARRAYED_STACK[YY_BUFFER]*/
T6 r138extendible(T138* C,T2 a1);
/*DS_ARRAYED_STACK[YY_BUFFER]*/
void r138put(T138* C,T0* a1);
/*DS_ARRAYED_STACK[YY_BUFFER]*/
T0* r138item(T138* C);
/*DS_ARRAYED_STACK[YY_BUFFER]*/
void r138make(T138* C,T2 a1);
/*DS_ARRAYED_STACK[YY_BUFFER]*/
void r138remove(T138* C);
/*DS_ARRAYED_STACK[YY_BUFFER]*/
T6 r138is_full(T138* C);
/*KL_SPECIAL_ROUTINES[STRING]*/
T0* r93make(T2 a1);
/*KL_SPECIAL_ROUTINES[STRING]*/
T0* r93resize(T0* a1,T2 a2);
/*GEPP_PARSER*/
void r56yy_do_action(T56* C,T2 a1);
extern T0*oBC56yytable_template;
extern int fBC56yytable_template;
/*GEPP_PARSER*/
T0* r56yytable_template(void);
/*GEPP_PARSER*/
void r56make_parser_skeleton(T56* C);
/*GEPP_PARSER*/
T6 r56wrap(T56* C);
/*GEPP_PARSER*/
void r56make_gepp_scanner(T56* C);
/*GEPP_PARSER*/
void r56fatal_error(T0* a1);
extern T0*oBC15std;
/*GEPP_PARSER*/
void r56yy_do_error_action(T56* C,T2 a1);
/*GEPP_PARSER*/
void r56parse_file(T56* C,T0* a1);
/*GEPP_PARSER*/
void r56parse(T56* C);
/*GEPP_PARSER*/
void r56set_input_buffer(T56* C,T0* a1);
extern T0*oBC58yy_ec_template;
extern int fBC58yy_ec_template;
/*GEPP_PARSER*/
T0* r56yy_ec_template(void);
/*GEPP_PARSER*/
T0* r56text_substring(T56* C,T2 a1,T2 a2);
/*GEPP_PARSER*/
void r56yy_execute_action(T56* C,T2 a1);
extern T0*oBC56yytranslate_template;
extern int fBC56yytranslate_template;
/*GEPP_PARSER*/
T0* r56yytranslate_template(void);
extern T0*oBC58yy_def_template;
extern int fBC58yy_def_template;
/*GEPP_PARSER*/
T0* r56yy_def_template(void);
/*GEPP_PARSER*/
T3 r56text_item(T56* C,T2 a1);
/*GEPP_PARSER*/
void r56yy_push_last_value(T56* C,T2 a1);
/*GEPP_PARSER*/
void r56yy_load_input_buffer(T56* C);
/*GEPP_PARSER*/
void r56yy_push_error_value(T56* C);
/*GEPP_PARSER*/
T6 r56syntax_error(T56* C);
extern T0*oBC56yyr1_template;
extern int fBC56yyr1_template;
/*GEPP_PARSER*/
T0* r56yyr1_template(void);
/*GEPP_PARSER*/
void r56make_with_buffer(T56* C,T0* a1);
extern T0*oBC56yytypes1_template;
extern int fBC56yytypes1_template;
/*GEPP_PARSER*/
T0* r56yytypes1_template(void);
/*GEPP_PARSER*/
T2 r56yy_null_trans_state(T56* C,T2 a1);
extern T0*oBC58yy_accept_template;
extern int fBC58yy_accept_template;
/*GEPP_PARSER*/
T0* r56yy_accept_template(void);
/*GEPP_PARSER*/
void r56echo(T56* C);
/*GEPP_PARSER*/
void r56read_token(T56* C);
/*GEPP_PARSER*/
void r56yy_init_value_stacks(T56* C);
/*GEPP_PARSER*/
T2 r56yy_previous_state(T56* C);
extern T0*oBC57execution_environment;
extern T0*oBC56yypgoto_template;
extern int fBC56yypgoto_template;
/*GEPP_PARSER*/
T0* r56yypgoto_template(void);
/*GEPP_PARSER*/
void r56yy_refill_input_buffer(T56* C);
extern T0*oBC56yytypes2_template;
extern int fBC56yytypes2_template;
/*GEPP_PARSER*/
T0* r56yytypes2_template(void);
/*GEPP_PARSER*/
T0* r56yy_fixed_array(T0* a1);
extern T0*oBC58yy_meta_template;
extern int fBC58yy_meta_template;
/*GEPP_PARSER*/
T0* r56yy_meta_template(void);
extern T0*oBC58yy_base_template;
extern int fBC58yy_base_template;
/*GEPP_PARSER*/
T0* r56yy_base_template(void);
/*GEPP_PARSER*/
T2 r56text_count(T56* C);
/*GEPP_PARSER*/
T0* r56new_file_buffer(T0* a1);
/*GEPP_PARSER*/
void r56yy_initialize(T56* C);
/*GEPP_PARSER*/
T0* r56text(T56* C);
/*GEPP_PARSER*/
void r56yy_clear_value_stacks(T56* C);
extern T0*oBC58yy_nxt_template;
extern int fBC58yy_nxt_template;
/*GEPP_PARSER*/
T0* r56yy_nxt_template(void);
/*GEPP_PARSER*/
void r56yy_build_parser_tables(T56* C);
/*GEPP_PARSER*/
T6 r56valid_start_condition(T2 a1);
/*GEPP_PARSER*/
void r56yy_set_beginning_of_line(T56* C);
extern T0*oBC66empty_buffer;
extern int fBC66empty_buffer;
/*GEPP_PARSER*/
T0* r56empty_buffer(void);
/*GEPP_PARSER*/
void r56report_error(T56* C,T0* a1);
extern T0*oBC56yydefact_template;
extern int fBC56yydefact_template;
/*GEPP_PARSER*/
T0* r56yydefact_template(void);
extern T0*oBC58yy_chk_template;
extern int fBC58yy_chk_template;
/*GEPP_PARSER*/
T0* r56yy_chk_template(void);
/*GEPP_PARSER*/
void r56process_include(T56* C,T0* a1);
extern T0*oBC56yycheck_template;
extern int fBC56yycheck_template;
/*GEPP_PARSER*/
T0* r56yycheck_template(void);
/*GEPP_PARSER*/
void r56make(T56* C,T0* a1);
/*GEPP_PARSER*/
T0* r56yyfixed_array(T0* a1);
extern T0*oBC56yydefgoto_template;
extern int fBC56yydefgoto_template;
/*GEPP_PARSER*/
T0* r56yydefgoto_template(void);
/*GEPP_PARSER*/
void r56yy_pop_last_value(T56* C,T2 a1);
/*GEPP_PARSER*/
void r56yy_set_content(T56* C,T0* a1);
extern T0*oBC56yypact_template;
extern int fBC56yypact_template;
/*GEPP_PARSER*/
T0* r56yypact_template(void);
/*GEPP_PARSER*/
void r56set_start_condition(T56* C,T2 a1);
/*GEPP_PARSER*/
void r56yy_build_tables(T56* C);
/*GEPP_PARSER*/
void r56output(T56* C,T0* a1);
extern T0*oBC29string_;
/*KL_TEXT_INPUT_FILE*/
T6 r39is_closed(T39* C);
/*KL_TEXT_INPUT_FILE*/
void r39old_close(T39* C);
/*KL_TEXT_INPUT_FILE*/
T2 r39read_to_string(T39* C,T0* a1,T2 a2,T2 a3);
/*KL_TEXT_INPUT_FILE*/
void r39open_read(T39* C);
/*KL_TEXT_INPUT_FILE*/
void r39old_read_character(T39* C);
/*KL_TEXT_INPUT_FILE*/
void r39read_character(T39* C);
/*KL_TEXT_INPUT_FILE*/
void r39fill_buffer(T39* C);
/*KL_TEXT_INPUT_FILE*/
void r39close(T39* C);
/*KL_TEXT_INPUT_FILE*/
void r39make(T39* C,T0* a1);
/*KL_TEXT_INPUT_FILE*/
T2 r39read_to_buffer(T39* C,T0* a1,T2 a2,T2 a3);
/*KL_TEXT_INPUT_FILE*/
void r39connect_to(T39* C,T0* a1);
/*KL_TEXT_INPUT_FILE*/
T2 r39_47Pread_to_buffer(T39* C,T0* a1,T2 a2,T2 a3);
/*KL_TEXT_INPUT_FILE*/
void r39old_open_read(T39* C);
extern T0*oBC13arguments;
extern int fBC13arguments;
/*UT_VERSION_NUMBER*/
T0* r200arguments(void);
/*UT_VERSION_NUMBER*/
void r200make(T200* C,T0* a1);
/*UT_VERSION_NUMBER*/
T0* r200message(T200* C,T0* a1);
/*UT_VERSION_NUMBER*/
T0* r200default_message(T200* C);
/*KL_STDIN_FILE*/
T2 r186read_to_string(T186* C,T0* a1,T2 a2,T2 a3);
/*KL_STDIN_FILE*/
void r186old_read_character(T186* C);
/*KL_STDIN_FILE*/
void r186read_character(T186* C);
/*KL_STDIN_FILE*/
void r186fill_buffer(T186* C);
/*KL_STDIN_FILE*/
void r186make(T186* C);
/*KL_STDIN_FILE*/
T2 r186read_to_buffer(T186* C,T0* a1,T2 a2,T2 a3);
extern T0*oBC20std_output;
/*KL_STDIN_FILE*/
void r186old_make(T186* C);
/*KL_STDIN_FILE*/
T2 r186_47Pread_to_buffer(T186* C,T0* a1,T2 a2,T2 a3);
/*UT_ERROR_HANDLER*/
T0* r98message(T0* a1);
/*UT_ERROR_HANDLER*/
void r98report_info_message(T98* C,T0* a1);
/*UT_ERROR_HANDLER*/
void r98make_standard(T98* C);
/*UT_ERROR_HANDLER*/
void r98report_error_message(T98* C,T0* a1);
/*KL_CHARACTER_BUFFER*/
T0* r180substring(T180* C,T2 a1,T2 a2);
/*KL_CHARACTER_BUFFER*/
void r180fill_from_string(T180* C,T0* a1,T2 a2);
/*KL_CHARACTER_BUFFER*/
T2 r180fill_from_stream(T180* C,T0* a1,T2 a2,T2 a3);
/*KL_CHARACTER_BUFFER*/
void r180move_left(T180* C,T2 a1,T2 a2,T2 a3);
/*KL_CHARACTER_BUFFER*/
void r180make(T180* C,T2 a1);
/*KL_CHARACTER_BUFFER*/
void r180resize(T180* C,T2 a1);
extern T0*oBC30unix_file_system;
/*KL_TEXT_OUTPUT_FILE*/
T6 r21is_closed(T21* C);
/*KL_TEXT_OUTPUT_FILE*/
void r21old_close(T21* C);
extern T0*oBC30file_system;
extern int fBC30file_system;
/*KL_TEXT_OUTPUT_FILE*/
T0* r21file_system(void);
/*KL_TEXT_OUTPUT_FILE*/
void r21old_open_write(T21* C);
/*KL_TEXT_OUTPUT_FILE*/
void r21close(T21* C);
/*KL_TEXT_OUTPUT_FILE*/
void r21make(T21* C,T0* a1);
extern T0*oBC31operating_system;
/*KL_TEXT_OUTPUT_FILE*/
void r21old_put_string(T21* C,T0* a1);
/*KL_TEXT_OUTPUT_FILE*/
void r21old_put_character(T21* C,T3 a1);
/*KL_TEXT_OUTPUT_FILE*/
void r21connect_to(T21* C,T0* a1);
/*KL_TEXT_OUTPUT_FILE*/
void r21put_line(T21* C,T0* a1);
/*KL_TEXT_OUTPUT_FILE*/
void r21recursive_open_write(T21* C);
/*KL_TEXT_OUTPUT_FILE*/
void r21old_make(T21* C);
/*KL_TEXT_OUTPUT_FILE*/
void r21open_write(T21* C);
extern T0*oBC30windows_file_system;
/*KL_TEXT_OUTPUT_FILE*/
void r21write_buffer(T21* C);
/*UT_USAGE_MESSAGE*/
T0* r199arguments(void);
/*UT_USAGE_MESSAGE*/
void r199make(T199* C,T0* a1);
/*UT_USAGE_MESSAGE*/
T0* r199message(T199* C,T0* a1);
/*UT_USAGE_MESSAGE*/
T0* r199default_message(T199* C);
/*KL_WINDOWS_FILE_SYSTEM*/
T0* r194dirname(T0* a1);
/*KL_WINDOWS_FILE_SYSTEM*/
T0* r194string_to_pathname(T0* a1);
extern T0*oBC194root_directory;
/*KL_WINDOWS_FILE_SYSTEM*/
T6 r194is_root_directory(T0* a1);
/*KL_WINDOWS_FILE_SYSTEM*/
T0* r194pathname_to_string(T0* a1);
/*KL_WINDOWS_FILE_SYSTEM*/
T0* r194canonical_pathname(T0* a1);
/*UT_CANNOT_WRITE_TO_FILE_ERROR*/
T0* r188arguments(void);
/*UT_CANNOT_WRITE_TO_FILE_ERROR*/
void r188make(T188* C,T0* a1);
/*UT_CANNOT_WRITE_TO_FILE_ERROR*/
T0* r188message(T188* C,T0* a1);
/*UT_CANNOT_WRITE_TO_FILE_ERROR*/
T0* r188default_message(T188* C);
/*KL_DIRECTORY*/
T6 r189is_closed(T189* C);
/*KL_DIRECTORY*/
void r189open_read(T189* C);
/*KL_DIRECTORY*/
T0* r189file_system(void);
/*KL_DIRECTORY*/
void r189create_directory(T189* C);
/*KL_DIRECTORY*/
T6 r189is_open_read(T189* C);
/*KL_DIRECTORY*/
void r189close(T189* C);
/*KL_DIRECTORY*/
void r189make(T189* C,T0* a1);
/*KL_DIRECTORY*/
T6 r189exists(T189* C);
/*KL_DIRECTORY*/
void r189recursive_create_directory(T189* C);
/*KL_DIRECTORY*/
T6 r189is_readable(T189* C);
/*YY_BUFFER*/
void r95set_position(T95* C,T2 a1,T2 a2,T2 a3);
/*YY_BUFFER*/
void r95make(T95* C,T0* a1);
/*YY_BUFFER*/
void r95make_from_buffer(T95* C,T0* a1);
/*YY_BUFFER*/
T0* r95new_default_buffer(T2 a1);
/*GEPP_TOO_MANY_INCLUDES_ERROR*/
T0* r178arguments(void);
/*GEPP_TOO_MANY_INCLUDES_ERROR*/
void r178make(T178* C,T2 a1);
/*GEPP_TOO_MANY_INCLUDES_ERROR*/
T0* r178message(T178* C,T0* a1);
/*GEPP_TOO_MANY_INCLUDES_ERROR*/
T0* r178default_message(T178* C);
/*UT_CANNOT_READ_FILE_ERROR*/
T0* r179arguments(void);
/*UT_CANNOT_READ_FILE_ERROR*/
void r179make(T179* C,T0* a1);
/*UT_CANNOT_READ_FILE_ERROR*/
T0* r179message(T179* C,T0* a1);
/*UT_CANNOT_READ_FILE_ERROR*/
T0* r179default_message(T179* C);
/*UC_STRING*/
void r103copy(T103* C,T0* a1);
/*UC_STRING*/
T0* r103substring(T103* C,T2 a1,T2 a2);
/*UC_STRING*/
void r103reset_byte_index_cache(T103* C);
/*UC_STRING*/
void r103wipe_out(T103* C);
/*UC_STRING*/
T6 r103same_unicode_string(T103* C,T0* a1);
/*UC_STRING*/
T2 r103item_code(T103* C,T2 a1);
/*UC_STRING*/
T3 r103character_item_at_byte_index(T103* C,T2 a1);
/*UC_STRING*/
void r103_7Pmake(T103* C,T2 a1);
/*UC_STRING*/
void r103put(T103* C,T3 a1,T2 a2);
/*UC_STRING*/
T6 r103is_equal(T103* C,T0* a1);
/*UC_STRING*/
T3 r103item(T103* C,T2 a1);
extern T0*oBC61integer_;
/*UC_STRING*/
void r103resize_byte_storage(T103* C,T2 a1);
/*UC_STRING*/
T6 r103valid_index(T103* C,T2 a1);
/*UC_STRING*/
void r103append(T103* C,T0* a1);
/*UC_STRING*/
T6 r103se_assigned_from(T0* a1);
/*UC_STRING*/
T2 r103byte_index(T103* C,T2 a1);
/*UC_STRING*/
T0* r103clone(T0* a1);
/*UC_STRING*/
void r103make_from_string(T103* C,T0* a1);
/*UC_STRING*/
void r103move_bytes_right(T103* C,T2 a1,T2 a2);
/*UC_STRING*/
void r103set_count(T103* C,T2 a1);
/*UC_STRING*/
T2 r103next_byte_index(T103* C,T2 a1);
/*UC_STRING*/
T6 r103same_type(T103* C,T0* a1);
/*UC_STRING*/
void r103remove_tail(T103* C,T2 a1);
extern T0*oBC103dummy_uc_string;
extern int fBC103dummy_uc_string;
/*UC_STRING*/
T0* r103dummy_uc_string(void);
/*UC_STRING*/
void r103make(T103* C,T2 a1);
/*UC_STRING*/
void r103append_string(T103* C,T0* a1);
/*UC_STRING*/
void r103make_filled(T103* C,T3 a1,T2 a2);
/*UC_STRING*/
void r103append_substring(T103* C,T0* a1,T2 a2,T2 a3);
/*UC_STRING*/
T2 r103item_code_at_byte_index(T103* C,T2 a1);
/*UC_STRING*/
T0* r103string(T103* C);
extern T0*oBC45platform;
/*UC_STRING*/
void r103extend(T103* C,T3 a1);
/*UC_STRING*/
T2 r103hash_code(T103* C);
/*UC_STRING*/
T0* r103prefixed_string(T103* C,T0* a1);
/*UC_STRING*/
T6 r103conforms_to(T103* C,T0* a1);
/*UC_STRING*/
void r103keep_head(T103* C,T2 a1);
/*UC_STRING*/
T2 r103to_integer(T103* C);
/*UC_STRING*/
T0* r103new_empty_string(T2 a1);
/*UC_STRING*/
void r103append_character(T103* C,T3 a1);
/*UC_STRING*/
void r103make_from_substring(T103* C,T0* a1,T2 a2,T2 a3);
/*UC_STRING*/
void r103put_code_at_byte_index(T103* C,T2 a1,T2 a2,T2 a3);
/*UC_STRING*/
void r103fill_with(T103* C,T3 a1);
/*UC_STRING*/
void r103put_character_at_byte_index(T103* C,T3 a1,T2 a2,T2 a3);
/*UC_STRING*/
void r103_7Pappend_string(T103* C,T0* a1);
/*UC_STRING*/
void r103resize(T103* C,T2 a1);
/*UC_STRING*/
void r103put_substring_at_byte_index(T103* C,T0* a1,T2 a2,T2 a3,T2 a4,T2 a5);
/*UC_STRING*/
T2 r103substring_index(T103* C,T0* a1,T2 a2);
extern T0*oBC105utf8;
/*UC_STRING*/
void r103from_external_copy(T103* C,T8 a1);
/*UC_STRING*/
void r103move_bytes_left(T103* C,T2 a1,T2 a2);
/*UC_STRING*/
T8 r103to_external(T103* C);
/*UC_STRING*/
T6 r103same_string(T103* C,T0* a1);
/*UC_STRING*/
T0* r103twin(T103* C);
/*UC_STRING*/
T0* r103to_utf8(T103* C);
/*UC_STRING*/
T0* r103_ix_43(T103* C,T0* a1);
extern T0*oBC101unicode;
/*UC_STRING*/
T2 r103_7Phash_code(T103* C);
/*UC_STRING*/
T2 r103unicode_substring_index(T103* C,T0* a1,T2 a2);
/*UC_STRING*/
void r103swap(T103* C,T2 a1,T2 a2);
/*YY_FILE_BUFFER*/
void r94fill(T94* C);
/*YY_FILE_BUFFER*/
void r94compact_left(T94* C);
/*YY_FILE_BUFFER*/
void r94set_position(T94* C,T2 a1,T2 a2,T2 a3);
extern T2 oBC95default_capacity;
/*YY_FILE_BUFFER*/
void r94make_from_string(T94* C,T0* a1);
/*YY_FILE_BUFFER*/
void r94make_from_buffer(T94* C,T0* a1);
/*YY_FILE_BUFFER*/
void r94resize(T94* C);
/*YY_FILE_BUFFER*/
T0* r94new_default_buffer(T2 a1);
/*YY_FILE_BUFFER*/
void r94make_with_size(T94* C,T0* a1,T2 a2);
/*YY_FILE_BUFFER*/
void r94set_file(T94* C,T0* a1);
/*YY_FILE_BUFFER*/
void r94flush(T94* C);
/*KL_STDOUT_FILE*/
void r197make(T197* C);
/*KL_STDOUT_FILE*/
void r197old_put_string(T197* C,T0* a1);
/*KL_STDOUT_FILE*/
void r197old_put_character(T197* C,T3 a1);
/*KL_STDOUT_FILE*/
void r197put_line(T197* C,T0* a1);
/*KL_STDOUT_FILE*/
void r197old_make(T197* C);
/*KL_STDOUT_FILE*/
void r197write_buffer(T197* C);
/*KL_STDOUT_FILE*/
void r197put_string(T197* C,T0* a1);
/*KL_STDERR_FILE*/
void r127make(T127* C);
/*KL_STDERR_FILE*/
void r127old_put_string(T0* a1);
/*KL_STDERR_FILE*/
void r127put_line(T0* a1);
/*KL_STDERR_FILE*/
void r127put_string(T0* a1);
/*KL_UNIX_FILE_SYSTEM*/
T0* r195dirname(T0* a1);
/*KL_UNIX_FILE_SYSTEM*/
T0* r195string_to_pathname(T0* a1);
extern T0*oBC195root_directory;
/*KL_UNIX_FILE_SYSTEM*/
T6 r195is_root_directory(T0* a1);
/*KL_UNIX_FILE_SYSTEM*/
T0* r195pathname_to_string(T0* a1);
/*KL_UNIX_FILE_SYSTEM*/
T0* r195canonical_pathname(T0* a1);
/*KL_PATHNAME*/
void r206append_name(T206* C,T0* a1);
/*KL_PATHNAME*/
T6 r206is_parent(T206* C,T2 a1);
/*KL_PATHNAME*/
void r206make(T206* C);
/*KL_PATHNAME*/
void r206set_canonical(T206* C);
/*KL_PATHNAME*/
T6 r206is_current(T206* C,T2 a1);
/*STD_OUTPUT*/
void r198make(T198* C);
/*STD_OUTPUT*/
void r198flush(T198* C);
/*STD_OUTPUT*/
void r198write_buffer(T198* C);
/*UT_SYNTAX_ERROR*/
T0* r96arguments(void);
/*UT_SYNTAX_ERROR*/
void r96make(T96* C,T0* a1,T2 a2);
/*UT_SYNTAX_ERROR*/
T0* r96message(T96* C,T0* a1);
/*UT_SYNTAX_ERROR*/
T0* r96default_message(T96* C);
extern T0*oBC20command_arguments;
extern int fBC20command_arguments;
/*KL_ARGUMENTS*/
T0* r119command_arguments(void);
/*KL_ARGUMENTS*/
T0* r119argument(T2 a1);
extern T0*oBC126error;
extern int fBC126error;
/*KL_STANDARD_FILES*/
T0* r126error(void);
extern T0*oBC126input;
extern int fBC126input;
/*KL_STANDARD_FILES*/
T0* r126input(void);
extern T0*oBC126output;
extern int fBC126output;
/*KL_STANDARD_FILES*/
T0* r126output(void);
extern T2 oBC208maximum_character_code;
extern int fBC208maximum_character_code;
/*KL_PLATFORM*/
T2 r208maximum_character_code(T208* C);
/*UC_UNICODE_ROUTINES*/
T6 r112valid_code(T2 a1);
/*UC_UTF8_ROUTINES*/
T2 r116encoded_next_value(T3 a1);
/*UC_UTF8_ROUTINES*/
T2 r116character_byte_count(T3 a1);
/*UC_UTF8_ROUTINES*/
T2 r116encoded_first_value(T3 a1);
/*UC_UTF8_ROUTINES*/
T2 r116code_byte_count(T2 a1);
/*UC_UTF8_ROUTINES*/
T2 r116encoded_byte_count(T3 a1);
/*UC_UTF8_ROUTINES*/
T2 r116substring_byte_count(T0* a1,T2 a2,T2 a3);
/*KL_INTEGER_ROUTINES*/
T3 r111to_character(T2 a1);
/*GEPP*/
void r12preprocess(T12* C);
/*GEPP*/
T0* r12arguments(void);
/*GEPP*/
void r12read_arguments(T12* C);
/*GEPP*/
void r12report_cannot_read_error(T12* C,T0* a1);
extern T0*oBC12usage_message;
extern int fBC12usage_message;
/*GEPP*/
T0* r12usage_message(void);
extern T0*oBC14exceptions;
/*GEPP*/
void r12execute(T12* C);
/*GEPP*/
void r12report_version_number(T12* C);
/*GEPP*/
void r12report_cannot_write_error(T12* C,T0* a1);
/*SYSTEM*/
T0* r184get_environment_variable(T0* a1);
/*BASIC_DIRECTORY*/
void r191connect_to_current_working_directory(T191* C);
/*BASIC_DIRECTORY*/
void r191disconnect(T191* C);
extern T0*oBC191last_entry;
/*BASIC_DIRECTORY*/
void r191connect_to(T191* C,T0* a1);
/*BASIC_DIRECTORY*/
T6 r191create_new_directory(T0* a1);
/*KL_STRING_ROUTINES*/
T0* r100as_string(T0* a1);
/*KL_STRING_ROUTINES*/
T0* r100clone(T0* a1);
/*KL_STRING_ROUTINES*/
T0* r100appended_string(T0* a1,T0* a2);
/*KL_STRING_ROUTINES*/
T6 r100is_integer(T0* a1);
/*KL_STRING_ROUTINES*/
T0* r100appended_substring(T0* a1,T0* a2,T2 a3,T2 a4);
/*KL_STRING_ROUTINES*/
T0* r100new_empty_string(T0* a1,T2 a2);
/*KL_STRING_ROUTINES*/
T0* r100concat(T0* a1,T0* a2);
/*KL_STRING_ROUTINES*/
T6 r100same_string(T0* a1,T0* a2);
/*KL_STRING_ROUTINES*/
T6 r100elks_same_string(T0* a1,T0* a2);
/*KL_STRING_ROUTINES*/
void r100append_substring_to_string(T0* a1,T0* a2,T2 a3,T2 a4);
/*KL_EXECUTION_ENVIRONMENT*/
T0* r183variable_value(T183* C,T0* a1);
/*KL_EXECUTION_ENVIRONMENT*/
T0* r183interpreted_string(T183* C,T0* a1);
/*KL_OPERATING_SYSTEM*/
T0* r129current_working_directory(T129* C);
/*KL_OPERATING_SYSTEM*/
T0* r129variable_value(T129* C,T0* a1);
/*KL_OPERATING_SYSTEM*/
T0* r129clone(T0* a1);
extern T6 oBC129is_windows;
extern int fBC129is_windows;
/*KL_OPERATING_SYSTEM*/
T6 r129is_windows(T129* C);
extern T6 oBC129is_unix;
extern int fBC129is_unix;
/*KL_OPERATING_SYSTEM*/
T6 r129is_unix(T129* C);
extern T12*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 212
void std_output_flush(void);
void initialize_eiffel_runtime(int argc,char*argv[]);
extern T7*ms127_10;
extern T7*ms17_1556;
extern T7*ms206_46;
extern T7*ms188_1606053737;
extern T7*ms200_1158552108;
extern T7*ms179_988446515;
extern T7*ms100_0;
extern T7*ms199_1515383187;
extern T7*ms103_0;
extern T7*ms116_0;
extern T7*ms178_434195944;
extern T7*ms96_1449702436;
extern T7*ms194_276;
extern T7*ms194_46;
extern T7*ms195_46;
extern T7*ms195_276;
extern T7*ms197_10;
extern T7*ms21_10;
extern T7*ms206_276;
extern T7*ms26_250860571;
T7*se_ms(int c,char*e);
T7*se_string(char*e);
/*
-- This file is  free  software, which  comes  along  with  SmartEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmartEiffel@loria.fr
--                       http://SmartEiffel.loria.fr
--
*/
/*
  This file (SmartEiffel/sys/runtime/manifest_string_trace.h) is automatically
  included when the -manifest_string_trace command line flag is used.
*/

EIF_STRING se_ms_trace(int count, char* c_string, int li, int co, char* path);
void se_msi1(void);
void*se_ma203(int argc,...);
T0* X7substring(T0*C,T2 a1,T2 a2);
void X7wipe_out(T0*C);
T2 X7item_code(T0*C,T2 a1);
void X7put(T0*C,T3 a1,T2 a2);
T6 X7is_equal(T0*C,T0* a1);
T3 X7item(T0*C,T2 a1);
void X7append(T0*C,T0* a1);
void X7set_count(T0*C,T2 a1);
T6 X7same_type(T0*C,T0* a1);
void X7remove_tail(T0*C,T2 a1);
void X7append_string(T0*C,T0* a1);
T0* X7string(T0*C);
void X7extend(T0*C,T3 a1);
T2 X7hash_code(T0*C);
T2 X7to_integer(T0*C);
void X7append_character(T0*C,T3 a1);
void X7resize(T0*C,T2 a1);
void X7from_external_copy(T0*C,T8 a1);
T8 X7to_external(T0*C);
T6 X7same_string(T0*C,T0* a1);
T0* X7twin(T0*C);
T0* X7_ix_43(T0*C,T0* a1);
void X7swap(T0*C,T2 a1,T2 a2);
T0* X18twin(T0*C);
T6 X20se_assigned_from(T0*C,T0* a1);
T6 X20conforms_to(T0*C,T0* a1);
void X38put_new_line(T0*C);
void X38put_line(T0*C,T0* a1);
void X38put_string(T0*C,T0* a1);
T6 X46is_closable(T0*C);
T0* X46name(T0*C);
T2 X46read_to_string(T0*C,T0* a1,T2 a2,T2 a3);
void X46read_character(T0*C);
void X46close(T0*C);
T2 X46read_to_buffer(T0*C,T0* a1,T2 a2,T2 a3);
T6 X46end_of_input(T0*C);
T3 X46last_character(T0*C);
void X95fill(T0*C);
T0* X97default_message(T0*C);
T0* X192dirname(T0*C,T0* a1);
T0* X192canonical_pathname(T0*C,T0* a1);

#ifdef __cplusplus
}
#endif
