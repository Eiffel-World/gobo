#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmallEiffel The GNU Eiffel Compiler
Release -0.74 (Tuesday May 7th 2002)
Copyright (C), 1994-2002 - LORIA - UHP - INRIA - FRANCE
Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
http://SmallEiffel.loria.fr
C Compiler options used: -O2 -nologo -D"WIN32" -w
*/

/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of
  compilation: -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifdef WIN32
#include <windows.h>
#else
#ifndef O_RDONLY
#include <sys/file.h>
#endif
#ifndef O_RDONLY
#define O_RDONLY 0000
#endif
#endif

/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0
#endif

/*
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.
*/
#ifdef _SIGSET_H_types
#define JMP_BUF    sigjmp_buf
#define SETJMP(x)  sigsetjmp( (x), 1)
#define LONGJMP    siglongjmp
#else
#define JMP_BUF    jmp_buf
#define SETJMP(x)  setjmp( (x) )
#define LONGJMP    longjmp
#endif

/*
   Type to store reference objects Id:
 */
typedef int Tid;
typedef struct S0 T0;
struct S0{Tid id;};

/*
   The default channel used to print runtime error messages:
*/
#define SE_ERR stderr

/*
   Eiffel type INTEGER is #2:
*/
typedef int T2;
#define EIF_INTEGER T2
#define M2 (0)
#define EIF_INTEGER_BITS (CHAR_BIT*sizeof(int))
#define EIF_MINIMUM_INTEGER (INT_MIN)
#define EIF_MAXIMUM_INTEGER (INT_MAX)

/*
  Eiffel type CHARACTER is #3:
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T2)(x))
#define T3to_integer(x) ((T2)((char)(x)))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL is #4:
*/
typedef float T4;
#define EIF_REAL T4
#define M4 (0.0)
#define EIF_REAL_BITS (CHAR_BIT*sizeof(float))
#define EIF_MINIMUM_REAL (-(FLT_MAX))
#define EIF_MAXIMUM_REAL (FLT_MAX)
#define T2toT4(x) ((T4)(x))

/*
  Eiffel type DOUBLE is #5:
*/
typedef double T5;
#define EIF_DOUBLE T5
#define M5 (0.0)
#define EIF_DOUBLE_BITS (CHAR_BIT*sizeof(double))
#define EIF_MINIMUM_DOUBLE (-(DBL_MAX))
#define EIF_MAXIMUM_DOUBLE (DBL_MAX)
#define T2toT5(x) ((T5)(x))
#define T4toT5(x) ((T5)(x))

/*
  Eiffel type BOOLEAN is #6:
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/*
   Eiffel type POINTER is #8:
*/
typedef void* T8;
#define EIF_POINTER T8
#define M8 (NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side:
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL:
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/*
   Wrappers for `malloc' and `calloc':
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);

/*C Header Pass 1 :*/
typedef struct S45 T45;
typedef struct S33 T33;
typedef struct S181 T181;
typedef struct S108 T108;
typedef struct S186 T186;
typedef struct S143 T143;
typedef struct S112 T112;
typedef struct S63 T63;
typedef struct S80 T80;
typedef struct S69 T69;
typedef struct S126 T126;
typedef struct S158 T158;
typedef struct S167 T167;
typedef struct S83 T83;
typedef struct S60 T60;
typedef struct S105 T105;
typedef struct S182 T182;
typedef struct S43 T43;
typedef struct S17 T17;
typedef struct S97 T97;
typedef struct S96 T96;
typedef struct S194 T194;
typedef struct S180 T180;
typedef struct S175 T175;
typedef struct S11 T11;
typedef struct S123 T123;
typedef struct S169 T169;
typedef struct S42 T42;
typedef struct S103 T103;
typedef int T166;
typedef struct S7 T7;
typedef struct S170 T170;
typedef struct S193 T193;
typedef struct S172 T172;
typedef struct S85 T85;
typedef struct S161 T161;
typedef struct S162 T162;
typedef struct S76 T76;
typedef struct S88 T88;
typedef struct S137 T137;
typedef struct S165 T165;
typedef struct S79 T79;
typedef struct S178 T178;
typedef struct S109 T109;
typedef struct S176 T176;
typedef struct S140 T140;
typedef struct S99 T99;
typedef struct S74 T74;
typedef struct S65 T65;
typedef struct S111 T111;
typedef struct S122 T122;
typedef struct S188 T188;
typedef struct S81 T81;
typedef struct S101 T101;

/*C Header Pass 2 :*/
typedef T0**T125;
typedef T0**T100;
typedef T3*T9;
typedef T2*T78;
typedef T0**T75;

/*C Header Pass 3 :*/
struct S172{T8 _directory_stream;T8 _current_entry;};
int se_cmpT172(T172 o1,T172 o2);

/*C Header Pass 4 :*/
struct S45{Tid id;T2 _error_count;T0* _yytranslate;T0* _yyr1;T0* _yyr2;T0* _yydefact;T0* _yydefgoto;T0* _yypact;T0* _yypgoto;T0* _yytable;T0* _yycheck;T0* _yyvs;T0* _yyss;T2 _yyvsp;T2 _yyssp;T0* _yyval;T6 _yy_lookahead_needed;T2 _yyerrstatus;T2 _yy_parsing_status;T0* _fixed_array_;T2 _last_token;T0* _input_buffer;T2 _line;T2 _column;T2 _position;T2 _yy_start_state;T0* _yy_content;T2 _yy_end;T2 _yy_start;T2 _yy_line;T2 _yy_column;T2 _yy_position;T6 _yy_more_flag;T2 _yy_more_len;T2 _yy_last_accepting_state;T2 _yy_last_accepting_cpos;T0* _yy_nxt;T0* _yy_chk;T0* _yy_base;T0* _yy_def;T0* _yy_ec;T0* _yy_meta;T0* _yy_accept;T0* _yy_acclist;T6 _yy_rejected;T0* _yy_state_stack;T2 _yy_state_count;T2 _yy_full_match;T2 _yy_lp;T2 _yy_looking_for_trail_begin;T2 _yy_full_lp;T2 _yy_full_state;T2 _line_nb;T0* _last_value;T6 _empty_lines;T0* _output_file;T0* _error_handler;T6 _makefile_dependencies;T0* _defined_values;T2 _if_level;T2 _ignored_level;T0* _include_stack;};
extern T45 M45;
struct S33{Tid id;T6 _push_back_flag;T0* _name;T0* _string_name;T0* _path;T8 _input_stream;T2 _memory;T3 _last_character;T6 _end_of_file;T0* _character_buffer;};
extern T33 M33;
struct S181{Tid id;T0* _parameters;};
extern T181 M181;
struct S108{Tid id;};
extern T108 M108;
struct S186{Tid id;T78 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T186 M186;
struct S143{Tid id;};
extern T143 M143;
struct S112{Tid id;};
extern T112 M112;
struct S63{Tid id;};
extern T63 M63;
struct S69{Tid id;};
extern T69 M69;
struct S126{Tid id;};
extern T126 M126;
struct S158{Tid id;T2 _position;T0* _container;T0* _next_cursor;};
extern T158 M158;
struct S167{Tid id;T6 _push_back_flag;T172 _basic_directory;T2 _memory;T0* _name;T3 _last_character;T6 _end_of_file;T0* _character_buffer;};
extern T167 M167;
struct S83{Tid id;T0* _error_file;T0* _warning_file;T0* _info_file;};
extern T83 M83;
struct S60{Tid id;T2 _item;};
extern T60 M60;
struct S105{Tid id;T2 _count;T9 _area;T0* _area_string;};
extern T105 M105;
struct S182{Tid id;};
extern T182 M182;
struct S43{Tid id;T8 _item;};
extern T43 M43;
struct S17{Tid id;T0* _name;T0* _string_name;T0* _path;T8 _output_stream;};
extern T17 M17;
struct S97{Tid id;};
extern T97 M97;
struct S96{Tid id;};
extern T96 M96;
struct S194{Tid id;};
extern T194 M194;
struct S180{Tid id;T0* _parameters;};
extern T180 M180;
struct S175{Tid id;};
extern T175 M175;
struct S11{Tid id;T0* _in_filename;T0* _out_filename;T0* _parser;T0* _error_handler;};
extern T11 M11;
struct S123{Tid id;T125 _storage;T2 _capacity;T2 _upper;};
extern T123 M123;
struct S169{Tid id;T0* _parameters;};
extern T169 M169;
struct S42{Tid id;T6 _item;};
extern T42 M42;
struct S103{Tid id;T100 _storage;T2 _capacity;T2 _upper;};
extern T103 M103;
extern T166 M166;
struct S170{Tid id;T0* _name;T0* _last_entry;T6 _end_of_input;T0* _string_name;T0* _entry_buffer;T172 _basic_directory;};
extern T170 M170;
struct S193{Tid id;};
extern T193 M193;
struct S7{Tid id;T9 _storage;T2 _count;T2 _capacity;};
extern T7 M7;
struct S80{Tid id;T0* _content;T2 _count;T2 _capacity;T2 _position;T2 _column;T2 _line;T2 _index;T6 _beginning_of_line;T6 _filled;};
extern T80 M80;
extern T172 M172;
struct S85{Tid id;};
extern T85 M85;
struct S161{Tid id;T0* _parameters;};
extern T161 M161;
struct S162{Tid id;T0* _parameters;};
extern T162 M162;
struct S76{Tid id;T78 _storage;T2 _capacity;T2 _upper;};
extern T76 M76;
struct S88{Tid id;T9 _storage;T2 _count;T2 _byte_count;T2 _byte_capacity;T2 _last_byte_index_input;T2 _last_byte_index_result;};
extern T88 M88;
struct S137{Tid id;T0* _equality_tester;T0* _key_equality_tester;T2 _count;T2 _capacity;T2 _last_position;T2 _modulus;T2 _free_slot;T2 _position;T2 _slots_position;T2 _clashes_previous_position;T2 _found_position;T0* _internal_cursor;T0* _items;T0* _keys;T0* _clashes;T0* _slots;T0* _fixed_item_array_;T0* _fixed_key_array_;};
extern T137 M137;
struct S165{Tid id;};
extern T165 M165;
struct S79{Tid id;T0* _content;T2 _count;T2 _capacity;T2 _position;T2 _column;T2 _line;T2 _index;T6 _beginning_of_line;T6 _filled;T6 _interactive;T0* _file;T6 _end_of_file;};
extern T79 M79;
struct S178{Tid id;T172 _basic_directory;T0* _name;};
extern T178 M178;
struct S109{Tid id;T172 _basic_directory;T0* _name;};
extern T109 M109;
struct S176{Tid id;};
extern T176 M176;
struct S140{Tid id;};
extern T140 M140;
struct S99{Tid id;T100 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T99 M99;
struct S74{Tid id;T75 _storage;T2 _capacity;T2 _upper;};
extern T74 M74;
struct S65{Tid id;T3 _item;};
extern T65 M65;
struct S111{Tid id;T172 _basic_directory;};
extern T111 M111;
struct S122{Tid id;T2 _count;T2 _capacity;T0* _storage;T0* _fixed_array_;};
extern T122 M122;
struct S188{Tid id;T6 _is_relative;T0* _drive;T0* _hostname;T2 _count;T0* _components;};
extern T188 M188;
struct S81{Tid id;T0* _parameters;};
extern T81 M81;
struct S101{Tid id;T0* _program_name;};
extern T101 M101;
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/

/*
  This file (SmallEiffel/sys/runtime/boost.h) is automatically included when
  `run_control.boost' is true (ie. only for mode -boost).
*/
#define SE_BOOST 1
void se_print_run_time_stack (void);
void se_signal_handler(int sig);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/exception.h) is automatically included
  when exception handling is used somewhere in the live code.
*/

#define SE_EXCEPTIONS 1

/*
  Constants from Eiffel class EXCEPTIONS :
*/
#define Check_instruction 	  1
#define Class_invariant 	  2
#define Developer_exception 	  3
#define Incorrect_inspect_value   4
#define Loop_invariant 		  5
#define Loop_variant 		  6
#define No_more_memory  	  7
#define Postcondition 		  8
#define Precondition  		  9
#define Routine_failure  	  10
#define	Os_signal		  11
#define Void_attached_to_expanded 12
#define Void_call_target 	  13
#define System_level_type_error	  14

/*
   This will be the structure of rescue contexts.  A rescue context
   will be declared for every routine that has a rescue clause.

   The `next' pointer is the address of the next rescue context if there
   is one higher up the call chain, or NULL if there is no other
   context.
*/
struct rescue_context {
  JMP_BUF jb;
#ifdef SE_NO_CHECK
  /* To keep track of dump stack to unwind it safely
     before the LONGJMP :
  */
  struct _se_dump_stack * top_of_ds ;
#endif
  struct rescue_context *next;
};

extern struct rescue_context *rescue_context_top;
extern int internal_exception_number;
extern int original_internal_exception_number;
extern int signal_exception_number;
extern char *additional_error_message;

void setup_signal_handler(void);
void signal_exception_handler(int);
void internal_exception_handler(int);
void print_exception(void);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_directory.h) is automatically
  included when some external "SmallEiffel" feature of class BASIC_DIRECTORY
  is live.
*/
#ifndef WIN32
#include <dirent.h>
#endif
#ifndef WIN32
#include <unistd.h>
#endif

EIF_POINTER basic_directory_open(EIF_POINTER path);
EIF_POINTER basic_directory_read_entry(EIF_POINTER dirstream);
EIF_POINTER basic_directory_get_entry_name(EIF_POINTER entry);
EIF_BOOLEAN basic_directory_close(EIF_POINTER dirstream);
#define basic_directory_current_working_directory (basic_directory_cwd())
EIF_POINTER basic_directory_cwd(void);
EIF_BOOLEAN basic_directory_chdir(EIF_POINTER destination);
EIF_BOOLEAN basic_directory_mkdir(EIF_POINTER directory_path);
EIF_BOOLEAN basic_directory_rmdir(EIF_POINTER directory_path);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_io.h) is automatically
  included when some external "SmallEiffel" basic_io_* feature is used.
*/

#define basic_io_stdin (stdin)
#define basic_io_stdout (stdout)
#define basic_io_stderr (stderr)
#define basic_io_eof (EOF)
#define basic_io_text_file_read_open(p) (fopen(((char*)(p)),"r"))
#define basic_io_text_file_write_open(p) (fopen(((char*)(p)),"w"))
#define basic_io_text_file_write_append(p) (fopen(((char*)(p)),"a"))
#define basic_io_text_file_read_write_open(p) (fopen(((char*)(p)),"r+"))
#define basic_io_text_file_read_write_append(p) (fopen(((char*)(p)),"a+"))
#define basic_io_binary_file_read_open(p) (fopen(((char*)(p)),"rb"))
#define basic_io_binary_file_write_open(p) (fopen(((char*)(p)),"wb"))
#define basic_io_binary_file_write_append(p) (fopen(((char*)(p)),"ab"))
#define basic_io_fclose(p) (fclose((FILE*)(p)))
#define basic_io_flush(p) (fflush((FILE*)(p)))
#define basic_io_getc(f) (getc(((FILE*)(f))))
#define basic_io_putc(b, f) (putc((b),((FILE*)(f))))
#define basic_io_feof(f) (feof(((FILE*)(f))))
#define basic_io_rename(o, n) (rename(((char*)(o)),((char*)(n))))
#define basic_io_remove(f) (remove(((char*)(f))))
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_getenv.h) is automatically
  included when the GENERAL.basic_getenv feature is used (ie. in live code).
*/

#define basic_getenv(v) (getenv((char*)v))
T6 r8is_null(T8 C);
T6 r6_ix_not(T6 C);
T6 r6_px_or(T6 C,T6 a1);
T6 r6_px_and(T6 C,T6 a1);
T6 r3_px_6061(T3 C,T3 a1);
T6 r3is_digit(T3 C);
T6 r3is_separator(T3 C);
T6 r3_px_6261(T3 C,T3 a1);
T2 r3value(T3 C);
T6 r3_px_60(T3 C,T3 a1);
T6 r3_px_62(T3 C,T3 a1);
T2 r3decimal_value(T3 C);
T0* r2out(T2 C);
T2 r2max(T2 C,T2 a1);
T2 r2min(T2 C,T2 a1);
T3 r2digit(T2 C);
void r2append_in(T2 C,T0* a1);
extern T0*oBC1tagged_out_memory;
void r125clear_all(T125 C,T2 a1);
T125 r125realloc(T125 C,T2 a1,T2 a2);
void r125set_all_with(T125 C,T0* a1,T2 a2);
void r125clear(T125 C,T2 a1,T2 a2);
void r125copy_from(T125 C,T125 a1,T2 a2);
void r100clear_all(T100 C,T2 a1);
T100 r100realloc(T100 C,T2 a1,T2 a2);
void r100move(T100 C,T2 a1,T2 a2,T2 a3);
void r100set_all_with(T100 C,T0* a1,T2 a2);
void r100clear(T100 C,T2 a1,T2 a2);
void r100copy_from(T100 C,T100 a1,T2 a2);
void r9copy_slice(T9 C,T2 a1,T9 a2,T2 a3,T2 a4);
T9 r9realloc(T9 C,T2 a1,T2 a2);
void r9set_all_with(T9 C,T3 a1,T2 a2);
T6 r9fast_memcmp(T9 C,T9 a1,T2 a2);
void r9copy_at(T9 C,T2 a1,T9 a2,T2 a3);
void r9clear(T9 C,T2 a1,T2 a2);
void r9copy_from(T9 C,T9 a1,T2 a2);
void r78clear_all(T78 C,T2 a1);
T78 r78realloc(T78 C,T2 a1,T2 a2);
void r78set_all_with(T78 C,T2 a1,T2 a2);
void r78clear(T78 C,T2 a1,T2 a2);
void r78copy_from(T78 C,T78 a1,T2 a2);
void r75clear_all(T75 C,T2 a1);
T75 r75realloc(T75 C,T2 a1,T2 a2);
void r75set_all_with(T75 C,T0* a1,T2 a2);
void r75clear(T75 C,T2 a1,T2 a2);
void r75copy_from(T75 C,T75 a1,T2 a2);
void r7copy(T7* C,T0* a1);
T0* r7substring(T7* C,T2 a1,T2 a2);
T2 r7item_code(T7* C,T2 a1);
T6 r7is_equal(T7* C,T0* a1);
T3 r7item(T7* C,T2 a1);
void r7append(T7* C,T0* a1);
T6 r7se_assigned_from(T0* a1);
void r7make_from_string(T7* C,T0* a1);
T6 r7same_type(T7* C,T0* a1);
void r7remove_tail(T7* C,T2 a1);
void r7make(T7* C,T2 a1);
void r7append_string(T7* C,T0* a1);
void r7make_filled(T7* C,T3 a1,T2 a2);
T0* r7string(T7* C);
void r7extend(T7* C,T3 a1);
T0* r7_px_43(T7* C,T0* a1);
T2 r7hash_code(T7* C);
T6 r7conforms_to(T7* C,T0* a1);
T2 r7to_integer(T7* C);
void r7append_character(T7* C,T3 a1);
void r7resize(T7* C,T2 a1);
T2 r7substring_index(T7* C,T0* a1,T2 a2);
void r7from_external_copy(T7* C,T8 a1);
T8 r7to_external(T7* C);
T0* r7twin(T7* C);
void r7swap(T7* C,T2 a1,T2 a2);
void r186copy(T186* C,T0* a1);
T2 r186count(T186* C);
T2 r186item(T186* C,T2 a1);
T6 r186se_assigned_from(T0* a1);
T6 r186conforms_to(T186* C,T0* a1);
T0* r186twin(T186* C);
void r123copy(T123* C,T0* a1);
T6 r123se_assigned_from(T0* a1);
void r123make(T123* C,T2 a1);
T6 r123conforms_to(T123* C,T0* a1);
void r123resize(T123* C,T2 a1);
T0* r123twin(T123* C);
void r103copy(T103* C,T0* a1);
T6 r103se_assigned_from(T0* a1);
void r103make(T103* C,T2 a1);
T6 r103conforms_to(T103* C,T0* a1);
void r103resize(T103* C,T2 a1);
T0* r103twin(T103* C);
void r76copy(T76* C,T0* a1);
T6 r76se_assigned_from(T0* a1);
void r76make(T76* C,T2 a1);
T6 r76conforms_to(T76* C,T0* a1);
void r76resize(T76* C,T2 a1);
T0* r76twin(T76* C);
void r76with_capacity(T76* C,T2 a1);
void r76from_collection(T76* C,T0* a1);
void r99copy(T99* C,T0* a1);
void r99force(T99* C,T0* a1,T2 a2);
T2 r99count(T99* C);
T0* r99item(T99* C,T2 a1);
T6 r99valid_index(T99* C,T2 a1);
T6 r99se_assigned_from(T0* a1);
void r99make(T99* C,T2 a1,T2 a2);
T6 r99conforms_to(T99* C,T0* a1);
void r99add_last(T99* C,T0* a1);
void r99resize(T99* C,T2 a1,T2 a2);
T0* r99twin(T99* C);
void r74copy(T74* C,T0* a1);
T2 r74count(T74* C);
T0* r74item(T74* C,T2 a1);
T6 r74se_assigned_from(T0* a1);
void r74make(T74* C,T2 a1);
T6 r74conforms_to(T74* C,T0* a1);
void r74resize(T74* C,T2 a1);
T0* r74twin(T74* C);
T6 r143se_assigned_from(T0* a1);
T6 r143conforms_to(T143* C,T0* a1);
T6 r143test(T0* a1,T0* a2);
T0* r143twin(T143* C);
void r69clear_all(T0* a1);
T6 r69se_assigned_from(T0* a1);
T0* r69make(T2 a1);
T6 r69conforms_to(T69* C,T0* a1);
T0* r69resize(T0* a1,T2 a2);
T0* r69twin(T69* C);
T6 r126se_assigned_from(T0* a1);
T0* r126to_fixed_array(T0* a1);
T0* r126make(T2 a1);
T0* r126make_from_array(T0* a1);
T6 r126conforms_to(T126* C,T0* a1);
T0* r126resize(T0* a1,T2 a2);
T0* r126twin(T126* C);
void r158copy(T158* C,T0* a1);
T6 r158se_assigned_from(T0* a1);
void r158make(T158* C,T0* a1);
T6 r158off(T158* C);
T6 r158conforms_to(T158* C,T0* a1);
T0* r158twin(T158* C);
T6 r182se_assigned_from(T0* a1);
T0* r182make(T2 a1);
T6 r182conforms_to(T182* C,T0* a1);
T0* r182resize(T0* a1,T2 a2);
T0* r182twin(T182* C);
T2 r137new_capacity(T2 a1);
void r137copy(T137* C,T0* a1);
void r137force(T137* C,T0* a1,T0* a2);
void r137make_clashes(T137* C,T2 a1);
void r137search_position(T137* C,T0* a1);
void r137remove_traversing_cursor(T137* C,T0* a1);
void r137clone_slots(T137* C);
void r137keys_resize(T137* C,T2 a1);
void r137clone_clashes(T137* C);
void r137move_all_cursors_after(T137* C);
void r137make_items(T137* C,T2 a1);
void r137add_traversing_cursor(T137* C,T0* a1);
T6 r137se_assigned_from(T0* a1);
T0* r137clone(T0* a1);
void r137remove_position(T137* C,T2 a1);
void r137make(T137* C,T2 a1);
void r137remove(T137* C,T0* a1);
void r137clone_items(T137* C);
T6 r137conforms_to(T137* C,T0* a1);
T6 r137has(T137* C,T0* a1);
void r137make_keys(T137* C,T2 a1);
T2 r137hash_position(T137* C,T0* a1);
extern T0*oBC55fixed_integer_array_;
void r137items_resize(T137* C,T2 a1);
void r137clone_keys(T137* C);
void r137make_with_equality_testers(T137* C,T2 a1,T0* a2,T0* a3);
void r137move_cursors_after(T137* C,T2 a1);
void r137resize(T137* C,T2 a1);
void r137move_cursors_forth(T137* C,T2 a1);
void r137clashes_resize(T137* C,T2 a1);
void r137slots_resize(T137* C,T2 a1);
T0* r137twin(T137* C);
T0* r137new_cursor(T137* C);
void r137make_slots(T137* C,T2 a1);
void r137move_all_cursors(T137* C,T2 a1,T2 a2);
T2 r137new_modulus(T2 a1);
T6 r137cursor_off(T0* a1);
T6 r140se_assigned_from(T0* a1);
T0* r140make(T2 a1);
T6 r140conforms_to(T140* C,T0* a1);
T0* r140resize(T0* a1,T2 a2);
T0* r140twin(T140* C);
void r122copy(T122* C,T0* a1);
void r122put(T122* C,T0* a1);
T0* r122item(T122* C);
T6 r122se_assigned_from(T0* a1);
T0* r122clone(T0* a1);
void r122make(T122* C,T2 a1);
void r122remove(T122* C);
T6 r122conforms_to(T122* C,T0* a1);
T0* r122twin(T122* C);
T6 r122is_full(T122* C);
void r45yy_refill_input_buffer(T45* C);
T0* r45text_substring(T45* C,T2 a1,T2 a2);
extern T0*oBC23string_;
void r45yy_build_tables(T45* C);
extern T0*oBC47yy_meta_template;
extern int fBC47yy_meta_template;
T0* r45yy_meta_template(void);
T6 r45syntax_error(T45* C);
extern T0*oBC45yycheck_template;
extern int fBC45yycheck_template;
T0* r45yycheck_template(void);
void r45yy_set_beginning_of_line(T45* C);
extern T0*oBC47yy_accept_template;
extern int fBC47yy_accept_template;
T0* r45yy_accept_template(void);
void r45read_token(T45* C);
extern T0*oBC47yy_base_template;
extern int fBC47yy_base_template;
T0* r45yy_base_template(void);
void r45yy_build_parser_tables(T45* C);
T6 r45se_assigned_from(T0* a1);
extern T0*oBC45yytable_template;
extern int fBC45yytable_template;
T0* r45yytable_template(void);
void r45set_input_buffer(T45* C,T0* a1);
extern T0*oBC56empty_buffer;
extern int fBC56empty_buffer;
T0* r45empty_buffer(void);
extern T0*oBC46execution_environment;
void r45make_gepp_scanner(T45* C);
T0* r45yyfixed_array(T0* a1);
void r45process_include(T45* C,T0* a1);
T2 r45yy_null_trans_state(T45* C,T2 a1);
extern T0*oBC45yypgoto_template;
extern int fBC45yypgoto_template;
T0* r45yypgoto_template(void);
extern T0*oBC14std;
void r45output(T45* C,T0* a1);
void r45yy_set_content(T45* C,T0* a1);
extern T0*oBC47yy_nxt_template;
extern int fBC47yy_nxt_template;
T0* r45yy_nxt_template(void);
void r45make(T45* C,T0* a1);
extern T0*oBC47yy_chk_template;
extern int fBC47yy_chk_template;
T0* r45yy_chk_template(void);
void r45fatal_error(T0* a1);
extern T0*oBC45yypact_template;
extern int fBC45yypact_template;
T0* r45yypact_template(void);
void r45echo(T45* C);
void r45make_parser_skeleton(T45* C);
extern T0*oBC45yydefact_template;
extern int fBC45yydefact_template;
T0* r45yydefact_template(void);
extern T0*oBC47yy_def_template;
extern int fBC47yy_def_template;
T0* r45yy_def_template(void);
T6 r45conforms_to(T45* C,T0* a1);
T0* r45yytype1(T0* a1);
void r45yy_clear_all(T45* C);
T6 r45yytype2(T0* a1);
extern T0*oBC47yy_ec_template;
extern int fBC47yy_ec_template;
T0* r45yy_ec_template(void);
void r45make_with_buffer(T45* C,T0* a1);
void r45yy_execute_action(T45* C,T2 a1);
void r45set_start_condition(T45* C,T2 a1);
void r45yy_initialize(T45* C);
T2 r45yy_at_beginning_of_line(T45* C);
void r45parse_file(T45* C,T0* a1);
extern T0*oBC45yyr1_template;
extern int fBC45yyr1_template;
T0* r45yyr1_template(void);
void r45parse(T45* C);
T0* r45twin(T45* C);
void r45yy_do_action(T45* C,T2 a1);
void r45yy_load_input_buffer(T45* C);
extern T0*oBC45yytranslate_template;
extern int fBC45yytranslate_template;
T0* r45yytranslate_template(void);
T0* r45yy_fixed_array(T0* a1);
T0* r45text(T45* C);
T2 r45text_count(T45* C);
T2 r45yy_previous_state(T45* C);
T6 r45wrap(T45* C);
T2 r45yy_translate(T45* C,T2 a1);
void r45report_error(T45* C,T0* a1);
extern T0*oBC45yyr2_template;
extern int fBC45yyr2_template;
T0* r45yyr2_template(void);
extern T0*oBC45yydefgoto_template;
extern int fBC45yydefgoto_template;
T0* r45yydefgoto_template(void);
T0* r45new_file_buffer(T0* a1);
T3 r45text_item(T45* C,T2 a1);
void r45clear_stacks(T45* C);
T6 r33is_closed(T33* C);
void r33old_close(T33* C);
T2 r33read_to_string(T33* C,T0* a1,T2 a2,T2 a3);
void r33open_read(T33* C);
T6 r33se_assigned_from(T0* a1);
void r33old_read_character(T33* C);
T6 r33old_end_of_file(T33* C);
void r33read_character(T33* C);
void r33close(T33* C);
void r33make(T33* C,T0* a1);
T6 r33conforms_to(T33* C,T0* a1);
void r33connect_to(T33* C,T0* a1);
T0* r33twin(T33* C);
void r33old_open_read(T33* C);
extern T0*oBC12arguments;
extern int fBC12arguments;
T0* r181arguments(void);
T6 r181se_assigned_from(T0* a1);
void r181make(T181* C,T0* a1);
T0* r181message(T181* C,T0* a1);
T6 r181conforms_to(T181* C,T0* a1);
T0* r181twin(T181* C);
T0* r181default_message(T181* C);
T0* r167current_working_directory(T167* C);
T2 r167read_to_string(T167* C,T0* a1,T2 a2,T2 a3);
T6 r167se_assigned_from(T0* a1);
void r167old_read_character(T167* C);
T0* r167clone(T0* a1);
extern T6 oBC111is_windows;
extern int fBC111is_windows;
T6 r167is_windows(T167* C);
T6 r167old_end_of_file(T167* C);
void r167read_character(T167* C);
void r167make(T167* C);
T6 r167conforms_to(T167* C,T0* a1);
extern T6 oBC111is_unix;
extern int fBC111is_unix;
T6 r167is_unix(T167* C);
T0* r167twin(T167* C);
T6 r83se_assigned_from(T0* a1);
T0* r83message(T0* a1);
T6 r83conforms_to(T83* C,T0* a1);
T0* r83twin(T83* C);
void r83report_info_message(T83* C,T0* a1);
void r83make_standard(T83* C);
void r83report_error_message(T83* C,T0* a1);
T0* r105substring(T105* C,T2 a1,T2 a2);
void r105fill_from_string(T105* C,T0* a1,T2 a2);
T2 r105fill_from_stream(T105* C,T0* a1,T2 a2,T2 a3);
T6 r105se_assigned_from(T0* a1);
void r105move_left(T105* C,T2 a1,T2 a2,T2 a3);
void r105make(T105* C,T2 a1);
T6 r105conforms_to(T105* C,T0* a1);
void r105resize(T105* C,T2 a1);
T0* r105twin(T105* C);
extern T0*oBC24unix_file_system;
T6 r17is_closed(T17* C);
void r17old_close(T17* C);
extern T0*oBC24file_system;
extern int fBC24file_system;
T0* r17file_system(void);
T6 r17se_assigned_from(T0* a1);
void r17old_open_write(T17* C);
void r17close(T17* C);
void r17make(T17* C,T0* a1);
extern T0*oBC25operating_system;
void r17old_put_string(T17* C,T0* a1);
T6 r17conforms_to(T17* C,T0* a1);
void r17connect_to(T17* C,T0* a1);
void r17put_line(T17* C,T0* a1);
void r17recursive_open_write(T17* C);
T0* r17twin(T17* C);
void r17open_write(T17* C);
extern T0*oBC24windows_file_system;
T0* r180arguments(void);
T6 r180se_assigned_from(T0* a1);
void r180make(T180* C,T0* a1);
T0* r180message(T180* C,T0* a1);
T6 r180conforms_to(T180* C,T0* a1);
T0* r180twin(T180* C);
T0* r180default_message(T180* C);
T6 r175se_assigned_from(T0* a1);
T0* r175dirname(T0* a1);
T6 r175conforms_to(T175* C,T0* a1);
T0* r175string_to_pathname(T0* a1);
extern T0*oBC175root_directory;
T6 r175is_root_directory(T0* a1);
T0* r175pathname_to_string(T0* a1);
T0* r175twin(T175* C);
T0* r175canonical_pathname(T0* a1);
T0* r169arguments(void);
T6 r169se_assigned_from(T0* a1);
void r169make(T169* C,T0* a1);
T0* r169message(T169* C,T0* a1);
T6 r169conforms_to(T169* C,T0* a1);
T0* r169twin(T169* C);
T0* r169default_message(T169* C);
T6 r170is_closed(T170* C);
void r170open_read(T170* C);
T0* r170file_system(void);
T6 r170se_assigned_from(T0* a1);
void r170create_directory(T170* C);
T6 r170is_open_read(T170* C);
void r170close(T170* C);
void r170make(T170* C,T0* a1);
T6 r170exists(T170* C);
void r170recursive_create_directory(T170* C);
T6 r170conforms_to(T170* C,T0* a1);
T0* r170twin(T170* C);
T6 r170is_readable(T170* C);
void r80set_position(T80* C,T2 a1,T2 a2,T2 a3);
T6 r80se_assigned_from(T0* a1);
void r80make(T80* C,T0* a1);
T6 r80conforms_to(T80* C,T0* a1);
void r80make_from_buffer(T80* C,T0* a1);
T0* r80twin(T80* C);
T0* r161arguments(void);
T6 r161se_assigned_from(T0* a1);
void r161make(T161* C,T2 a1);
T0* r161message(T161* C,T0* a1);
T6 r161conforms_to(T161* C,T0* a1);
T0* r161twin(T161* C);
T0* r161default_message(T161* C);
T0* r162arguments(void);
T6 r162se_assigned_from(T0* a1);
void r162make(T162* C,T0* a1);
T0* r162message(T162* C,T0* a1);
T6 r162conforms_to(T162* C,T0* a1);
T0* r162twin(T162* C);
T0* r162default_message(T162* C);
void r88copy(T88* C,T0* a1);
T0* r88substring(T88* C,T2 a1,T2 a2);
void r88reset_byte_index_cache(T88* C);
void r88wipe_out(T88* C);
T6 r88same_unicode_string(T88* C,T0* a1);
T2 r88item_code(T88* C,T2 a1);
T3 r88character_item_at_byte_index(T88* C,T2 a1);
void r88put(T88* C,T3 a1,T2 a2);
T6 r88is_equal(T88* C,T0* a1);
T3 r88item(T88* C,T2 a1);
extern T0*oBC50integer_;
void r88resize_byte_storage(T88* C,T2 a1);
void r88append(T88* C,T0* a1);
T6 r88se_assigned_from(T0* a1);
T2 r88byte_index(T88* C,T2 a1);
T0* r88clone(T0* a1);
void r88move_bytes_right(T88* C,T2 a1,T2 a2);
void r88set_count(T88* C,T2 a1);
T2 r88next_byte_index(T88* C,T2 a1);
T6 r88same_type(T88* C,T0* a1);
void r88remove_tail(T88* C,T2 a1);
void r88make(T88* C,T2 a1);
void r88old_make_filled(T88* C,T3 a1,T2 a2);
void r88append_substring(T88* C,T0* a1,T2 a2,T2 a3);
T2 r88item_code_at_byte_index(T88* C,T2 a1);
extern T0*oBC51platform;
T0* r88string(T88* C);
void r88extend(T88* C,T3 a1);
T0* r88_px_43(T88* C,T0* a1);
T2 r88hash_code(T88* C);
T0* r88prefixed_string(T88* C,T0* a1);
T6 r88conforms_to(T88* C,T0* a1);
void r88keep_head(T88* C,T2 a1);
T2 r88to_integer(T88* C);
T0* r88new_empty_string(T2 a1);
void r88append_character(T88* C,T3 a1);
void r88make_from_substring(T88* C,T0* a1,T2 a2,T2 a3);
void r88put_code_at_byte_index(T88* C,T2 a1,T2 a2,T2 a3);
void r88fill_with(T88* C,T3 a1);
void r88put_character_at_byte_index(T88* C,T3 a1,T2 a2,T2 a3);
void r88resize(T88* C,T2 a1);
void r88put_substring_at_byte_index(T88* C,T0* a1,T2 a2,T2 a3,T2 a4,T2 a5);
T2 r88substring_index(T88* C,T0* a1,T2 a2);
extern T0*oBC90utf8;
void r88from_external_copy(T88* C,T8 a1);
void r88move_bytes_left(T88* C,T2 a1,T2 a2);
void r88old_make(T88* C,T2 a1);
T8 r88to_external(T88* C);
void r88old_make_from_string(T88* C,T0* a1);
T0* r88twin(T88* C);
T0* r88to_utf8(T88* C);
T2 r88unicode_substring_index(T88* C,T0* a1,T2 a2);
void r88swap(T88* C,T2 a1,T2 a2);
void r79fill(T79* C);
void r79compact_left(T79* C);
void r79set_position(T79* C,T2 a1,T2 a2,T2 a3);
T6 r79se_assigned_from(T0* a1);
void r79make_from_string(T79* C,T0* a1);
T6 r79conforms_to(T79* C,T0* a1);
void r79make_from_buffer(T79* C,T0* a1);
void r79resize(T79* C);
void r79make_with_size(T79* C,T0* a1,T2 a2);
T0* r79twin(T79* C);
void r79set_file(T79* C,T0* a1);
void r79flush(T79* C);
T0* r178current_working_directory(T178* C);
T6 r178se_assigned_from(T0* a1);
T0* r178clone(T0* a1);
T6 r178is_windows(T178* C);
void r178make(T178* C);
void r178old_put_string(T0* a1);
T6 r178conforms_to(T178* C,T0* a1);
T6 r178is_unix(T178* C);
void r178put_line(T0* a1);
T0* r178twin(T178* C);
void r178put_string(T0* a1);
T0* r109current_working_directory(T109* C);
T6 r109se_assigned_from(T0* a1);
T0* r109clone(T0* a1);
T6 r109is_windows(T109* C);
void r109make(T109* C);
void r109old_put_string(T0* a1);
T6 r109conforms_to(T109* C,T0* a1);
T6 r109is_unix(T109* C);
void r109put_line(T0* a1);
T0* r109twin(T109* C);
void r109put_string(T0* a1);
T6 r176se_assigned_from(T0* a1);
T0* r176dirname(T0* a1);
T6 r176conforms_to(T176* C,T0* a1);
T0* r176string_to_pathname(T0* a1);
extern T0*oBC176root_directory;
T6 r176is_root_directory(T0* a1);
T0* r176pathname_to_string(T0* a1);
T0* r176twin(T176* C);
T0* r176canonical_pathname(T0* a1);
void r188copy(T188* C,T0* a1);
void r188append_name(T188* C,T0* a1);
T6 r188se_assigned_from(T0* a1);
T0* r188clone(T0* a1);
T6 r188is_parent(T188* C,T2 a1);
void r188make(T188* C);
void r188set_canonical(T188* C);
T6 r188conforms_to(T188* C,T0* a1);
T0* r188twin(T188* C);
T6 r188is_current(T188* C,T2 a1);
T0* r81arguments(void);
T6 r81se_assigned_from(T0* a1);
void r81make(T81* C,T0* a1,T2 a2);
T0* r81message(T81* C,T0* a1);
T6 r81conforms_to(T81* C,T0* a1);
T0* r81twin(T81* C);
T0* r81default_message(T81* C);
extern T0*oBC1command_arguments;
extern int fBC1command_arguments;
T0* r101command_arguments(void);
T6 r101se_assigned_from(T0* a1);
T6 r101conforms_to(T101* C,T0* a1);
T0* r101twin(T101* C);
T0* r101argument(T2 a1);
extern T0*oBC108error;
extern int fBC108error;
T0* r108error(void);
T6 r108se_assigned_from(T0* a1);
extern T0*oBC108input;
extern int fBC108input;
T0* r108input(void);
extern T0*oBC108output;
extern int fBC108output;
T0* r108output(void);
T6 r108conforms_to(T108* C,T0* a1);
T0* r108twin(T108* C);
extern T2 oBC112maximum_character_code;
extern int fBC112maximum_character_code;
T2 r112maximum_character_code(T112* C);
T6 r112se_assigned_from(T0* a1);
T6 r112conforms_to(T112* C,T0* a1);
T0* r112twin(T112* C);
T6 r63se_assigned_from(T0* a1);
T6 r63conforms_to(T63* C,T0* a1);
T0* r63twin(T63* C);
T6 r60se_assigned_from(T0* a1);
T6 r60conforms_to(T60* C,T0* a1);
T0* r60twin(T60* C);
T6 r43se_assigned_from(T0* a1);
T6 r43conforms_to(T43* C,T0* a1);
T0* r43twin(T43* C);
T2 r97encoded_next_value(T3 a1);
T2 r97character_byte_count(T3 a1);
T6 r97se_assigned_from(T0* a1);
T2 r97encoded_first_value(T3 a1);
T6 r97conforms_to(T97* C,T0* a1);
T2 r97code_byte_count(T2 a1);
T2 r97encoded_byte_count(T3 a1);
T0* r97twin(T97* C);
T2 r97substring_byte_count(T0* a1,T2 a2,T2 a3);
T6 r96se_assigned_from(T0* a1);
T6 r96conforms_to(T96* C,T0* a1);
T3 r96to_character(T2 a1);
T0* r96twin(T96* C);
T6 r194se_assigned_from(T0* a1);
T6 r194conforms_to(T194* C,T0* a1);
T0* r194twin(T194* C);
void r11preprocess(T11* C);
T0* r11arguments(void);
void r11read_arguments(T11* C);
T6 r11se_assigned_from(T0* a1);
void r11report_cannot_read_error(T11* C,T0* a1);
extern T0*oBC11usage_message;
extern int fBC11usage_message;
T0* r11usage_message(void);
T6 r11conforms_to(T11* C,T0* a1);
extern T0*oBC13exceptions;
void r11execute(T11* C);
void r11report_version_number(T11* C);
void r11report_cannot_write_error(T11* C,T0* a1);
T0* r11twin(T11* C);
T6 r42se_assigned_from(T0* a1);
T6 r42conforms_to(T42* C,T0* a1);
T0* r42twin(T42* C);
T0* r166get_environment_variable(T0* a1);
T6 r193se_assigned_from(T0* a1);
T6 r193conforms_to(T193* C,T0* a1);
T0* r193twin(T193* C);
void r172connect_to_current_working_directory(T172* C);
void r172disconnect(T172* C);
extern T0*oBC172last_entry;
void r172connect_to(T172* C,T0* a1);
T6 r172create_new_directory(T0* a1);
T0* r85as_string(T0* a1);
T6 r85se_assigned_from(T0* a1);
T0* r85clone(T0* a1);
T0* r85appended_string(T0* a1,T0* a2);
T6 r85is_integer(T0* a1);
T0* r85make(T2 a1);
T0* r85string(T0* a1);
T6 r85conforms_to(T85* C,T0* a1);
T0* r85appended_substring(T0* a1,T0* a2,T2 a3,T2 a4);
T0* r85new_empty_string(T0* a1,T2 a2);
T0* r85concat(T0* a1,T0* a2);
T2 r85substring_index(T0* a1,T0* a2,T2 a3);
T6 r85same_string(T0* a1,T0* a2);
T0* r85twin(T85* C);
T6 r85elks_same_string(T0* a1,T0* a2);
void r85append_substring_to_string(T0* a1,T0* a2,T2 a3,T2 a4);
T0* r165variable_value(T0* a1);
T6 r165se_assigned_from(T0* a1);
extern T166 oBC165environment_impl;
T6 r165conforms_to(T165* C,T0* a1);
T0* r165interpreted_string(T0* a1);
T0* r165twin(T165* C);
T6 r65se_assigned_from(T0* a1);
T6 r65conforms_to(T65* C,T0* a1);
T0* r65twin(T65* C);
T0* r111current_working_directory(T111* C);
T6 r111se_assigned_from(T0* a1);
T0* r111clone(T0* a1);
T6 r111is_windows(T111* C);
T6 r111conforms_to(T111* C,T0* a1);
T6 r111is_unix(T111* C);
T0* r111twin(T111* C);
extern T11*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 195
void initialize_eiffel_runtime(int argc,char*argv[]);
extern T7*ms81_1449702436;
extern T7*ms15_1553;
extern T7*ms85_0;
extern T7*ms88_0;
extern T7*ms97_0;
extern T7*ms175_46;
extern T7*ms176_46;
extern T7*ms188_276;
extern T7*ms178_10;
extern T7*ms181_1158552108;
extern T7*ms21_250860571;
extern T7*ms169_1606053737;
extern T7*ms188_46;
extern T7*ms162_988446515;
extern T7*ms175_276;
extern T7*ms17_10;
extern T7*ms176_276;
extern T7*ms161_434195944;
extern T7*ms109_10;
extern T7*ms180_1515383187;
T7*se_ms(int c,char*e);
T7*se_string(char*e);
void se_msi1(void);
void*se_ma186(int argc,...);
T0* X7substring(T0*C,T2 a1,T2 a2);
void X7wipe_out(T0*C);
T2 X7item_code(T0*C,T2 a1);
void X7put(T0*C,T3 a1,T2 a2);
T6 X7is_equal(T0*C,T0* a1);
T3 X7item(T0*C,T2 a1);
void X7append(T0*C,T0* a1);
void X7set_count(T0*C,T2 a1);
T6 X7same_type(T0*C,T0* a1);
void X7remove_tail(T0*C,T2 a1);
void X7append_string(T0*C,T0* a1);
T0* X7string(T0*C);
void X7extend(T0*C,T3 a1);
T0* X7_px_43(T0*C,T0* a1);
T2 X7hash_code(T0*C);
T2 X7to_integer(T0*C);
void X7append_character(T0*C,T3 a1);
void X7resize(T0*C,T2 a1);
T2 X7substring_index(T0*C,T0* a1,T2 a2);
void X7from_external_copy(T0*C,T8 a1);
T8 X7to_external(T0*C);
T0* X7twin(T0*C);
void X7swap(T0*C,T2 a1,T2 a2);
T0* X10twin(T0*C);
T6 X1se_assigned_from(T0*C,T0* a1);
T6 X1conforms_to(T0*C,T0* a1);
void X69clear_all(T0*C,T0* a1);
T0* X69make(T0*C,T2 a1);
T0* X69resize(T0*C,T0* a1,T2 a2);
void X32put_new_line(T0*C);
void X32put_line(T0*C,T0* a1);
void X32put_string(T0*C,T0* a1);
T0* X38name(T0*C);
T2 X38read_to_string(T0*C,T0* a1,T2 a2,T2 a3);
void X38read_character(T0*C);
T6 X38end_of_input(T0*C);
T3 X38last_character(T0*C);
void X80fill(T0*C);
T2 X185count(T0*C);
T2 X185item(T0*C,T2 a1);
T2 X185lower(T0*C);
void X74put(T0*C,T0* a1,T2 a2);
T0* X74item(T0*C,T2 a1);
T75 X74storage(T0*C);
void X74set_all_with(T0*C,T0* a1);
void X74resize(T0*C,T2 a1);
void X26close(T0*C);
T0* X82default_message(T0*C);
T6 X111is_windows(T0*C);
T6 X111is_unix(T0*C);
T0* X173dirname(T0*C,T0* a1);
T0* X173canonical_pathname(T0*C,T0* a1);
T0* T2toT60(T2 source);
T2 T60toT2(T0* source);
T0* T6toT42(T6 source);

#ifdef __cplusplus
}
#endif
