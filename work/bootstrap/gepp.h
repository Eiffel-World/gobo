#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmallEiffel The GNU Eiffel Compiler
Release -0.75 (July 16th 2001)
Copyright (C), 1994-2001 - LORIA - UHP - INRIA - FRANCE
Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
http://SmallEiffel.loria.fr
*/

/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/base.h) contains all basic Eiffel
  type definitions.
  This file is automatically included in the header for all modes of 
  compilation : -boost, -no_check, -require_check, -ensure_check, ...
  This file is also included in the header of any cecil file (when the
  -cecil option is used).
  This file is also included in the header file of C++ wrappers (when
  using the external "C++" clause).
*/
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <float.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifdef WIN32
#include <windows.h>
#else
#ifndef O_RDONLY
#include <sys/file.h>
#endif
#ifndef O_RDONLY
#define O_RDONLY 0000
#endif
#endif

/* Because ANSI C EXIT_* are not always defined: */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif
#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0
#endif

/* 
   On Linux glibc systems, we need to use sig.* versions of jmp_buf,
   setjmp and longjmp to preserve the signal handling context.
   Currently, the way I figured to detect this is if _SIGSET_H_types has
   been defined in /usr/include/setjmp.h.
*/
#ifdef _SIGSET_H_types
#define JMP_BUF    sigjmp_buf
#define SETJMP(x)  sigsetjmp( (x), 1)
#define LONGJMP    siglongjmp
#else
#define JMP_BUF    jmp_buf
#define SETJMP(x)  setjmp( (x) )
#define LONGJMP    longjmp
#endif

/* 
   Type to store reference objects Id :
 */
typedef int Tid;

typedef struct S0 T0;

struct S0{
  Tid id;
};

/* 
   The default channel used to print runtime error messages :
*/
#define SE_ERR stderr

/* 
   Eiffel type INTEGER is #2 :
*/
typedef int T2;
#define EIF_INTEGER T2
#define M2 (0)
#define EIF_INTEGER_BITS (CHAR_BIT*sizeof(int))
#define EIF_MINIMUM_INTEGER (INT_MIN)
#define EIF_MAXIMUM_INTEGER (INT_MAX)

/*
  Eiffel type CHARACTER is #3 :
*/
typedef unsigned char T3;
#define EIF_CHARACTER T3
#define M3 (0)
#define EIF_CHARACTER_BITS (CHAR_BIT)
#define EIF_MINIMUM_CHARACTER_CODE (0)
#define EIF_MAXIMUM_CHARACTER_CODE (255)
#define T3code(x) ((T2)(x))
#define T3to_integer(x) ((T2)((char)(x)))
#define T3to_bit(x) (x)

/*
  Eiffel type REAL is #4 :
*/
typedef float T4;
#define EIF_REAL T4
#define M4 (0.0)
#define EIF_REAL_BITS (CHAR_BIT*sizeof(float))
#define EIF_MINIMUM_REAL (-(FLT_MAX))
#define EIF_MAXIMUM_REAL (FLT_MAX)
#define T2toT4(x) ((T4)(x))

/*
  Eiffel type DOUBLE is #5 :
*/
typedef double T5;
#define EIF_DOUBLE T5
#define M5 (0.0)
#define EIF_DOUBLE_BITS (CHAR_BIT*sizeof(double))
#define EIF_MINIMUM_DOUBLE (-(DBL_MAX))
#define EIF_MAXIMUM_DOUBLE (DBL_MAX)
#define T2toT5(x) ((T5)(x))
#define T4toT5(x) ((T5)(x))

/*
  Eiffel type BOOLEAN is #6 :
*/
typedef char T6;
#define EIF_BOOLEAN T6
#define M6 (0)
#define EIF_BOOLEAN_BITS (CHAR_BIT)

/* 
   Eiffel type POINTER is #8 :
*/
typedef void* T8;
#define EIF_POINTER T8
#define M8 (NULL)
#define EIF_POINTER_BITS (CHAR_BIT*sizeof(void*))

/*
  To use type STRING on the C side :
*/
#define EIF_STRING T7*

/*
  Some Other EIF_* defined in ETL :
*/
#define eif_access(x) ((char*)(x))
#define EIF_REFERENCE T0*
#define EIF_OBJ T0*
#define EIF_OBJECT EIF_OBJ

/* 
   Wrappers for `malloc', `calloc' and `realloc' :
*/
void* se_malloc(size_t size);
void* se_calloc(size_t nmemb, size_t size);
void* se_realloc(void *ptr, size_t size);

/*C Header Pass 1 :*/
typedef struct S32 T32;
typedef struct S148 T148;
typedef struct S57 T57;
typedef struct S152 T152;
typedef struct S52 T52;
typedef struct S75 T75;
typedef struct S68 T68;
typedef struct S105 T105;
typedef struct S138 T138;
typedef struct S58 T58;
typedef struct S78 T78;
typedef struct S49 T49;
typedef struct S149 T149;
typedef struct S29 T29;
typedef struct S30 T30;
typedef struct S147 T147;
typedef struct S17 T17;
typedef struct S102 T102;
typedef struct S144 T144;
typedef struct S28 T28;
typedef struct S85 T85;
typedef struct S7 T7;
typedef struct S88 T88;
typedef struct S87 T87;
typedef struct S27 T27;
typedef struct S79 T79;
typedef struct S141 T141;
typedef struct S142 T142;
typedef struct S71 T71;
typedef struct S117 T117;
typedef struct S143 T143;
typedef struct S74 T74;
typedef struct S145 T145;
typedef struct S89 T89;
typedef struct S120 T120;
typedef struct S81 T81;
typedef struct S69 T69;
typedef struct S54 T54;
typedef struct S123 T123;
typedef struct S107 T107;
typedef struct S101 T101;
typedef struct S76 T76;
typedef struct S83 T83;

/*C Header Pass 2 :*/
typedef T0**T104;
typedef T0**T82;
typedef T3*T9;
typedef T2*T73;
typedef T0**T70;

/*C Header Pass 3 :*/

/*C Header Pass 4 :*/
struct S32{Tid id;T2 _error_count;T0* _yytranslate;T0* _yyr1;T0* _yyr2;T0* _yydefact;T0* _yydefgoto;T0* _yypact;T0* _yypgoto;T0* _yytable;T0* _yycheck;T0* _yyvs;T0* _yyss;T2 _yyvsp;T2 _yyssp;T0* _yyval;T6 _yy_lookahead_needed;T2 _yyerrstatus;T2 _yy_parsing_status;T0* _FIXED_ARRAY_;T2 _last_token;T0* _input_buffer;T2 _line;T2 _column;T2 _position;T2 _yy_start_state;T0* _yy_content;T2 _yy_end;T2 _yy_start;T2 _yy_line;T2 _yy_column;T2 _yy_position;T6 _yy_more_flag;T2 _yy_more_len;T2 _yy_last_accepting_state;T2 _yy_last_accepting_cpos;T0* _yy_nxt;T0* _yy_chk;T0* _yy_base;T0* _yy_def;T0* _yy_ec;T0* _yy_meta;T0* _yy_accept;T0* _yy_acclist;T6 _yy_rejected;T0* _yy_state_stack;T2 _yy_state_count;T2 _yy_full_match;T2 _yy_lp;T2 _yy_looking_for_trail_begin;T2 _yy_full_lp;T2 _yy_full_state;T2 _line_nb;T0* _last_value;T0* _output_file;T0* _error_handler;T6 _makefile_dependencies;T0* _defined_values;T2 _if_level;T2 _ignored_level;T0* _include_stack;};
extern T32 M32;
struct S148{Tid id;T0* _parameters;};
extern T148 M148;
struct S57{Tid id;};
extern T57 M57;
struct S152{Tid id;T73 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T152 M152;
struct S52{Tid id;};
extern T52 M52;
struct S68{Tid id;};
extern T68 M68;
struct S105{Tid id;};
extern T105 M105;
struct S138{Tid id;T2 _position;T0* _container;T0* _next_cursor;};
extern T138 M138;
struct S58{Tid id;T6 _push_back_flag;T2 _memory;T0* _name;};
extern T58 M58;
struct S78{Tid id;T0* _error_file;T0* _warning_file;T0* _message_file;};
extern T78 M78;
struct S49{Tid id;T2 _item;};
extern T49 M49;
struct S149{Tid id;};
extern T149 M149;
struct S29{Tid id;T0* _path;T8 _output_stream;};
extern T29 M29;
struct S30{Tid id;T8 _item;};
extern T30 M30;
struct S147{Tid id;T0* _parameters;};
extern T147 M147;
struct S17{Tid id;T0* _in_filename;T0* _out_filename;T0* _parser;T0* _error_handler;};
extern T17 M17;
struct S102{Tid id;T104 _storage;T2 _capacity;T2 _upper;};
extern T102 M102;
struct S144{Tid id;T0* _parameters;};
extern T144 M144;
struct S28{Tid id;T6 _item;};
extern T28 M28;
struct S85{Tid id;T82 _storage;T2 _capacity;T2 _upper;};
extern T85 M85;
struct S7{Tid id;T9 _storage;T2 _count;T2 _capacity;};
extern T7 M7;
struct S88{Tid id;T6 _push_back_flag;T0* _path;T8 _input_stream;T2 _memory;};
extern T88 M88;
struct S75{Tid id;T0* _content;T2 _capacity;T2 _position;T2 _column;T2 _line;T2 _index;T2 _upper;T6 _beginning_of_line;T6 _filled;};
extern T75 M75;
struct S87{Tid id;};
extern T87 M87;
struct S27{Tid id;};
extern T27 M27;
struct S79{Tid id;};
extern T79 M79;
struct S141{Tid id;T0* _parameters;};
extern T141 M141;
struct S142{Tid id;T0* _parameters;};
extern T142 M142;
struct S71{Tid id;T73 _storage;T2 _capacity;T2 _upper;};
extern T71 M71;
struct S117{Tid id;T0* _equality_tester;T0* _key_equality_tester;T2 _count;T2 _capacity;T2 _last_position;T2 _modulus;T2 _free_slot;T2 _position;T2 _slots_position;T2 _clashes_previous_position;T2 _found_position;T0* _internal_cursor;T0* _items;T0* _keys;T0* _clashes;T0* _slots;T0* _FIXED_ITEM_ARRAY_;T0* _FIXED_KEY_ARRAY_;};
extern T117 M117;
struct S143{Tid id;};
extern T143 M143;
struct S74{Tid id;T0* _content;T2 _capacity;T2 _position;T2 _column;T2 _line;T2 _index;T2 _upper;T6 _beginning_of_line;T6 _filled;T6 _interactive;T0* _file;T6 _end_of_file;};
extern T74 M74;
struct S145{Tid id;T0* _name;};
extern T145 M145;
struct S89{Tid id;T0* _name;};
extern T89 M89;
struct S120{Tid id;};
extern T120 M120;
struct S81{Tid id;T82 _storage;T2 _capacity;T2 _upper;T2 _lower;};
extern T81 M81;
struct S69{Tid id;T70 _storage;T2 _capacity;T2 _upper;};
extern T69 M69;
struct S54{Tid id;T3 _item;};
extern T54 M54;
struct S123{Tid id;};
extern T123 M123;
struct S107{Tid id;};
extern T107 M107;
struct S101{Tid id;T2 _count;T2 _capacity;T0* _storage;T0* _FIXED_ARRAY_;};
extern T101 M101;
struct S76{Tid id;T0* _parameters;};
extern T76 M76;
struct S83{Tid id;T0* _program_name;};
extern T83 M83;
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/

/*
  This file (SmallEiffel/sys/runtime/boost.h) is automatically included when
  `run_control.boost' is true (ie. only for mode -boost).
*/
#define SE_BOOST 1
void se_print_run_time_stack (void);
void se_signal_handler(int sig);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_getenv.h) is automatically 
  included when the GENERAL.basic_getenv feature is used (ie. in live code).
*/

EIF_POINTER basic_getenv(EIF_POINTER name);
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/exception.h) is automatically included 
  when exception handling is used somewhere in the live code.
*/

#define SE_EXCEPTIONS 1

/*
  Constants from Eiffel class EXCEPTIONS :
*/
#define Check_instruction 	  1
#define Class_invariant 	  2
#define Developer_exception 	  3
#define Incorrect_inspect_value   4
#define Loop_invariant 		  5
#define Loop_variant 		  6
#define No_more_memory  	  7
#define Postcondition 		  8
#define Precondition  		  9
#define Routine_failure  	  10
#define	Os_signal		  11
#define Void_attached_to_expanded 12
#define Void_call_target 	  13
#define System_level_type_error	  14

/* 
   This will be the structure of rescue contexts.  A rescue context 
   will be declared for every routine that has a rescue clause.

   The `next' pointer is the address of the next rescue context if there
   is one higher up the call chain, or NULL if there is no other
   context.
*/
struct rescue_context {
  JMP_BUF jb;
#ifdef SE_NO_CHECK
  /* To keep track of dump stack to unwind it safely
     before the LONGJMP :
  */
  struct _se_dump_stack * top_of_ds ;
#endif
  struct rescue_context *next;
};

extern struct rescue_context *rescue_context_top;
extern int internal_exception_number;
extern int original_internal_exception_number;
extern int signal_exception_number;
extern char *additional_error_message;

void setup_signal_handler(void);
void signal_exception_handler(int);
void internal_exception_handler(int);
void print_exception(void);
T6 r6_ix_not(T6 C);
T6 r6_px_or(T6 C,T6 a1);
T6 r6_px_and(T6 C,T6 a1);
T6 r3_px_6061(T3 C,T3 a1);
T6 r3is_digit(T3 C);
T6 r3is_separator(T3 C);
T6 r3_px_6261(T3 C,T3 a1);
T2 r3value(T3 C);
T2 r3decimal_value(T3 C);
T0* r2out(T2 C);
T3 r2digit(T2 C);
void r2append_in(T2 C,T0* a1);
extern T0*oBC1tagged_out_memory;
T104 r104realloc(T104 C,T2 a1,T2 a2);
void r104set_all_with(T104 C,T0* a1,T2 a2);
void r104clear(T104 C,T2 a1,T2 a2);
void r104copy_from(T104 C,T104 a1,T2 a2);
T82 r82realloc(T82 C,T2 a1,T2 a2);
void r82set_all_with(T82 C,T0* a1,T2 a2);
void r82clear(T82 C,T2 a1,T2 a2);
void r82copy_from(T82 C,T82 a1,T2 a2);
void r9copy_slice(T9 C,T2 a1,T9 a2,T2 a3,T2 a4);
T9 r9realloc(T9 C,T2 a1,T2 a2);
void r9set_all_with(T9 C,T3 a1,T2 a2);
T6 r9fast_memcmp(T9 C,T9 a1,T2 a2);
void r9copy_at(T9 C,T2 a1,T9 a2,T2 a3);
void r9copy_from(T9 C,T9 a1,T2 a2);
T73 r73realloc(T73 C,T2 a1,T2 a2);
void r73set_all_with(T73 C,T2 a1,T2 a2);
void r73clear(T73 C,T2 a1,T2 a2);
void r73copy_from(T73 C,T73 a1,T2 a2);
T70 r70realloc(T70 C,T2 a1,T2 a2);
void r70set_all_with(T70 C,T0* a1,T2 a2);
void r70clear(T70 C,T2 a1,T2 a2);
void r70copy_from(T70 C,T70 a1,T2 a2);
void r7copy(T7* C,T0* a1);
T0* r7substring(T7* C,T2 a1,T2 a2);
T6 r7is_equal(T7* C,T0* a1);
T6 r7is_integer(T7* C);
void r7make(T7* C,T2 a1);
void r7append_string(T7* C,T0* a1);
void r7make_filled(T7* C,T3 a1,T2 a2);
void r7extend(T7* C,T3 a1);
T2 r7hash_code(T7* C);
T2 r7to_integer(T7* C);
void r7append_character(T7* C,T3 a1);
void r7from_external_copy(T7* C,T8 a1);
T8 r7to_external(T7* C);
T0* r7twin(T7* C);
void r7swap(T7* C,T2 a1,T2 a2);
T2 r152count(T152* C);
T2 r152item(T152* C,T2 a1);
void r102make(T102* C,T2 a1);
void r102resize(T102* C,T2 a1);
void r85make(T85* C,T2 a1);
void r85resize(T85* C,T2 a1);
void r71make(T71* C,T2 a1);
void r71resize(T71* C,T2 a1);
void r71with_capacity(T71* C,T2 a1);
void r71from_collection(T71* C,T0* a1);
T0* r81item(T81* C,T2 a1);
T6 r81valid_index(T81* C,T2 a1);
void r81make(T81* C,T2 a1,T2 a2);
T2 r69count(T69* C);
T0* r69item(T69* C,T2 a1);
void r69make(T69* C,T2 a1);
void r69resize(T69* C,T2 a1);
void r68clear_all(T0* a1);
T0* r68make(T2 a1);
T0* r68resize(T0* a1,T2 a2);
T0* r105to_fixed_array(T0* a1);
T0* r105make(T2 a1);
T0* r105make_from_array(T0* a1);
T0* r105resize(T0* a1,T2 a2);
void r138make(T138* C,T0* a1);
T0* r149make(T2 a1);
T0* r149resize(T0* a1,T2 a2);
T2 r117new_capacity(T2 a1);
void r117force(T117* C,T0* a1,T0* a2);
void r117make_clashes(T117* C,T2 a1);
void r117search_position(T117* C,T0* a1);
extern T0*oBC43FIXED_INTEGER_ARRAY_;
void r117keys_resize(T117* C,T2 a1);
void r117make_items(T117* C,T2 a1);
void r117remove_position(T117* C,T2 a1);
void r117make(T117* C,T2 a1);
void r117remove(T117* C,T0* a1);
T6 r117has(T117* C,T0* a1);
void r117make_keys(T117* C,T2 a1);
T2 r117hash_position(T117* C,T0* a1);
void r117items_resize(T117* C,T2 a1);
void r117make_with_equality_testers(T117* C,T2 a1,T0* a2,T0* a3);
void r117move_cursors_after(T117* C,T2 a1);
void r117resize(T117* C,T2 a1);
void r117move_cursors_forth(T117* C,T2 a1);
void r117clashes_resize(T117* C,T2 a1);
void r117slots_resize(T117* C,T2 a1);
T0* r117new_cursor(T117* C);
void r117make_slots(T117* C,T2 a1);
void r117move_all_cursors(T117* C,T2 a1,T2 a2);
T2 r117new_modulus(T2 a1);
T0* r120make(T2 a1);
T0* r120resize(T0* a1,T2 a2);
T6 r123test(T0* a1,T0* a2);
void r101put(T101* C,T0* a1);
T0* r101item(T101* C);
void r101make(T101* C,T2 a1);
void r101remove(T101* C);
T6 r101is_full(T101* C);
void r32yy_refill_input_buffer(T32* C);
T0* r32text_substring(T32* C,T2 a1,T2 a2);
void r32yy_build_tables(T32* C);
extern T0*oBC35yy_meta_template;
extern int fBC35yy_meta_template;
T0* r32yy_meta_template(void);
T6 r32syntax_error(T32* C);
extern T0*oBC32yycheck_template;
extern int fBC32yycheck_template;
T0* r32yycheck_template(void);
void r32yy_set_beginning_of_line(T32* C);
extern T0*oBC35yy_accept_template;
extern int fBC35yy_accept_template;
T0* r32yy_accept_template(void);
void r32read_token(T32* C);
extern T0*oBC35yy_base_template;
extern int fBC35yy_base_template;
T0* r32yy_base_template(void);
void r32yy_build_parser_tables(T32* C);
extern T0*oBC32yytable_template;
extern int fBC32yytable_template;
T0* r32yytable_template(void);
void r32set_input_buffer(T32* C,T0* a1);
void r32make_gepp_scanner(T32* C);
T0* r32yyfixed_array(T0* a1);
void r32process_include(T32* C,T0* a1);
T2 r32yy_null_trans_state(T32* C,T2 a1);
extern T0*oBC32yypgoto_template;
extern int fBC32yypgoto_template;
T0* r32yypgoto_template(void);
extern T0*oBC45Empty_buffer;
extern int fBC45Empty_buffer;
T0* r32Empty_buffer(void);
extern T0*oBC20std;
void r32output(T32* C,T0* a1);
void r32yy_set_content(T32* C,T0* a1);
extern T0*oBC35yy_nxt_template;
extern int fBC35yy_nxt_template;
T0* r32yy_nxt_template(void);
void r32make(T32* C,T0* a1);
extern T0*oBC35yy_chk_template;
extern int fBC35yy_chk_template;
T0* r32yy_chk_template(void);
void r32fatal_error(T0* a1);
extern T0*oBC34Execution_environment;
extern T0*oBC32yypact_template;
extern int fBC32yypact_template;
T0* r32yypact_template(void);
void r32echo(T32* C);
void r32make_parser_skeleton(T32* C);
extern T0*oBC44STRING_BUFFER_;
extern T0*oBC32yydefact_template;
extern int fBC32yydefact_template;
T0* r32yydefact_template(void);
extern T0*oBC35yy_def_template;
extern int fBC35yy_def_template;
T0* r32yy_def_template(void);
T0* r32yytype1(T0* a1);
void r32yy_clear_all(T32* C);
T6 r32yytype2(T0* a1);
extern T0*oBC35yy_ec_template;
extern int fBC35yy_ec_template;
T0* r32yy_ec_template(void);
void r32make_with_buffer(T32* C,T0* a1);
void r32yy_execute_action(T32* C,T2 a1);
void r32set_start_condition(T32* C,T2 a1);
void r32yy_initialize(T32* C);
T2 r32yy_at_beginning_of_line(T32* C);
void r32parse_file(T32* C,T0* a1);
extern T0*oBC32yyr1_template;
extern int fBC32yyr1_template;
T0* r32yyr1_template(void);
void r32parse(T32* C);
void r32yy_do_action(T32* C,T2 a1);
void r32yy_load_input_buffer(T32* C);
extern T0*oBC32yytranslate_template;
extern int fBC32yytranslate_template;
T0* r32yytranslate_template(void);
T0* r32yy_fixed_array(T0* a1);
extern T0*oBC22INPUT_STREAM_;
T0* r32text(T32* C);
T2 r32text_count(T32* C);
T2 r32yy_previous_state(T32* C);
T6 r32wrap(T32* C);
T2 r32yy_translate(T32* C,T2 a1);
void r32report_error(T32* C,T0* a1);
extern T0*oBC32yyr2_template;
extern int fBC32yyr2_template;
T0* r32yyr2_template(void);
extern T0*oBC32yydefgoto_template;
extern int fBC32yydefgoto_template;
T0* r32yydefgoto_template(void);
T0* r32new_file_buffer(T0* a1);
T3 r32text_item(T32* C,T2 a1);
void r32clear_stacks(T32* C);
extern T0*oBC18Arguments;
extern int fBC18Arguments;
T0* r148Arguments(void);
void r148make(T148* C,T0* a1);
T0* r148message(T148* C,T0* a1);
T0* r148default_message(T148* C);
extern T0*oBC33STRING_;
void r58read_character(T58* C);
void r58make(T58* C);
T6 r58end_of_file(T58* C);
void r78report_message(T78* C,T0* a1);
T0* r78message(T0* a1);
void r78make_standard(T78* C);
void r78report_error(T78* C,T0* a1);
void r29disconnect(T29* C);
void r29connect_to(T29* C,T0* a1);
void r29put_string(T29* C,T0* a1);
T0* r147Arguments(void);
void r147make(T147* C,T0* a1);
T0* r147message(T147* C,T0* a1);
T0* r147default_message(T147* C);
T0* r144Arguments(void);
void r144make(T144* C,T0* a1);
T0* r144message(T144* C,T0* a1);
T0* r144default_message(T144* C);
void r88disconnect(T88* C);
void r88read_character(T88* C);
T6 r88end_of_input(T88* C);
void r88connect_to(T88* C,T0* a1);
void r75set_position(T75* C,T2 a1,T2 a2,T2 a3);
extern T2 oBC75lower;
extern int fBC75lower;
T2 r75lower(void);
void r75make(T75* C,T0* a1);
void r75make_from_buffer(T75* C,T0* a1);
T0* r141Arguments(void);
void r141make(T141* C,T2 a1);
T0* r141message(T141* C,T0* a1);
T0* r141default_message(T141* C);
T0* r142Arguments(void);
void r142make(T142* C,T0* a1);
T0* r142message(T142* C,T0* a1);
T0* r142default_message(T142* C);
void r74fill(T74* C);
void r74compact_left(T74* C);
T2 r74count(T74* C);
void r74set_position(T74* C,T2 a1,T2 a2,T2 a3);
T2 r74lower(void);
void r74make_from_string(T74* C,T0* a1);
void r74make_from_buffer(T74* C,T0* a1);
void r74resize(T74* C);
void r74make_with_size(T74* C,T0* a1,T2 a2);
void r74set_file(T74* C,T0* a1);
void r74flush(T74* C);
void r145make(T145* C);
void r145put_string(T145* C,T0* a1);
void r89make(T89* C);
void r89put_string(T89* C,T0* a1);
T0* r76Arguments(void);
void r76make(T76* C,T0* a1,T2 a2);
T0* r76message(T76* C,T0* a1);
T0* r76default_message(T76* C);
extern T0*oBC1command_arguments;
extern int fBC1command_arguments;
T0* r83command_arguments(void);
T0* r83argument(T2 a1);
extern T0*oBC57error;
extern int fBC57error;
T0* r57error(void);
extern T0*oBC57input;
extern int fBC57input;
T0* r57input(void);
extern T0*oBC57output;
extern int fBC57output;
T0* r57output(void);
void r17preprocess(T17* C);
void r17read_arguments(T17* C);
extern T0*oBC19Exceptions;
void r17report_cannot_read_error(T17* C,T0* a1);
T0* r17Arguments(void);
void r17execute(T17* C);
void r17report_version_number(T17* C);
extern T0*oBC21OUTPUT_STREAM_;
void r17report_cannot_write_error(T17* C,T0* a1);
extern T0*oBC17Usage_message;
extern int fBC17Usage_message;
T0* r17Usage_message(void);
T0* r87name(T0* a1);
T0* r87make_file_open_read(T0* a1);
T6 r87is_open_read(T0* a1);
void r87close(T0* a1);
T6 r87end_of_input(T0* a1);
T2 r87read_stream(T0* a1,T0* a2,T2 a3,T2 a4);
T6 r27is_closed(T0* a1);
T0* r27make_file_open_write(T0* a1);
T6 r27is_open_write(T0* a1);
void r27close(T0* a1);
T6 r79is_integer(T0* a1);
T0* r79make(T2 a1);
T0* r143variable_value(T143* C,T0* a1);
T0* r143get_environment_variable(T143* C,T0* a1);
T0* r143interpreted_string(T143* C,T0* a1);
T0* r107substring(T0* a1,T2 a2,T2 a3);
void r107move_left(T0* a1,T2 a2,T2 a3,T2 a4);
T0* r107make(T2 a1);
void r107copy_from_string(T0* a1,T2 a2,T0* a3);
T0* r107resize(T0* a1,T2 a2);
T2 r107copy_from_stream(T0* a1,T2 a2,T0* a3,T2 a4);
extern T17*eiffel_root_object;
extern int se_argc;
extern char**se_argv;
#define SE_MAXID 155
void initialize_eiffel_runtime(int argc,char*argv[]);
extern T7*ms87_1338085634;
extern T7*ms76_1449702436;
extern T7*ms147_1515383187;
extern T7*ms17_45aaa;
extern T7*ms17_184927;
extern T7*ms17_45aa;
extern T7*ms17_311;
extern T7*ms17_329;
extern T7*ms17_288;
extern T7*ms17_45a;
extern T7*ms142_988446515;
extern T7*ms144_1606053737;
extern T7*ms35_1173251759;
extern T7*ms89_447584;
extern T7*ms46_1338477769a;
extern T7*ms17_0;
extern T7*ms32_0;
extern T7*ms141_434195944;
extern T7*ms45_0;
extern T7*ms17_23342040;
extern T7*ms145_447851;
extern T7*ms87_0;
extern T7*ms17_16072;
extern T7*ms40_195717202;
extern T7*ms23_1528;
extern T7*ms58_89510;
extern T7*ms32_6359;
extern T7*ms148_1158552108;
extern T7*ms17_312977978;
extern T7*ms17_45;
extern T7*ms32_449403;
extern T7*ms32_10;
extern T7*ms46_1338477769;
T7*se_ms(int c,char*e);
T7*se_string(char*e);
void se_msi1(void);
void*se_ma152(int argc,...);
T6 X25is_connected(T0*C);
void X25put_character(T0*C,T3 a1);
void X25put_string(T0*C,T0* a1);
void X68clear_all(T0*C,T0* a1);
T0* X68make(T0*C,T2 a1);
T0* X68resize(T0*C,T0* a1,T2 a2);
void X75fill(T0*C);
T2 X153count(T0*C);
T2 X153item(T0*C,T2 a1);
T2 X153lower(T0*C);
void X69put(T0*C,T0* a1,T2 a2);
T0* X69item(T0*C,T2 a1);
void X69set_all_with(T0*C,T0* a1);
void X69resize(T0*C,T2 a1);
T6 X26is_connected(T0*C);
void X26read_character(T0*C);
T6 X26end_of_input(T0*C);
T3 X26last_character(T0*C);
T0* X77default_message(T0*C);
T0* T2toT49(T2 source);
T2 T49toT2(T0* source);
T0* T6toT28(T6 source);

#ifdef __cplusplus
}
#endif
