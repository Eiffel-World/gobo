indexing

	description:

		"Expat API"

	library: "Gobo Eiffel XML Library"
	copyright: "Copyright (c) 2001-2002, Eric Bezault and others"
	license: "Eiffel Forum License v1 (see forum.txt)"
	date: "$Date$"
	revision: "$Revision$"

class XM_EXPAT_API

inherit

	ANY

	KL_SHARED_PLATFORM
		export {NONE} all end

	KL_SHARED_OPERATING_SYSTEM
		export {NONE} all end

	UC_UNICODE_FACTORY
		export {NONE} all end

#ifdef HACT
	C_UTIL
		export {NONE} all end

#endif
feature -- Initialization

	init_api is
			-- Initialize Expat API.
		once
		end

feature -- Creating and destroying parsers

	exml_XML_ParserCreate (encoding: POINTER): POINTER is
			-- Create a new parser; encoding is the encoding
			-- specified by the external protocol or null if there
			-- is none specified.
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Char *): EIF_POINTER | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_ParserCreate"
		end

	exml_XML_ParserCreateNS (encoding: POINTER; namespace_separator: CHARACTER): POINTER is
			-- Create a new parser and namespace processor. Element
			-- type names and attribute names that belong to a namespace
			-- will be expanded; unprefixed attribute names are never
			-- expanded; unprefixed element type names are expanded only
			-- if there is a default namespace. The expanded name is the
			-- concatenation of the namespace URI, the namespace
			-- separator character, and the local part of the name. If
			-- the namespace separator is '\0' then the namespace URI and
			-- the local part will be concatenated without any separator.
			-- When a namespace is not declared, the name and prefix will
			-- be passed through without expansion.
		external
#ifdef SE || ISE
			"C use <expat.h>"
#endif
#ifdef HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_ParserCreateNS"
		end

	exml_XML_ParserCreate_MM (encoding, memsuite: POINTER; namespace_separator: POINTER): POINTER is
			-- Create a new parser using the memory management suit
			-- referred to by `memsuite'. If `memsuite' is NULL, then use the
			-- standard library memory suite. If `namespace_separator' is
			-- non-NULL it creates a parser with namespace processing as
			-- described above. The character pointed at will serve as
			-- the namespace separator.
			-- All further memory operations used for the created parser
			-- will come from the given suite.
		external
#ifdef SE || ISE
			"C use <expat.h>"
#endif
#ifdef HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_ParserCreate_MM"
		end

	exml_XML_ExternalEntityParserCreate (parser_handle: POINTER; context: POINTER; encoding: POINTER): POINTER is
			-- Create an XM_Parser object that can parse an external general
			-- entity;
			-- `context' is a '\0'-terminated string specifying the parse context;
			-- `encoding' is a '\0'-terminated string giving the name of
			-- the externally specified encoding, or null if there is no
			-- externally specified encoding.
			-- The context string consists of a sequence of tokens
			-- separated by formfeeds (\f); a token consisting of a name
			-- specifies that the general entity of the name is open; a
			-- token of the form prefix=uri specifies the namespace for a
			-- particular prefix; a token of the form =uri specifies the
			-- default namespace.
			-- This can be called at any point after the first call to an
			-- ExternalEntityRefHandler so longer as the parser has not
			-- yet been freed.
			-- The new parser is completely independent and may safely be
			-- used in a separate thread.
			-- The handlers and userData are initialized from the parser
			-- argument.
			-- Returns 0 if out of memory.  Otherwise returns a new XM_Parser
			-- object.
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_Char *, XML_Char *): EIF_POINTER | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_ExternalEntityParserCreate"
		end

	exml_XML_ParserFree (parser_handle: POINTER) is
			-- Free memory used by the parser.
			-- If an Eiffel callback has been specified, make sure you
			-- have called `exml_XM_SetUserData' with a Void argument,
			-- else your callback is never available for the gc again.
		external
#ifdef SE || ISE
			"C use <expat.h>"
#endif
#ifdef HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_ParserFree"
		end

feature -- Parsing

	exml_XML_Parse_string (a_parser: POINTER; str: STRING; is_final: BOOLEAN): INTEGER is
			-- Parse some input. Return 0 if a fatal error is
			-- detected. The last call to XML_Parse must have `is_final'
			-- true; `str' may be empty.
		require
			a_parser_not_null: a_parser /= default_pointer
			str_not_void: str /= Void
		local
			int: INTEGER
#ifdef ISE || HACT
			c_str: ANY
#endif
		do
			if is_final then
				int := 1
			end
#ifdef ISE || HACT
			c_str := str.to_c
			Result := exml_XML_Parse (a_parser, $c_str, str.count, int)
#endif
#ifdef SE || VE
			Result := exml_XML_Parse (a_parser, str.to_external, str.count, int)
#endif
		end

	exml_XML_Parse (a_parser: POINTER; s: POINTER; len: INTEGER; is_final: INTEGER): INTEGER is
			-- Parse some input. Return 0 if a fatal error is
			-- detected. The last call to XML_Parse must have `is_final'
			-- true; `len' may be zero for this call (or any other).
		require
			a_parser_not_null: a_parser /= default_pointer
			s_not_null: s /= default_pointer
			len_not_negative: len >= 0
		external
#ifdef SE || ISE
			"C use <expat.h>"
#endif
#ifdef HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_Parse"
		end

feature -- Error reporting

	exml_XML_GetErrorCode (a_parser: POINTER): INTEGER is
			-- If XML_Parse or XML_ParseBuffer have returned 0, then
			-- XML_GetErrorCode returns information about the error.
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE || ISE
			"C use <expat.h>"
#endif
#ifdef HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_GetErrorCode"
		end

	exml_XML_ErrorString (code: INTEGER): POINTER is
			-- Return a string describing the error.
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (int): EIF_POINTER | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_ErrorString"
		end

feature -- Parse state

-- These functions return information about the current parse
-- location. They may be called when XM_Parse or XML_ParseBuffer
-- return 0; in this case the location is the location of the
-- character at which the error was detected.

-- They may also be called from any other callback called to
-- report some parse event; in this the location is the location of the
-- first of the sequence of characters that generated the event.

	exml_XML_GetCurrentLineNumber (a_parser: POINTER): INTEGER is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE || ISE
			"C use <expat.h>"
#endif
#ifdef HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_GetCurrentLineNumber"
		end

	exml_XML_GetCurrentColumnNumber (a_parser: POINTER): INTEGER is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE || ISE
			"C use <expat.h>"
#endif
#ifdef HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_GetCurrentColumnNumber"
		end

	exml_XML_GetCurrentByteIndex (a_parser: POINTER): INTEGER is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE || ISE
			"C use <expat.h>"
#endif
#ifdef HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_GetCurrentByteIndex"
		end

feature -- Miscellaneous

	set_callback_object (a_parser: POINTER; a_callback: XM_EXPAT_CALLBACK) is
			-- Attach `a_callback' to the user data of Expat.
			-- Make sure that `a_callback' is not moved by the GC.
		require
			a_parser_not_null: a_parser /= default_pointer
#ifdef ISE || HACT
		local
			ptr: POINTER
#endif
		do
#ifdef ISE || HACT
			ptr := exml_XML_GetUserData (a_parser)
			if ptr /= default_pointer then
				eif_unfreeze (ptr)
			end
			if a_callback /= Void then
				ptr := eif_freeze (a_callback)
				exml_XML_SetUserData (a_parser, ptr)
				exml_XML_SetExternalEntityRefHandlerArg (a_parser, ptr)
			else
				exml_XML_SetUserData (a_parser, default_pointer)
				exml_XML_SetExternalEntityRefHandlerArg (a_parser, default_pointer)
			end
#endif
#ifdef SE || VE
				-- BdB: I think we need to freeze for VE too, look it up.
			exml_XML_SetUserData (a_parser, a_callback)
			exml_XML_SetExternalEntityRefHandlerArg (a_parser, a_callback)
#endif
		end

#ifdef SE || VE
	exml_XML_SetUserData (a_parser: POINTER; a_callback: XM_EXPAT_CALLBACK) is
#else
	exml_XML_SetUserData (a_parser, a_callback: POINTER) is
#endif
			-- This value is passed as the userData argument to
			-- callbacks.
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetUserData"
		end

	exml_XML_SetBase_string (a_parser: POINTER; a_base: STRING): BOOLEAN is
			-- Set the base to be used for resolving relative URIs in
			-- system identifiers in declarations. Resolving relative
			-- identifiers is left to the application: this value will be
			-- passed through as the base argument to the
			-- XML_ExternalEntityRefHandler, XML_NotationDeclHandler and
			-- XML_UnparsedEntityDeclHandler. The base argument will be
			-- copied.
			-- Returns zero if out of memory, non-zero otherwise.
		require
			a_parser_not_null: a_parser /= default_pointer
			a_base_not_void: a_base /= Void
#ifdef ISE || HACT
		local
			c_str: ANY
#endif
		do
#ifdef ISE || HACT
			c_str := a_base.to_c
			Result := exml_XML_SetBase (a_parser, $c_str)
#endif
#ifdef SE || VE
			Result := exml_XML_SetBase (a_parser, a_base.to_external)
#endif
			end

	exml_XML_SetBase (a_parser: POINTER; a_base: POINTER): BOOLEAN is
			-- Set the base to be used for resolving relative URIs in
			-- system identifiers in declarations. Resolving relative
			-- identifiers is left to the application: this value will be
			-- passed through as the base argument to the
			-- XML_ExternalEntityRefHandler, XML_NotationDeclHandler and
			-- XML_UnparsedEntityDeclHandler. The base argument will be
			-- copied.
			-- Returns zero if out of memory, non-zero otherwise.
		require
			a_parser_not_null: a_parser /= default_pointer
			a_base_not_null: a_base /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetBase"
		end

	exml_XML_GetBase (a_parser: POINTER): POINTER is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_GetBase"
		end

	exml_XML_SetParamEntityParsing (a_parser: POINTER; parsing: INTEGER): BOOLEAN is
			-- Control parsing of parameter entities (including the
			-- external DTD subset). If parsing of parameter entities is
			-- enabled, then references to external parameter entities
			-- (including the external DTD subset) will be passed to the
			-- handler set with `XML_SetExternalEntityRefHandler'. The
			-- context passed will be 0. Unlike external general
			-- entities, external parameter entities can only be parsed
			-- synchronously. If the external parameter entity is to be
			-- parsed, it must be parsed during the call to the external
			-- entity ref handler: the complete sequence of
			-- `XML_ExternalEntityParserCreate', `XML_Parse'/`XML_ParseBuffer'
			-- and `XML_ParserFree' calls must be made during this call.
			-- After `XML_ExternalEntityParserCreate' has been called to
			-- create the parser for the external parameter entity
			-- (context must be 0 for this call), it is illegal to make
			-- any calls on the old parser until `XML_ParserFree' has been
			-- called on the newly created parser. If the library has
			-- been compiled without support for parameter entity parsing
			-- (i.e. without XM_DTD being defined), then
			-- `XML_SetParamEntityParsing' will return 0 if parsing of
			-- parameter entities is requested; otherwise it will return
			-- non-zero.
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, enum XML_ParamEntityParsing): unsigned char | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetParamEntityParsing"
		end

	exml_XML_ExpatVersion: POINTER  is
			-- Return a string containing the version number of this expat
		external
#ifdef SE || ISE
			"C use <expat.h>"
#endif
#ifdef HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_ExpatVersion"
		end

feature -- Handlers

	exml_XML_SetElementDeclHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_ElementDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetElementDeclHandler"
		end

	exml_XML_SetAttlistDeclHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_AttlistDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetAttlistDeclHandler"
		end

	exml_XML_SetXmlDeclHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_XmlDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetXmlDeclHandler"
		end

	exml_XML_SetEntityDeclHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_EntityDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetEntityDeclHandler"
		end

	exml_XML_SetElementHandler (a_parser, a_start, a_end: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_StartElementHandler, XML_EndElementHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetElementHandler"
		end

	exml_XML_SetStartElementHandler (a_parser, a_hanlder: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_StartElementHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetStartElementHandler"
		end

	exml_XML_SetEndElementHandler (a_parser, a_hanlder: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_EndElementHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetEndElementHandler"
		end

	exml_XML_SetCharacterDataHandler (a_parser, a_hanlder: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_CharacterDataHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetCharacterDataHandler"
		end

	exml_XML_SetProcessingInstructionHandler (a_parser, a_hanlder: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_ProcessingInstructionHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetProcessingInstructionHandler"
		end

	exml_XML_SetCommentHandler (a_parser, a_hanlder: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_CommentHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetCommentHandler"
		end

	exml_XML_SetCdataSectionHandler (a_parser, a_start, a_end: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_StartCdataSectionHandler, XML_EndCdataSectionHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetCdataSectionHandler"
		end

	exml_XML_SetStartCdataSectionHandler (a_parser, a_hanlder: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_StartCdataSectionHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetStartCdataSectionHandler"
		end

	exml_XML_SetEndCdataSectionHandler (a_parser, a_hanlder: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_EndCdataSectionHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetEndCdataSectionHandler"
		end

	exml_XML_SetDefaultHandler (a_parser, a_hanlder: POINTER) is
			-- Set default handler and also inhibits expansion
			-- of internal entities.
			-- The entity reference will be passed to the default handler.
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_DefaultHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetDefaultHandler"
		end

	exml_XML_SetDefaultHandlerExpand (a_parser, a_hanlder: POINTER) is
			-- Set default handler but does not inhibit
			-- expansion of internal entities.
			-- The entity reference will not be passed to the default handler.
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_DefaultHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetDefaultHandlerExpand"
		end

	exml_XML_SetDoctypeDeclHandler (a_parser, a_start, a_end: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_StartDoctypeDeclHandler, XML_EndDoctypeDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetDoctypeDeclHandler"
		end

	exml_XML_SetStartDoctypeDeclHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_StartDoctypeDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetStartDoctypeDeclHandler"
		end

	exml_XML_SetEndDoctypeDeclHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_EndDoctypeDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetEndDoctypeDeclHandler"
		end

	exml_XML_SetNotationDeclHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_NotationDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetNotationDeclHandler"
		end

	exml_XML_SetNamespaceDeclHandler (a_parser, a_start, a_end: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_StartNamespaceDeclHandler, XML_EndNamespaceDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetNamespaceDeclHandler"
		end

	exml_XML_SetStartNamespaceDeclHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_StartNamespaceDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetStartNamespaceDeclHandler"
		end

	exml_XML_SetEndNamespaceDeclHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_EndNamespaceDeclHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetEndNamespaceDeclHandler"
		end

	exml_XML_SetNotStandaloneHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_NotStandaloneHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetNotStandaloneHandler"
		end

	exml_XML_SetExternalEntityRefHandler (a_parser, a_handler: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser,  XML_ExternalEntityRefHandler) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetExternalEntityRefHandler"
		end

#ifdef SE || VE
	exml_XML_SetExternalEntityRefHandlerArg (a_parser: POINTER; a_arg: XM_EXPAT_CALLBACK) is
#else
	exml_XML_SetExternalEntityRefHandlerArg (a_parser: POINTER; a_arg: POINTER) is
#endif
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetExternalEntityRefHandlerArg"
		end

	exml_XML_SetUnknownEncodingHandler (a_parser, a_handler, info: POINTER) is
		require
			a_parser_not_null: a_parser /= default_pointer
		external
#ifdef SE
			"C use <expat.h>"
#endif
#ifdef ISE || HACT
			"C (XML_Parser, XML_UnknownEncodingHandler, void *) | <expat.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"XML_SetUnknownEncodingHandler"
		end

feature -- XML_ParamEntityParsing enum

#ifdef VE
	XML_PARAM_ENTITY_PARSING_NEVER: INTEGER is 0
#else
	XML_PARAM_ENTITY_PARSING_NEVER: INTEGER is
		external
#ifdef SE
			"C macro use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_PARAM_ENTITY_PARSING_NEVER"
		end
#endif

#ifdef VE
	XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE: INTEGER is 1
#else
	XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE: INTEGER is
		external
#ifdef SE
			"C macro use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE"
		end
#endif

#ifdef VE
	XML_PARAM_ENTITY_PARSING_ALWAYS: INTEGER is 2
#else
	XML_PARAM_ENTITY_PARSING_ALWAYS: INTEGER is
		external
#ifdef SE
			"C macro use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_PARAM_ENTITY_PARSING_ALWAYS"
		end
#endif

feature -- XML_Content_Type enum

#ifdef VE
	XML_CTYPE_EMPTY: INTEGER is 1
#else
	XML_CTYPE_EMPTY: INTEGER is
		external
#ifdef SE
			"C macro use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_CTYPE_EMPTY"
		end
#endif

#ifdef VE
	XML_CTYPE_ANY: INTEGER is 2
#else
	XML_CTYPE_ANY: INTEGER is
		external
#ifdef SE
			"C macro use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_CTYPE_ANY"
		end
#endif

#ifdef VE
	XML_CTYPE_MIXED: INTEGER is 3
#else
	XML_CTYPE_MIXED: INTEGER is
		external
#ifdef SE
			"C macro use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_CTYPE_MIXED"
		end
#endif

#ifdef VE
	XML_CTYPE_NAME: INTEGER is 4
#else
	XML_CTYPE_NAME: INTEGER is
		external
#ifdef SE
			"C macro use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_CTYPE_NAME"
		end
#endif

#ifdef VE
	XML_CTYPE_CHOICE: INTEGER is 5
#else
	XML_CTYPE_CHOICE: INTEGER is
		external
#ifdef SE
			"C macro use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_CTYPE_CHOICE"
		end
#endif

#ifdef VE
	XML_CTYPE_SEQ: INTEGER is 6
#else
	XML_CTYPE_SEQ: INTEGER is
		external
#ifdef SE
			"C macro use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_CTYPE_SEQ"
		end
#endif

feature -- XML_Content_Quant enum

#ifdef VE
	XML_CQUANT_NONE: INTEGER is 0
#else
	XML_CQUANT_NONE: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_CQUANT_NONE"
		end
#endif

#ifdef VE
	XML_CQUANT_OPT: INTEGER is 1
#else
	XML_CQUANT_OPT: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_CQUANT_OPT"
		end
#endif

#ifdef VE
	XML_CQUANT_REP: INTEGER is 2
#else
	XML_CQUANT_REP: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_CQUANT_REP"
		end
#endif

#ifdef VE
	XML_CQUANT_PLUS: INTEGER is 3
#else
	XML_CQUANT_PLUS: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_CQUANT_PLUS"
		end
#endif

feature -- XML_Error enum

#ifdef VE
	XML_ERROR_NONE: INTEGER is 0
#else
	XML_ERROR_NONE: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_NONE"
		end
#endif

#ifdef VE
	XML_ERROR_NO_MEMORY: INTEGER is 1
#else
	XML_ERROR_NO_MEMORY: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_NO_MEMORY"
		end
#endif

#ifdef VE
	XML_ERROR_SYNTAX: INTEGER is 2
#else
	XML_ERROR_SYNTAX: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_SYNTAX"
		end
#endif

#ifdef VE
	XML_ERROR_NO_ELEMENTS: INTEGER is 3
#else
	XML_ERROR_NO_ELEMENTS: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_NO_ELEMENTS"
		end
#endif

#ifdef VE
	XML_ERROR_INVALID_TOKEN: INTEGER is 4
#else
	XML_ERROR_INVALID_TOKEN: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_INVALID_TOKEN"
		end
#endif

#ifdef VE
	XML_ERROR_UNCLOSED_TOKEN: INTEGER is 5
#else
	XML_ERROR_UNCLOSED_TOKEN: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_UNCLOSED_TOKEN"
		end
#endif

#ifdef VE
	XML_ERROR_PARTIAL_CHAR: INTEGER is 6
#else
	XML_ERROR_PARTIAL_CHAR: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_PARTIAL_CHAR"
		end
#endif

#ifdef VE
	XML_ERROR_TAG_MISMATCH: INTEGER is 7
#else
	XML_ERROR_TAG_MISMATCH: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_TAG_MISMATCH"
		end
#endif

#ifdef VE
	XML_ERROR_DUPLICATE_ATTRIBUTE: INTEGER is 8
#else
	XML_ERROR_DUPLICATE_ATTRIBUTE: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_DUPLICATE_ATTRIBUTE"
		end
#endif

#ifdef VE
	XML_ERROR_JUNK_AFTER_DOC_ELEMENT: INTEGER is 9
#else
	XML_ERROR_JUNK_AFTER_DOC_ELEMENT: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_JUNK_AFTER_DOC_ELEMENT"
		end
#endif

#ifdef VE
	XML_ERROR_PARAM_ENTITY_REF: INTEGER is 10
#else
	XML_ERROR_PARAM_ENTITY_REF: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_PARAM_ENTITY_REF"
		end
#endif

#ifdef VE
	XML_ERROR_UNDEFINED_ENTITY: INTEGER is 11
#else
	XML_ERROR_UNDEFINED_ENTITY: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_UNDEFINED_ENTITY"
		end
#endif

#ifdef VE
	XML_ERROR_RECURSIVE_ENTITY_REF: INTEGER is 12
#else
	XML_ERROR_RECURSIVE_ENTITY_REF: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_RECURSIVE_ENTITY_REF"
		end
#endif

#ifdef VE
	XML_ERROR_ASYNC_ENTITY: INTEGER is 13
#else
	XML_ERROR_ASYNC_ENTITY: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_ASYNC_ENTITY"
		end
#endif

#ifdef VE
	XML_ERROR_BAD_CHAR_REF: INTEGER is 14
#else
	XML_ERROR_BAD_CHAR_REF: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_BAD_CHAR_REF"
		end
#endif

#ifdef VE
	XML_ERROR_BINARY_ENTITY_REF: INTEGER is 15
#else
	XML_ERROR_BINARY_ENTITY_REF: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_BINARY_ENTITY_REF"
		end
#endif

#ifdef VE
	XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF: INTEGER is 16
#else
	XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF"
		end
#endif

#ifdef VE
	XML_ERROR_MISPLACED_XML_PI: INTEGER is 17
#else
	XML_ERROR_MISPLACED_XML_PI: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_MISPLACED_XML_PI"
		end
#endif

#ifdef VE
	XML_ERROR_UNKNOWN_ENCODING: INTEGER is 18
#else
	XML_ERROR_UNKNOWN_ENCODING: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_UNKNOWN_ENCODING"
		end
#endif

#ifdef VE
	XML_ERROR_INCORRECT_ENCODING: INTEGER is 19
#else
	XML_ERROR_INCORRECT_ENCODING: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_INCORRECT_ENCODING"
		end
#endif

#ifdef VE
	XML_ERROR_UNCLOSED_CDATA_SECTION: INTEGER is 20
#else
	XML_ERROR_UNCLOSED_CDATA_SECTION: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_UNCLOSED_CDATA_SECTION"
		end
#endif

#ifdef VE
	XML_ERROR_EXTERNAL_ENTITY_HANDLING: INTEGER is 21
#else
	XML_ERROR_EXTERNAL_ENTITY_HANDLING: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_EXTERNAL_ENTITY_HANDLING"
		end
#endif

#ifdef VE
	XML_ERROR_NOT_STANDALONE: INTEGER is 22
#else
	XML_ERROR_NOT_STANDALONE: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_NOT_STANDALONE"
		end
#endif

#ifdef VE
	XML_ERROR_UNEXPECTED_STATE: INTEGER is 23
#else
	XML_ERROR_UNEXPECTED_STATE: INTEGER is
		external
#ifdef SE || ISE
			"C macro use <expat.h>"
#endif
#ifdef HACT
			"C [macro <expat.h>]"
#endif
		alias
			"XML_ERROR_UNEXPECTED_STATE"
		end
#endif

feature -- XML_cp members

#ifdef VE
	exml_XML_cp_size: INTEGER is 20
#else
	exml_XML_cp_size: INTEGER is
		external
#ifdef SE
			"C inline use <expat.h>"
		alias
			"sizeof(XML_Content)"
#endif
#ifdef ISE || HACT
			"C [macro <expat.h>]: EIF_INTEGER"
		alias
			"sizeof(XML_Content)"
#endif
		end
#endif

	exml_XML_cp_type (cp: POINTER): INTEGER is
		require
			have_struct_pointer: cp /= Void
#ifdef VE
		local
			m_cp: RTS_MEMORY_MAPPED_AREA_ARRAY [INTEGER]
		do
			create m_cp.make (cp, exml_XML_cp_size)
			Result := m_cp.item (1)
#else
		external
#ifdef SE
			"C struct XML_Content get type use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [struct <expat.h>] (struct XML_cp): EIF_INTEGER"
		alias
			"type"
#endif
#endif
		end

	exml_XML_cp_quant (cp: POINTER): INTEGER is
		require
			have_struct_pointer: cp /= Void
#ifdef VE
		local
			m_cp: RTS_MEMORY_MAPPED_AREA_ARRAY [INTEGER]
		do
			create m_cp.make (cp, exml_XML_cp_size)
			Result := m_cp.item (2)
#else
		external
#ifdef SE
			"C struct XML_Content get quant use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [struct <expat.h>] (struct XML_cp): EIF_INTEGER"
		alias
			"quant"
#endif
#endif
		end

	exml_XML_cp_name (cp: POINTER): POINTER is
		require
			have_struct_pointer: cp /= Void
#ifdef VE
		local
			m_cp: RTS_MEMORY_MAPPED_AREA_ARRAY [POINTER]
		do
			create m_cp.make (cp, exml_XML_cp_size)
			Result := m_cp.item (3)
#else
		external
#ifdef SE
			"C struct XML_Content get name use <expat.h>"
#endif
#ifdef HACT || ISE
			"C [struct <expat.h>] (struct XML_cp): EIF_POINTER"
		alias
			"name"
#endif
#endif
		end

	exml_XML_cp_numchildren (cp: POINTER): INTEGER is
		require
			have_struct_pointer: cp /= Void
#ifdef VE
		local
			m_cp: RTS_MEMORY_MAPPED_AREA_ARRAY [INTEGER]
		do
			create m_cp.make (cp, exml_XML_cp_size)
			Result := m_cp.item (4)
#else
		external
#ifdef SE
			"C struct XML_Content get numchildren use <expat.h>"
#endif
#ifdef ISE || HACT
			"C [struct <expat.h>] (struct XML_cp): EIF_INTEGER"
		alias
			"numchildren"
#endif
#endif
		end

#ifdef ISE || HACT
	exml_XML_cp_children_0 (cp: POINTER): POINTER is
		external
			"C [struct <expat.h>] (struct XML_cp): EIF_INTEGER"
		alias
			"children"
		end
#endif

	exml_XML_cp_children (cp: POINTER; index: INTEGER): POINTER is
		require
			have_struct_pointer: cp /= Void
			valid_index: index >= 0 and index < exml_XML_cp_numchildren (cp)
#ifdef VE
		local
			m_cp,
			m_cp_array: RTS_MEMORY_MAPPED_AREA_ARRAY [POINTER]
		do
			create m_cp.make (cp, exml_XML_cp_size + (exml_XML_cp_numchildren (cp) * exml_XML_cp_size))
			Result := m_cp.item (5) + (index * exml_XML_cp_size)
#else
#ifdef SE
		external
			"C inline"
		alias
			"(EIF_POINTER) (&(((XML_Content*)$cp)->children[$index]))"
#endif
#ifdef ISE || HACT
		local
			children: POINTER
		do
			children := exml_XML_cp_children_0 (cp)
#ifdef ISE
			Result := children + (index * exml_XML_cp_size)
#else
			Result := integer_to_pointer (pointer_to_integer (children) + (index * exml_XML_cp_size))
#endif
#endif
#endif
		ensure
			valid_struct: Result /= default_pointer
		end

feature -- XML_Content freeing

	exml_XML_cp_free (cp: POINTER) is
			-- Free the Expat allocated XML_Content struct by assuming it
			-- has been allocated by malloc so free likes it.
		require
			cp_points_to_something: cp /= default_pointer
		external
#ifdef SE || ISE
			"C use <stdlib.h>"
#endif
#ifdef HACT
			"C | <stdlib.h>"
#endif
#ifdef VE
			"C"
#endif
		alias
			"free"
		end

feature -- Conversion

	new_attribute_list_from_c (attr_spec_ptr: POINTER): DS_BILINKED_LIST [DS_PAIR [DS_PAIR [STRING, STRING], STRING]] is
		require
			attr_spec_ptr_not_null: attr_spec_ptr /= default_pointer
		local
			a_name: STRING
			a_prefix: STRING
			a_value: STRING
			ptr: POINTER
			pair1: DS_PAIR [STRING, STRING]
			pair2: DS_PAIR [DS_PAIR [STRING, STRING], STRING]
			colon_index: INTEGER
#ifdef SE
			a_storage: NATIVE_ARRAY [POINTER]
			i: INTEGER
#endif
#ifdef ISE || HACT
			a_storage: SPECIAL [POINTER]
			ptr_size: INTEGER
			ptr2: POINTER
#endif
#ifdef ISE
			to_special: TO_SPECIAL [POINTER]
			ptr1: POINTER
#endif
#ifdef VE
			a_storage: RTS_MEMORY_MAPPED_AREA_ARRAY [POINTER]
			i: INTEGER
#endif
		do
			!! Result.make
			from
#ifdef SE
				a_storage := a_storage.from_pointer (attr_spec_ptr)
				ptr := a_storage.item (i)
#endif
#ifdef ISE
				ptr_size := Platform.Pointer_bytes
				!! to_special.make_area (1)
				a_storage := to_special.area
				ptr2 := attr_spec_ptr
				ptr1 := c_rtid ($a_storage)
				ptr1.memory_copy (ptr2, ptr_size)
				ptr := a_storage.item (0)
#endif
#ifdef HACT
				ptr_size := Platform.Pointer_bytes
				!! a_storage.make (1)
				ptr2 := attr_spec_ptr
				c_bcopy (ptr2, $a_storage, ptr_size)
				ptr := a_storage.item (0)
#endif
#ifdef VE
				i := 1
				!! a_storage.make (attr_spec_ptr, i)
				ptr := a_storage.item (i)
#endif
			until
				ptr = default_pointer
			loop
				a_name := new_unicode_string_from_utf8 (new_string_from_c_zero_terminated_string (ptr))
				colon_index := a_name.index_of (':', 1)
				if colon_index /= 0 then
					a_prefix := a_name.substring (1, colon_index - 1)
					a_name := a_name.substring (colon_index + 1, a_name.count)
				else
					a_prefix := new_unicode_string_empty
				end
#ifdef SE
				i := i + 1
				ptr := a_storage.item (i)
#endif
#ifdef ISE
				ptr2 := ptr2 + ptr_size
				ptr1 := c_rtid ($a_storage)
				ptr1.memory_copy (ptr2, ptr_size)
				ptr := a_storage.item (0)
#endif
#ifdef HACT
				ptr2 := integer_to_pointer (pointer_to_integer (ptr2) + ptr_size)
				c_bcopy (ptr2, $a_storage, ptr_size)
				ptr := a_storage.item (0)
#endif
#ifdef VE
				i := i + 1
				a_storage.resize (i)
				ptr := a_storage.item (i)
#endif
				a_value := new_unicode_string_from_utf8 (new_string_from_c_zero_terminated_string (ptr))
				!! pair1.make (a_name, a_prefix)
				!! pair2.make (pair1, a_value)
				Result.force_last (pair2)
#ifdef SE
				i := i + 1
				ptr := a_storage.item (i)
#endif
#ifdef ISE
				ptr2 := ptr2 + ptr_size
				ptr1 := c_rtid ($a_storage)
				ptr1.memory_copy (ptr2, ptr_size)
				ptr := a_storage.item (0)
#endif
#ifdef HACT
				ptr2 := integer_to_pointer (pointer_to_integer (ptr2) + ptr_size)
				c_bcopy (ptr2, $a_storage, ptr_size)
				ptr := a_storage.item (0)
#endif
#ifdef VE
				i := i + 1
				a_storage.resize (i)
				ptr := a_storage.item (i)
#endif
			end
		ensure
			attribute_list_not_void: Result /= Void
		end

feature -- Conversion: C Strings to STRING

	new_string_from_c_zero_terminated_string (psz: POINTER): STRING is
			-- Eiffel STRING object created from a zero terminated C
			-- String located at `psz'.
			-- The string is copied so the memory allocated at `psz' may be
			-- freed without affecting the returned string.
		require
			psz_valid: psz /= default_pointer
		do
#ifdef SE
			!! Result.from_external_copy (psz)
#else
#ifdef VE
			!! Result.make_empty
#else
			!! Result.make (0)
#endif
			Result.from_c (psz)
#endif
		ensure
			string_not_void: Result /= Void
		end

	new_string_from_c_runlength_string (ps: POINTER; length: INTEGER): STRING is
			-- Eiffel STRING object created from a runlength
			-- C string. The string is copied so the memory allocated at
			-- `ps' may be freed without affecting the returned string.
		require
			ps_valid: ps /= default_pointer
			len_valid: length >= 0
#ifdef SE || VE
		local
			i: INTEGER
#ifdef SE
			storage: NATIVE_ARRAY [CHARACTER]
#endif
#ifdef VE
			a_storage: RTS_MEMORY_MAPPED_AREA_ARRAY [CHARACTER]
#endif
#endif
		do
			if length = 0 then
				Result := clone ("")
			else
#ifdef SE
				storage := storage.from_pointer (ps)
				!! Result.make (length)
				from i := 0 until i = length loop
					Result.append_character (storage.item (i))
					i := i + 1
				end
#endif
#ifdef HACT
				!! Result.make (0)
				Result.from_c_substring (ps, 1, length)
#endif
#ifdef ISE
				!! Result.make (length)
				Result.from_c_substring (ps, 1, length)
#endif
#ifdef VE
				!! Result.make_filled ('%U', length)
				!! a_storage.make (ps, length)
				from i := 1 until i > length loop
					Result.put (a_storage.item (i), i)
					i := i + 1
				end
#endif
			end
		ensure
			string_not_void: Result /= Void
		end

	new_string_from_c_zero_terminated_string_safe (psz: POINTER): STRING is
			-- Same as `new_string_from_c_zero_terminated_string',
			-- except you may give it a `default_pointer' - in that case
			-- it will give you back Void
		do
			if psz /= default_pointer then
				Result := new_string_from_c_zero_terminated_string (psz)
			end
		end

feature -- Conversion: C Strings to UC_STRING

	new_uc_string_from_c_utf8_zero_terminated_string_safe (psz: POINTER): UC_STRING is
			-- Same as `new_string_from_c_utf8_zero_terminated_string',
			-- except you may give it a `default_pointer' - in that case
			-- it will give you back Void
		do
			if psz /= default_pointer then
				Result := new_uc_string_from_c_utf8_zero_terminated_string (psz)
			end
		end

	new_uc_string_from_c_utf8_zero_terminated_string (psz: POINTER): UC_STRING is
			-- Eiffel UC_STRING object created from a zero terminated C
			-- String located at `psz'.
			-- The string is copied so the memory allocated at `psz' may be
			-- freed without affecting the returned string.
			-- The C String is assumed to be in utf8 format.
		require
			psz_valid: psz /= default_pointer
		do
			Result := new_unicode_string_from_utf8 (new_string_from_c_zero_terminated_string (psz))
		ensure
			string_not_void: Result /= Void
		end

	new_uc_string_from_c_utf8_runlength_string (ps: POINTER; length: INTEGER): UC_STRING is
			-- Eiffel UC_STRING object created from a runlength
			-- C string encoded in UTF8. The string is copied so the memory allocated at
			-- `ps' may be freed without affecting the returned string.
		require
			ps_not_default: ps /= default_pointer
			positive_length: length >= 0
		do
			Result := new_unicode_string_from_utf8 (new_string_from_c_runlength_string (ps, length))
		ensure
			string_not_void: Result /= Void
		end

feature {NONE} -- Implementation

#ifdef ISE
	c_rtid (p: POINTER): POINTER is
			-- Return `p'
		external
			"C [macro <eif_macros.h>]"
		alias
			"/**/"
		end

#endif
#ifdef HACT
	c_bcopy (s, d: POINTER; l: INTEGER) is
			-- Return `p'
		external
			"C [macro <eif_eiffel.h>]"
		alias
			"bcopy"
		end

#endif
#ifdef ISE || HACT
	eif_freeze (obj: ANY): POINTER is
			-- Make sure that `obj' will not be moved by GC.
		require
			obj_not_void: obj /= Void
		external
			"C [macro <eif_eiffel.h>]"
		alias
			"eif_freeze"
		end

	eif_unfreeze (ptr: POINTER) is
			-- Object at address `ptr' can be handled
			-- and moved by the GC now.
		require
			ptr_not_null: ptr /= default_pointer
		external
			"C [macro <eif_eiffel.h>] (EIF_REFERENCE)"
		alias
			"eif_unfreeze"
		end

	exml_XML_GetUserData (a_parser: POINTER): POINTER is
			-- Last value set by XM_SetUserData or null.
		require
			a_parser_not_null: a_parser /= default_pointer
		external
			"C [macro <expat.h>]"
		alias
			"XML_GetUserData"
		end

#endif
end
