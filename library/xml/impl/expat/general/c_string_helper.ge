indexing
   description:
   
	"Create Eiffel STRINGSs and UC_STRINGs from C strings"

   library:    "?"
   author:     "Andreas Leitner <nozone@sbox.tugraz.at>"
   copyright:  "Copyright (c) 2001, Andreas Leitner and others"
   license:    "Eiffel Forum Freeware License v1 (see forum.txt)"
   date:       "$Date$"
   revision:   "$Revision$"

class
   C_STRING_HELPER

feature {NONE} -- C Strings to STRING
   
   new_string_from_c_zero_terminated_string (psz: POINTER): STRING is
         -- Returns an Eiffel STRING object created from a zero terminated C
         -- String located at `psz'.
         -- The string is copied so the memory allocated at `psz' may be
         -- freed without affecting the returned string.
      require
         psz_valid: psz /= Void and then psz /= default_pointer
      do
#ifdef SE
         !! Result.from_external_copy (psz)
#else
#ifdef VE
         !! Result.make_empty
#else
         !! Result.make (0)
#endif
         Result.from_c (psz)
#endif
      end
   
   new_string_from_c_runlength_string (ps: POINTER; length: INTEGER): STRING is
         -- Returns an Eiffel STRING object created from a runlength
         -- C string. The string is copied so the memory allocated at
         -- `ps' may be freed without affecting the returned string.
      require
         ps_valid: ps /= default_pointer
         len_valid: length > 0
#ifdef SE || VE
      local
         i: INTEGER
#ifdef SE
         storage: NATIVE_ARRAY[CHARACTER];
#endif
#ifdef VE
         a_storage: RTS_MEMORY_MAPPED_AREA_ARRAY [CHARACTER]
#endif
#endif
      do
#ifdef SE
         storage := storage.from_pointer (ps);
         !! Result.make (length)
         from 
            i := 0
         until 
            i = length
         loop
            Result.append_character (storage.item (i))
            i := i + 1
         end
#endif
#ifdef HACT
         !! Result.make (0)
         Result.from_c_substring (ps, 1, length)
#endif
#ifdef ISE
         !! Result.make (length)
         Result.from_c_substring (ps, 1, length)
#endif
#ifdef VE
         !! Result.make_filled ('%U', length)
         !! a_storage.make (ps, length)
         from i := 1 until i > length loop
            Result.put (a_storage.item (i), i)
            i := i + 1
         end
#endif
      end
   
   new_string_from_c_zero_terminated_string_safe (psz: POINTER): STRING is
         -- Same as `new_string_from_c_zero_terminated_string', 
         -- except you may give it a `default_pointer' - in that case 
         -- it will give you back Void
      do
         if
            psz /= default_pointer
          then
            Result := new_string_from_c_zero_terminated_string (psz)
         end
      end

feature {NONE} -- C Strings to UC_STRING
   
   new_uc_string_from_c_utf8_zero_terminated_string_safe (psz: POINTER): UC_STRING is
         -- Same as `new_string_from_c_zero_terminated_string', 
         -- except you may give it a `default_pointer' - in that case 
         -- it will give you back Void
      do
         if
            psz /= default_pointer
          then
            Result := new_uc_string_from_c_utf8_zero_terminated_string (psz)
         end
      end
   
   new_uc_string_from_c_utf8_zero_terminated_string (psz: POINTER): UC_STRING is
         -- Returns an Eiffel UC_STRING object created from a zero terminated C
         -- String located at `psz'.
         -- The string is copied so the memory allocated at `psz' may be
         -- freed without affecting the returned string.
         -- The C String is assumed to be in utf8 format
      require
         psz_valid: psz /= default_pointer
      do
         !! Result.make_from_utf8 (new_string_from_c_zero_terminated_string (psz))
      ensure
         valid_result: Result /= Void
      end

   new_uc_string_from_c_utf8_runlength_string (ps: POINTER; length: INTEGER): UC_STRING is
         -- Returns an Eiffel UC_STRING object created from a runlength
         -- C string encoded in UTF8. The string is copied so the memory allocated at
         -- `ps' may be freed without affecting the returned string.
      require
         ps_not_default: ps /= default_pointer
         positive_length: length >= 0
      do
         !! Result.make_from_utf8 (new_string_from_c_runlength_string (ps, length))
      ensure
         valid_result: Result /= Void
      end
   
   
   
end -- class C_STRING_HELPER
