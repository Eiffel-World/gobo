indexing

	description:

		"Objects that represent an XSLT instruction"

	library: "Gobo Eiffel XSLT Library"
	copyright: "Copyright (c) 2004, Colin Adams and others"
	license: "Eiffel Forum License v2 (see forum.txt)"
	date: "$Date$"
	revision: "$Revision$"

deferred class XM_XSLT_INSTRUCTION

inherit

	KL_IMPORTED_STRING_ROUTINES

	XM_XPATH_LOCATOR

	XM_XPATH_DEBUGGING_ROUTINES

feature -- Access

	children: DS_ARRAYED_LIST [XM_XSLT_INSTRUCTION]
			-- Child instructions

	executable: XM_XSLT_EXECUTABLE
			-- Executable

	line_number: INTEGER
			-- Line number within module

	system_id: STRING is
			--  SYSTEM id
		do
			if module_number = 0 then
				Result := ""
			else
				Result := executable.system_id (module_number)
			end
		end

	result_type: XM_XPATH_SEQUENCE_TYPE is
			-- Static type of values generated by `Current'
		do
			create Result.make_any_sequence
		ensure
			result_type_not_void: Result /= void
		end

	instruction_name: STRING is
			-- Name of instruction, for diagnostics
		require
			executable_not_void: executable /= Void
		deferred
		ensure
			instruction_name_not_void: Result /= Void
		end

	assembled_parameters (a_context:XM_XSLT_EVALUATION_CONTEXT;  a_parameter_list: DS_ARRAYED_LIST [XM_XSLT_COMPILED_WITH_PARAM]):  XM_XSLT_PARAMETER_SET is
			-- Assembled parameter set
		require
			context_not_void: a_context /= Void
			paramter_list_not_void: a_parameter_list /= Void
		local
			a_cursor:  DS_ARRAYED_LIST_CURSOR [XM_XSLT_COMPILED_WITH_PARAM]
			a_param: XM_XSLT_COMPILED_WITH_PARAM
		do
			from
				create Result.make_empty
				a_cursor := a_parameter_list.new_cursor; a_cursor.start
			variant
				a_parameter_list.count + 1 - a_cursor.index
			until
				a_cursor.after
			loop
				a_param := a_cursor.item
				Result.put (a_param.value (a_context), a_param.variable_fingerprint)
				a_cursor.forth
			end
		ensure
			assembled_parameters_not_void: Result /= Void
		end

	assembled_tunnel_parameters (a_context:XM_XSLT_EVALUATION_CONTEXT;  a_parameter_list: DS_ARRAYED_LIST [XM_XSLT_COMPILED_WITH_PARAM]):  XM_XSLT_PARAMETER_SET is
			-- Assembled tunnel parameter set
		require
			context_not_void: a_context /= Void
			paramter_list_not_void: a_parameter_list /= Void
		local
			a_cursor:  DS_ARRAYED_LIST_CURSOR [XM_XSLT_COMPILED_WITH_PARAM]
			a_param: XM_XSLT_COMPILED_WITH_PARAM
			some_existing_parameters: XM_XSLT_PARAMETER_SET
		do
			some_existing_parameters := a_context.transformer.bindery.tunnel_parameters
			if some_existing_parameters = Void then
				Result := assembled_parameters (a_context, a_parameter_list)
			else
				create Result.make (some_existing_parameters)
				if a_parameter_list.count > 0 then
					from
						a_cursor := a_parameter_list.new_cursor; a_cursor.start
					variant
						a_parameter_list.count + 1 - a_cursor.index
					until
						a_cursor.after
					loop
						a_param := a_cursor.item
						Result.put (a_param.value (a_context), a_param.variable_fingerprint)
						a_cursor.forth
					end
				end
			end
		end
		
feature -- Status report

	last_tail_call: XM_XSLT_TAIL_CALL
			-- Residue from last call to `process_leaving_tail'

	display_children (a_level: INTEGER; a_pool: XM_XPATH_NAME_POOL) is
			-- Diagnostic print of children to `std.error'
		local
			a_message: STRING
			an_expression: XM_XPATH_EXPRESSION
			a_cursor: DS_ARRAYED_LIST_CURSOR [XM_XSLT_INSTRUCTION]
		do
			from
				a_cursor := children.new_cursor
				a_cursor.start
			variant
				children.count + 1 - a_cursor.index
			until
				a_cursor.after
			loop
				an_expression ?= a_cursor.item
				if an_expression /= Void then
					an_expression.display (a_level, a_pool)
				else
					a_message := STRING_.appended_string (instruction_indentation (a_level), a_cursor.item.instruction_name)
					std.error.put_string (a_message)
					std.error.put_new_line
				end
				a_cursor.forth
			end
		end

feature -- Status setting

	report_recoverable_error (an_instruction: XM_XSLT_INSTRUCTION; a_message: STRING; a_transformer: XM_XSLT_TRANSFORMER) is
			-- Report a recoverable error.
		require
			instruction_not_void: an_instruction /= Void
			message_not_void: a_message /= Void
			transformer_not_void: a_transformer /= Void
		do
			a_transformer.report_recoverable_error (a_message, an_instruction)
		end

	report_fatal_error (an_instruction: XM_XSLT_INSTRUCTION; a_message: STRING; a_transformer: XM_XSLT_TRANSFORMER) is
			-- Report a recoverable error.
		require
			instruction_not_void: an_instruction /= Void
			message_not_void: a_message /= Void
			transformer_not_void: a_transformer /= Void
		do
			a_transformer.report_fatal_error (a_message, an_instruction)
		end

feature -- Evaluation

	process_leaving_tail (a_context: XM_XSLT_EVALUATION_CONTEXT) is
			-- Execute `Current', writing results to the current `XM_XPATH_RECEIVER'.
		require
			evaluation_context_not_void: a_context /= Void
		deferred
		ensure
			possible_tail_call: last_tail_call = Void or else last_tail_call /= Void
		end

	process (a_context: XM_XSLT_EVALUATION_CONTEXT) is
			-- Execute `Current' completely, writing results to the current `XM_XPATH_RECEIVER'.
		require
			evaluation_context_not_void: a_context /= Void
		do
			process_leaving_tail (a_context)
			from
			until
				last_tail_call = Void
			loop
				last_tail_call.process_leaving_tail (a_context.transformer)
			end
		ensure
			no_tail_calls: last_tail_call = Void
		end

	process_children (a_context: XM_XSLT_EVALUATION_CONTEXT) is
		-- Execute children of `Current' completely, writing results to the current `XM_XPATH_RECEIVER'.
		require
			evaluation_context_not_void: a_context /= Void
		local
			a_transformer: XM_XSLT_TRANSFORMER
			a_cursor: DS_ARRAYED_LIST_CURSOR [XM_XSLT_INSTRUCTION]
		do
			a_transformer := a_context.transformer
			from
				a_cursor := children.new_cursor
				a_cursor.start
			variant
				children.count + 1 - a_cursor.index
			until
				a_transformer.is_error or else a_cursor.after
			loop
				a_cursor.item.process (a_context)
				a_cursor.forth
			end
		ensure
			no_tail_calls: last_tail_call = Void
		end

	process_children_leaving_tail (a_context: XM_XSLT_EVALUATION_CONTEXT) is
			-- Process the children of this instruction
		require
			evaluation_context_not_void: a_context /= Void
			no_error: not a_context.transformer.is_error
		local
			a_transformer: XM_XSLT_TRANSFORMER
			a_cursor: DS_ARRAYED_LIST_CURSOR [XM_XSLT_INSTRUCTION]
			an_instruction: XM_XSLT_INSTRUCTION
		do
			last_tail_call := Void
			a_transformer := a_context.transformer
			from
				a_cursor := children.new_cursor; a_cursor.start
			variant
				a_cursor.index - children.count + 1
			until
				a_transformer.is_error or else a_cursor.after
			loop
				an_instruction := a_cursor.item
				an_instruction.process_leaving_tail (a_context)
				last_tail_call := an_instruction.last_tail_call
				a_cursor.forth
			end
		end

feature -- Element change

	set_executable (an_executable: XM_XSLT_EXECUTABLE) is
			-- Set executable.
		require
			executable_not_void: an_executable /= Void
		do
			executable := an_executable
		ensure
			set: executable = an_executable
		end

	set_source_location (a_module_number, a_line_number: INTEGER) is
			-- Set source location information.
		do
			module_number := a_module_number
			line_number := a_line_number
		ensure
			line_number_set: line_number = a_line_number
			system_id_set: module_number = a_module_number
		end

	set_children (a_child_list: DS_ARRAYED_LIST [XM_XSLT_INSTRUCTION]) is
			-- Set child list.
		require
			child_list_not_void: a_child_list /= Void
		do
			children := a_child_list
		ensure
			children_set: children = a_child_list
		end

feature {XM_XSLT_INSTRUCTION} -- local

		instruction_indentation (a_level: INTEGER): STRING is
			-- Indentation string prefix, for diagnostic output
		require
			strictly_positive_level: a_level > 0
		local
			counter: INTEGER
		do
			Result := ""
			from
				counter := 1
			variant
				a_level + 1 - counter
			until
				counter > a_level
			loop
				Result := STRING_.appended_string (Result, " ")
				counter := counter + 1
			end
		end

feature {NONE} -- Implementation

	module_number: INTEGER
			-- Index into SYSTEM ID array

invariant

	children_not_void: children /= Void
	executable_not_void: executable /= Void
	positive_module_number: module_number >= 0

end
	
