indexing

	description:

		"Objects that represent an XSLT instruction"

	library: "Gobo Eiffel XSLT Library"
	copyright: "Copyright (c) 2004, Colin Adams and others"
	license: "Eiffel Forum License v2 (see forum.txt)"
	date: "$Date$"
	revision: "$Revision$"

deferred class XM_XSLT_INSTRUCTION

inherit

	KL_IMPORTED_STRING_ROUTINES

	XM_XPATH_DEBUGGING_ROUTINES

feature -- Access

	children: DS_ARRAYED_LIST [XM_XSLT_INSTRUCTION]
			-- Child instructions

	executable: XM_XSLT_EXECUTABLE
			-- Executable

	line_number: INTEGER
			-- Line number within module

	result_type: XM_XPATH_SEQUENCE_TYPE is
			-- Static type of values generated by `Current'
		do
			create Result.make_any_sequence
		ensure
			result_type_not_void: Result /= void
		end

	instruction_name: STRING is
			-- Name of instruction, for diagnostics
		require
			executable_not_void: executable /= Void
		deferred
		ensure
			instruction_name_not_void: Result /= Void
		end

feature -- Status report

	last_tail_call: XM_XSLT_INSTRUCTION
			-- Residue from last call to `process_leaving_tail'

	display_children (a_level: INTEGER; a_pool: XM_XPATH_NAME_POOL) is
			-- Diagnostic print of children to `std.error'
		local
			a_message: STRING
			an_expression: XM_XPATH_EXPRESSION
			a_cursor: DS_ARRAYED_LIST_CURSOR [XM_XSLT_INSTRUCTION]
		do
			from
				a_cursor := children.new_cursor
				a_cursor.start
			variant
				children.count + 1 - a_cursor.index
			until
				a_cursor.after
			loop
				an_expression ?= a_cursor.item
				if an_expression /= Void then
					an_expression.display (a_level, a_pool)
				else
					a_message := STRING_.appended_string (instruction_indentation (a_level), a_cursor.item.instruction_name)
					std.error.put_string (a_message)
					std.error.put_new_line
				end
				a_cursor.forth
			end
		end

feature -- Evaluation

	process_leaving_tail (a_context: XM_XSLT_CONTEXT) is
			-- Execute `Current', writing results to the current `XM_XPATH_RECEIVER'.
		require
			evaluation_context_not_void: a_context /= Void
		deferred
		ensure
			possible_tail_call: last_tail_call = Void or else last_tail_call /= Void
		end

	process (a_context: XM_XSLT_CONTEXT) is
			-- Execute `Current' completely, writing results to the current `XM_XPATH_RECEIVER'.
		require
			evaluation_context_not_void: a_context /= Void
		do
			process_leaving_tail (a_context)
			from
			until
				last_tail_call = Void
			loop
				last_tail_call.process_leaving_tail (a_context)
			end
		ensure
			no_tail_calls: last_tail_call = Void
		end

	process_children (a_context: XM_XSLT_CONTEXT) is
		-- Execute children of `Current' completely, writing results to the current `XM_XPATH_RECEIVER'.
		require
			evaluation_context_not_void: a_context /= Void
		local
			a_transformer: XM_XSLT_TRANSFORMER
			a_cursor: DS_ARRAYED_LIST_CURSOR [XM_XSLT_INSTRUCTION]
		do
			a_transformer := a_context.transformer
			if a_transformer.is_tracing then
				-- TODO
			end
			from
				a_cursor := children.new_cursor
				a_cursor.start
			variant
				children.count + 1 - a_cursor.index
			until
				a_cursor.after
			loop
				if a_transformer.is_tracing then
					-- TODO
				end
				a_cursor.item.process (a_context)
				-- TODO - add error handling
				if a_transformer.is_tracing then
					-- TODO
				end
				a_cursor.forth
			end
		ensure
			no_tail_calls: last_tail_call = Void
		end

feature -- Element change

	set_executable (an_executable: XM_XSLT_EXECUTABLE) is
			-- Set executable.
		require
			executable_not_void: an_executable /= Void
		do
			executable := an_executable
		ensure
			set: executable = an_executable
		end

	set_source_location (a_module_number, a_line_number: INTEGER) is
			-- Set source location information.
		do
			module_number := a_module_number
			line_number := a_line_number
		ensure
			line_number_set: line_number = a_line_number
			system_id_set: module_number = a_module_number
		end

	set_children (a_child_list: DS_ARRAYED_LIST [XM_XSLT_INSTRUCTION]) is
			-- Set child list.
		require
			child_list_not_void: a_child_list /= Void
		do
			children := a_child_list
		ensure
			children_set: children = a_child_list
		end

feature {XM_XSLT_INSTRUCTION} -- local

		instruction_indentation (a_level: INTEGER): STRING is
			-- Indentation string prefix, for diagnostic output
		require
			strictly_positive_level: a_level > 0
		local
			counter: INTEGER
		do
			Result := ""
			from
				counter := 1
			variant
				a_level + 1 - counter
			until
				counter > a_level
			loop
				Result := STRING_.appended_string (Result, " ")
				counter := counter + 1
			end
		end

feature {NONE} -- Implementation

	module_number: INTEGER
			-- Index into SYSTEM ID array

invariant

	children_not_void: children /= Void

end
	
