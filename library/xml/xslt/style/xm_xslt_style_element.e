indexing

	description:

		"Element nodes in an XSLT stylesheet"

	library: "Gobo Eiffel XSLT Library"
	copyright: "Copyright (c) 2004, Colin Adams and others"
	license: "Eiffel Forum License v2 (see forum.txt)"
	date: "$Date$"
	revision: "$Revision$"

deferred class XM_XSLT_STYLE_ELEMENT

inherit

	XM_XPATH_TREE_ELEMENT

	XM_UNICODE_CHARACTERS_1_1

	XM_XPATH_DEBUGGING_ROUTINES

feature -- Access

	extension_namespaces: DS_ARRAYED_LIST [INTEGER]
			-- Namespace URI codes of extension elements

	excluded_namespaces: DS_ARRAYED_LIST [INTEGER]
			-- Namespace URI codes to be excluded from output

	default_xpath_namespace: STRING
			-- Default XPath namespace

	version: STRING -- TODO MA_DECIMAL

	is_instruction: BOOLEAN
			-- Is `Current' an instruction?

	containing_stylesheet: XM_XSLT_STYLESHEET is
			-- Containing stylesheet;
			-- N.B. This may not be the principal stylersheet, it may be 
			--  an included or imported module.
		local
			a_node: XM_XPATH_TREE_COMPOSITE_NODE
		do
			from
				a_node := Current
				Result ?= a_node
			until
				Result /= Void
			loop
				a_node := a_node.parent
				Result ?= a_node
			end
		ensure
			containing_stylesheet_not_void: Result /= Void
		end

	prinicpal_stylesheet: XM_XSLT_STYLESHEET is
			-- Top-level stylesheet
		local
			another_stylesheet: XM_XSLT_STYLESHEET
		do
			from
				Result := containing_stylesheet
				another_stylesheet := Result.importer
			until
				another_stylesheet = Void
			loop
					Result := another_stylesheet
					another_stylesheet := Result.importer
			end
		ensure
			prinicpal_stylesheet_not_void: Result /= Void
		end

	target_name_pool: XM_XPATH_NAME_POOL is
			-- Name pool to be used at run-time;
			-- This namepool holds the names used in
			--  all XPath expressions and patterns.
		do
			Result := prinicpal_stylesheet.target_name_pool
		ensure
			target_name_pool_not_void: Result /= Void
		end

	attribute_value_by_expanded_name (an_attribute_name: STRING): STRING is
			-- Value of `an_attribute_name'
		require
			valid_attribute_name: an_attribute_name /= Void
				and then	is_valid_expanded_name (an_attribute_name)
		local
		do
			if not document.name_pool.is_expanded_name_allocated (an_attribute_name) then
				document.name_pool.allocate_expanded_name (an_attribute_name)
			end
			Result := attribute_value (document.name_pool.fingerprint_from_expanded_name (an_attribute_name))
		end

	precedence: INTEGER is
			-- Import precedence of `Current'
		do
			Result := containing_stylesheet.precedence
		end

	uri_for_prefix (an_xml_prefix: STRING; use_default_namespace: BOOLEAN): STRING is
			-- URI for `an_xml_prefix' using the in-scope namespaces
		require
			prefix_not_void: an_xml_prefix /= Void
		local
			a_uri_code: INTEGER
		do
			if not use_default_namespace and then STRING_.same_string (an_xml_prefix, "") then
				Result := ""
			else
				a_uri_code := uri_code_for_prefix (an_xml_prefix)
				Result := document.name_pool.uri_from_uri_code (a_uri_code)
			end
		ensure
			uri_not_void: Result /= Void
		end

feature -- Status_report

	last_generated_name_code: INTEGER
			-- Last name code generated by `generate_name_code'

	is_stylesheet_in_error: BOOLEAN is
			-- is any element of the stylsheet tree compiled in error?
		local
			a_cursor: DS_ARRAYED_LIST_CURSOR [XM_XPATH_TREE_NODE]
			a_style_element: XM_XSLT_STYLE_ELEMENT
		do
			if is_error then Result := True
			else

				-- recusively check all the children

				from
					a_cursor := children.new_cursor
					a_cursor.start
				variant
					children.count + 1 - a_cursor.index
				until
					a_cursor.after
				loop
					a_style_element ?= a_cursor.item
					if a_style_element /= Void then
						if a_style_element.is_stylesheet_in_error then
							Result := True
							debug ("XSLT stylesheet compilation")
								std.error.put_string ("Style element marked in error:%N")
								std.error.put_string (a_style_element.error_value.error_message)
								print (a_style_element);print ("%N")
							end
							a_cursor.go_after
						end
					end
					if not a_cursor.after then a_cursor.forth end
				end
			end
		end

	is_forwards_compatible_processing_enabled: BOOLEAN is
			-- Is forwards-compatible mode enabled for this element?
		do
			todo ("is_forwards_compatible_processing_enabled - needs MA_DECIAML", False)
		end

	check_unknown_attribute (a_name_code: INTEGER) is
			-- Check whether an unknown attribute is permitted.
		local
			an_attribute_uri, an_element_uri, a_local_name, a_message: STRING
		do
			if not is_forwards_compatible_processing_enabled then
				an_attribute_uri := document.name_pool.namespace_uri_from_name_code (a_name_code)
				an_element_uri := uri
				a_local_name := document.name_pool.local_name_from_name_code (a_name_code)

				-- Allow xsl:extension-element-prefixes etc on an extension element.

				if is_instruction and then
					STRING_.same_string (an_attribute_uri, Xslt_uri) and then
					not STRING_.same_string (an_element_uri, Xslt_uri) and then
					(
					 STRING_.same_string (a_local_name, Xpath_default_namespace_attribute) or else
					 STRING_.same_string (a_local_name, Extension_element_prefixes_attribute) or else
					 STRING_.same_string (a_local_name, Exclude_result_prefixes_attribute) or else
					 STRING_.same_string (a_local_name, Version_attribute)
					 ) then
					do_nothing

					-- Allow standard attributes on an XSLT element.

				elseif STRING_.same_string (an_element_uri, Xslt_uri) and then
					STRING_.same_string (an_attribute_uri, "") and then
					(
					 STRING_.same_string (a_local_name, Xpath_default_namespace_attribute) or else
					 STRING_.same_string (a_local_name, Extension_element_prefixes_attribute) or else
					 STRING_.same_string (a_local_name, Exclude_result_prefixes_attribute) or else
					 STRING_.same_string (a_local_name, Version_attribute)
					 ) then
					do_nothing
				elseif STRING_.same_string (an_attribute_uri, "") or else
					STRING_.same_string (an_attribute_uri, Xslt_uri) then
					a_message := STRING_.appended_string ("Attribute ", document.name_pool.display_name_from_name_code (a_name_code))
					a_message := STRING_.appended_string (a_message, " is not allowed on this element")
					set_last_error_from_string (a_message, 0, Static_error)
				end
			end
		end

feature -- Element change

	generate_name_code (a_qname: STRING) is
			-- Generate a name code and register it in the name pool.
			-- `Current' is used as the context for namespace resolution.
			-- The default namespace is not used.
		require
			valid_qname: a_qname /= Void and then is_qname (a_qname)
		local
			a_string_splitter: ST_SPLITTER
			qname_parts: DS_LIST [STRING]
			an_xml_prefix, a_uri, a_local_name, a_message: STRING
			a_uri_code: INTEGER			
			a_name_pool: XM_XPATH_NAME_POOL
		do
			a_name_pool := target_name_pool
			create a_string_splitter.make
			a_string_splitter.set_separators (":")
			qname_parts := a_string_splitter.split (a_qname)
			if qname_parts.count = 1 then
				an_xml_prefix := ""
				if a_name_pool.is_name_code_allocated_using_uri_code (an_xml_prefix, a_uri_code, a_qname) then
					last_generated_name_code := a_name_pool.name_code (an_xml_prefix, a_name_pool.uri_from_uri_code (a_uri_code), a_qname)
				else
					if not a_name_pool.is_name_pool_full_using_uri_code (a_uri_code, a_qname) then
						a_name_pool.allocate_name_using_uri_code (an_xml_prefix, a_uri_code, a_qname)
						last_generated_name_code := a_name_pool.last_name_code
					else
						a_message := STRING_.appended_string ("Name pool has no room to allocate ", a_qname)
						set_last_error_from_string (a_message, 0, Static_error)
						last_generated_name_code := -1
					end
				end
			else
				check
					two_parts: qname_parts.count = 2
				end
				an_xml_prefix := qname_parts.item (1)
				a_local_name := qname_parts.item (2)
				a_uri := uri_for_prefix (an_xml_prefix, False)
				if is_reserved_namespace (a_uri) then
					a_message := STRING_.appended_string ("Namespace prefix ", an_xml_prefix)
					a_message := STRING_.appended_string (a_message, " refers to a reserved namespace")
					set_last_error_from_string (a_message, 0, Static_error)
				else
					if a_name_pool.is_name_code_allocated (an_xml_prefix, a_uri, a_local_name) then
						last_generated_name_code := a_name_pool.name_code (an_xml_prefix, a_uri, a_local_name)
					else
						if not a_name_pool.is_name_pool_full (a_uri, a_local_name) then
							a_name_pool.allocate_name (an_xml_prefix, a_uri, a_local_name)
							last_generated_name_code := a_name_pool.last_name_code
						else
							a_message := STRING_.appended_string ("Name pool has no room to allocate {", a_uri)
							a_message := STRING_.appended_string (a_message, "}")
							a_message := STRING_.appended_string (a_message, a_local_name)
							set_last_error_from_string (a_message, 0, Static_error)
							last_generated_name_code := -1
						end
					end
				end
			end
		end

	allocate_slots (an_expr: XM_XPATH_EXPRESSION) is
			-- TODO
		do
			todo ("allocate_slots", False)
		end

	prepare_attributes is
			-- Set the attribute list for the element.
		deferred
		end

	process_attributes is
			-- Process the attribute list for the element.
		do
			prepare_attributes
			if is_error then
				todo ("process_attributes", True)
			end
		end

	
	process_all_attributes is
			-- Process the attributes of this element and all its children
		local
			a_static_context: XM_XSLT_EXPRESSION_CONTEXT
			a_child_iterator: XM_XPATH_SEQUENCE_ITERATOR [XM_XPATH_NODE]
			a_style_element: like Current
		do
			create a_static_context
			process_attributes
			from
				a_child_iterator := new_axis_iterator (Child_axis)
				a_child_iterator.start
			until
				a_child_iterator.after
			loop
				a_style_element ?= a_child_iterator.item
				if a_style_element /= Void then
					a_style_element.process_all_attributes
				end
				a_child_iterator.forth
			end
		end

	process_default_xpath_namespace_attribute (an_attribute_name: STRING) is
			--	Process the [xsl:]default-xpath-namespace attribute. 
		require
			valid_attribute_name: an_attribute_name /= Void
				and then	is_valid_expanded_name (an_attribute_name)
				and then STRING_.same_string (local_name_from_expanded_name (an_attribute_name), Xpath_default_namespace_attribute)
				and then ( namespace_uri_from_expanded_name (an_attribute_name).count = 0
							  or else STRING_.same_string (namespace_uri_from_expanded_name (an_attribute_name), Xslt_uri))
		do
			default_xpath_namespace := attribute_value_by_expanded_name (an_attribute_name)
		end

	process_version_attribute (an_attribute_name: STRING) is
			--	Process the [xsl:]version attribute. 
		require
			valid_attribute_name: an_attribute_name /= Void
				and then	is_valid_expanded_name (an_attribute_name)
				and then STRING_.same_string (local_name_from_expanded_name (an_attribute_name), Version_attribute)
				and then ( namespace_uri_from_expanded_name (an_attribute_name).count = 0
							  or else STRING_.same_string (namespace_uri_from_expanded_name (an_attribute_name), Xslt_uri))
		local
			a_version: STRING
		do
			a_version := attribute_value_by_expanded_name (an_attribute_name)
			todo ("process_version_attribute - need MA_DECIMAL", True)
			version := a_version -- TODO, version must become MA_DECIMAL
		end

	process_extension_element_attribute (an_attribute_name: STRING) is
			--	Process the [xsl:]extension-element-prefixes attribute. 
		require
			valid_attribute_name: an_attribute_name /= Void
				and then	is_valid_expanded_name (an_attribute_name)
				and then STRING_.same_string (local_name_from_expanded_name (an_attribute_name), Extension_element_prefixes_attribute)
				and then ( namespace_uri_from_expanded_name (an_attribute_name).count = 0
							  or else STRING_.same_string (namespace_uri_from_expanded_name (an_attribute_name), Xslt_uri))
		local
			extensions, an_extension: STRING
			a_splitter: ST_SPLITTER
			an_extension_list: DS_LIST [STRING]
			a_cursor: DS_LIST_CURSOR [STRING]
		do
			extensions := attribute_value_by_expanded_name (an_attribute_name)
			if extensions /= Void then
				create a_splitter.make
				an_extension_list := a_splitter.split (extensions)
				if an_extension_list.count > 0 then
					create extension_namespaces.make (an_extension_list.count)
					from
						a_cursor := an_extension_list.new_cursor
						a_cursor.start
					variant
						an_extension_list.count + 1 - a_cursor.index
					until
						a_cursor.after
					loop
						an_extension := a_cursor.item
						if STRING_.same_string (an_extension, "#default") then
							an_extension := ""
						end
						extension_namespaces.put_last (uri_code_for_prefix (an_extension))
						a_cursor.forth
					end
				end
			end
		end

	process_excluded_namespaces_attribute (an_attribute_name: STRING) is
			--	Process the  [xsl:]exclude-result-prefixes attribute.
		require
			valid_attribute_name: an_attribute_name /= Void
				and then	is_valid_expanded_name (an_attribute_name)
				and then STRING_.same_string (local_name_from_expanded_name (an_attribute_name), Exclude_result_prefixes_attribute)
				and then ( namespace_uri_from_expanded_name (an_attribute_name).count = 0
							  or else STRING_.same_string (namespace_uri_from_expanded_name (an_attribute_name), Xslt_uri))
		local
			exclusions, an_exclusion: STRING
			a_splitter: ST_SPLITTER
			an_exclusion_list: DS_LIST [STRING]
			a_cursor: DS_LIST_CURSOR [STRING]
		do
			exclusions := attribute_value_by_expanded_name (an_attribute_name)
			if exclusions /= Void then
				exclusions.left_adjust
				exclusions.right_adjust
				if STRING_.same_string (exclusions, "#all") then
					todo ("process_excluded_namespaces_attribute - #all", True)
				else
					create a_splitter.make
					an_exclusion_list := a_splitter.split (exclusions)
					if an_exclusion_list.count > 0 then
						create excluded_namespaces.make (an_exclusion_list.count)
						from
							a_cursor := an_exclusion_list.new_cursor
							a_cursor.start
						variant
							an_exclusion_list.count + 1 - a_cursor.index
						until
							a_cursor.after
						loop
							an_exclusion := a_cursor.item
							if STRING_.same_string (an_exclusion, "#default") then
								an_exclusion := ""
							elseif STRING_.same_string (an_exclusion, "#all") then
								set_last_error_from_string ("In exclude-result-prefixes, cannot mix #all with other values", 0, Static_error)
								a_cursor.go_after
							end
							excluded_namespaces.put_last (uri_code_for_prefix (an_exclusion))
							a_cursor.forth
						end
					end					
				end
			end
		end

end
