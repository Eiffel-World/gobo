indexing

	description:

		"Interface compatibility with class ARRAY as described in %
		%the Eiffel Library Kernel Standard vintage '95 from NICE; %
		%used for implementation of data structures using arrays";

	library:    "Gobo Eiffel Structure Library";
	author:     "Eric Bezault <ericb@gobo.demon.co.uk>";
	copyright:  "Copyright (c) 1997, Eric Bezault";
	date:       "$Date$";
	revision:   "$Revision$"

class DS_ARRAYED [G]

#ifdef ISE || HACT
inherit

	ARRAY [G]
		rename
			empty as ise_empty,
			full as ise_full,
			has as ise_has,
			capacity as ise_capacity,
			wipe_out as ise_wipe_out,
			prune as ise_prune,
			extend as ise_extend,
			extendible as ise_extendible,
			object_comparison as ise_object_comparison,
			occurrences as ise_occurrences
		end

creation

	make, make_from_array
#else
#ifdef SE
inherit

	ANY
		redefine
			copy, is_equal
		end

creation

	make, make_from_array

feature {NONE} -- Initialization

	make (minindex, maxindex: INTEGER) is
			-- Allocate array; set index interval to 
			-- `minindex'..`maxindex'; set all values 
			-- to default.
		require
			valid_indices: minindex <= maxindex + 1
		do
			!! handle.make (minindex, maxindex)
		ensure
			lower_set: lower = minindex
			upper_set: upper = maxindex
		end

	make_from_array (an_array: ARRAY [G]) is
			-- Initialize from the items of `an_array'.
		require
			an_array_not_void: an_array /= Void
		do
			!! handle.from_collection (an_array)
		ensure
			lower_set: lower = an_array.lower
			upper_set: upper = an_array.upper
		end

feature -- Access

	item, infix "@" (i: INTEGER): G is
			-- Entry at index `i'
		require
			valid_index: valid_index (i)
		do
			Result := handle.item (i)
		end

feature -- Measurement

	count: INTEGER is
			-- Number of available indices
		do
			Result := handle.count
		end

	lower: INTEGER is
			-- Minimum index
		do
			Result := handle.lower
		end

	upper: INTEGER is
			-- Maximum index
		do
			Result := handle.upper
		end

feature -- Status report

	valid_index (i: INTEGER): BOOLEAN is
			-- Is `i' within array bounds?
		do
			Result := lower <= i and i <= upper
		end

feature -- Comparison

	is_equal (other: like Current): BOOLEAN is
			-- Is array equal to `other'?
		do
			Result := handle.is_equal (other.handle)
		end

feature -- Duplication

	copy (other: like Current) is
			-- Copy `other' to cuurent array.
		do
			standard_copy (other)
			handle := clone (other.handle)
		end

feature -- Element change

	put (v: like item; i: INTEGER) is
			-- Replace `i'-th entry by `v'.
		require
			valid_index: valid_index (i)
		do
			handle.put (v, i)
		ensure
			inserted: item (i) = v
		end

	force (v: like item; i: INTEGER) is
			-- Replace `i'-th entry by `v'.
			-- Resize array if necessary.
		do
			handle.force (v, i)
		ensure
			inserted: item (i) = v
			higher_count: count >= old count
		end

feature -- Resizing

	resize (minindex, maxindex: INTEGER) is
			-- Resize array.
			-- Do not lose any previously entered item.
		require
			valid_indices: minindex <= maxindex + 1
		do
			handle.resize (minindex, maxindex)
		ensure
			lower_set: lower = minindex.min (old lower)
			upper_set: upper = maxindex.max (old upper)
		end

feature {ELKS_ARRAY} -- Implementation

	handle: ARRAY [G]
			-- Handle to array

invariant

	consistent_size: count = upper - lower + 1
	positive_count: count >= 0
	handle_not_void: handle /= Void
#else
inherit

	ARRAY [G]

creation

	make, make_from_array
#endif
#endif

end -- class DS_ARRAYED
