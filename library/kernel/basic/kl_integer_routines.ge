indexing

	description:

		"Routines that ought to be in class INTEGER"

	library: "Gobo Eiffel Kernel Library"
	copyright: "Copyright (c) 1999, Eric Bezault and others"
	license: "Eiffel Forum License v2 (see forum.txt)"
	date: "$Date$"
	revision: "$Revision$"

class KL_INTEGER_ROUTINES

inherit

	KL_SHARED_PLATFORM
	KL_IMPORTED_STRING_ROUTINES

feature -- Conversion

	to_character (an_int: INTEGER): CHARACTER is
			-- Character whose code is `an_int'
		require
			an_int_large_enough: an_int >= Platform.Minimum_character_code
			an_int_small_enough: an_int <= Platform.Maximum_character_code
		do
#ifdef VE
			Result.from_integer (an_int)
#endif
#ifdef ISE || SE
			Result := an_int.to_character
#endif
		ensure
			valid_character_code: Result.code = an_int
		end

	to_hexadecimal (an_int: INTEGER; uppercase: BOOLEAN): STRING is
			-- Hexadecimal representation of `an_int';
			-- Return a new string at each call.
		require
			an_int_positive: an_int >= 0
		do
			create Result.make (8) -- Max 8 hexadecimal digits for 32-bits
			append_hexadecimal_integer (Result, an_int, uppercase)
		ensure
			hexadecimal_not_void: Result /= Void
			is_string: Result.same_type ("")
			-- regexp_uppercase: uppercase implies (0|[1-9A-F][0-9A-F]*).recognizes (Result)
			-- regexp_lowercase: not uppercase implies (0|[1-9a-f][0-9a-f]*).recognizes (Result)
		end

feature -- Output

	append_hexadecimal_integer (a_string: STRING; an_int: INTEGER; uppercase: BOOLEAN) is
			-- Append a hexadecimal representation of `an_int' to `a_string'.
			-- Note: works even when `a_string' is a UC_STRING.
		require
			a_string_not_void: a_string /= Void
			an_int_positive: an_int >= 0
		local
			k: INTEGER
		do
			if an_int = 0 then
				a_string.append_character ('0')
			else
				k := an_int // 16
				if k /= 0 then
					append_hexadecimal_integer (a_string, k, uppercase)
				end
				inspect an_int \\ 16
				when 0 then
					a_string.append_character ('0')
				when 1 then
					a_string.append_character ('1')
				when 2 then
					a_string.append_character ('2')
				when 3 then
					a_string.append_character ('3')
				when 4 then
					a_string.append_character ('4')
				when 5 then
					a_string.append_character ('5')
				when 6 then
					a_string.append_character ('6')
				when 7 then
					a_string.append_character ('7')
				when 8 then
					a_string.append_character ('8')
				when 9 then
					a_string.append_character ('9')
				when 10 then
					if uppercase then
						a_string.append_character ('A')
					else
						a_string.append_character ('a')
					end
				when 11 then
					if uppercase then
						a_string.append_character ('B')
					else
						a_string.append_character ('b')
					end
				when 12 then
					if uppercase then
						a_string.append_character ('C')
					else
						a_string.append_character ('c')
					end
				when 13 then
					if uppercase then
						a_string.append_character ('D')
					else
						a_string.append_character ('d')
					end
				when 14 then
					if uppercase then
						a_string.append_character ('E')
					else
						a_string.append_character ('e')
					end
				when 15 then
					if uppercase then
						a_string.append_character ('F')
					else
						a_string.append_character ('f')
					end
				end
			end
		ensure
			-- regexp_uppercase: uppercase implies (0|[1-9A-F][0-9A-F]*).recognizes (a_string.substring (old a_string.count + 1, a_string.count))
			-- regexp_lowercase: not uppercase implies (0|[1-9a-f][0-9a-f]*).recognizes (a_string.substring (old a_string.count + 1, a_string.count))
		end

feature -- Operation(s)

	power (x, n: INTEGER): INTEGER is
			-- Integer `x' to the power of `n' (`x' ^ `n')
		require
			positive_n: n >= 0
		do
			if n = 0 then
				Result := 1
			elseif n = 1 then
				Result := x
			elseif x /= 0 then
				if is_even (n) then
						-- x ^ 2N = (x ^ N) ^ 2
					Result := power (x, n // 2)
					Result := Result * Result
				else
					Result := power (x, n - 1) * x
				end
			end
		ensure
			zero_power_n: x = 0 and n /= 0 implies Result = 0
			x_power_0: n = 0 implies Result = 1
			recursive_definition: n > 0 implies (Result = x * power (x, n - 1))
		end

	bit_and (m, n: INTEGER): INTEGER is
			-- Bitwise 'and' between `m' and `n'
		local
#ifdef VE
			i,j: BIT 32
#endif
		do
#ifdef VE
			i.from_integer (m)
			j.from_integer (n)
			Result := (i and j).to_integer
#endif
#ifdef ISE
			Result := m.bit_and (n)
#endif
#ifdef SE
			Result := m.bit_and (n)
#endif
		end

	bit_or (m, n: INTEGER): INTEGER is
			-- Bitwise 'or' between `m' and `n'
		local
#ifdef VE
			i,j: BIT 32
#endif
		do
#ifdef VE
			i.from_integer (m)
			j.from_integer (n)
			Result := (i or j).to_integer
#endif
#ifdef ISE
			Result := m.bit_or (n)
#endif
#ifdef SE
			Result := m.bit_or (n)
#endif
		end

	bit_shift_left (m, n: INTEGER): INTEGER is
			-- `m' shifted `n' bits to left;
			-- Note: The new bits added on the right are 0.
		require
			thirty_two_bit_shift: 0 <= n and n < 32
		local
#ifdef VE
			i: BIT 32
#endif
		do
#ifdef VE
			i.from_integer (m)
			Result := (i ^ -n).to_integer
#endif
#ifdef ISE
			Result := m.bit_shift_left (n)
#endif
#ifdef SE
			Result := m.bit_shift_left (n.to_integer_8)
#endif
		end


	bit_shift_right (m, n: INTEGER): INTEGER is
			-- `m' shifted `n' bits to right;
			-- Note: If the first bit of `m' is set (i.e. the sign bit), then
			-- the new bits added on the left are 1; otherwise they are 0.
		require
			thirty_two_bit_shift: 0 <= n and n < 32
		local
#ifdef VE
			b: BIT 32
			i: INTEGER
#endif
		do
#ifdef VE
			b.from_integer (m)
			b := b ^ n
			if m < 0 then
				i := 32 - n + 1
				from until i > 32 loop
					b.put (True, i)
					i := i + 1
				end
			end
			Result := b.to_integer
#endif
#ifdef ISE
			Result := m.bit_shift_right (n)
#endif
#ifdef SE
			Result := m.bit_shift_right (n.to_integer_8)
#endif
		end

feature -- Status report

	is_even (an_int: INTEGER): BOOLEAN is
			-- Is `an_int' an even integer?
		do
			Result := an_int \\ 2 = 0
		ensure
			definition: Result = (an_int \\ 2 = 0)
		end

end
