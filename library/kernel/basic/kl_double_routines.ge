indexing

	description:

		"Routines that ought to be in class DOUBLE"

	library: "Gobo Eiffel Kernel Library"
	copyright: "Copyright (c) 2003-2006, Eric Bezault and others"
	license: "MIT License"
	date: "$Date$"
	revision: "$Revision$"

class KL_DOUBLE_ROUTINES

inherit

#ifdef ISE
	DOUBLE_MATH
		rename
			log as old_log,
			log10 as old_log10,
			exp as old_exp
		export
			{NONE} all
		end

#endif
#ifdef VE
	MATH
		rename
			log as old_log,
			exp as old_exp
		export
			{NONE} all
		end

#endif

	KL_SHARED_PLATFORM

feature -- Logarithms

	log (d: DOUBLE): DOUBLE is
			-- Natural logarithm of `d'
		require
			d_positive: d > 0.0
		do
#ifdef SE
			Result := d.log
#endif
#ifdef ISE
			Result := old_log (d)
#endif
#ifdef VE
			Result := old_log (d.truncated_to_real)
#endif
		end

	log2 (d: DOUBLE): DOUBLE is
			-- Base 2 logarithm of `d'
		require
			d_positive: d > 0.0
#ifdef VE || SE
		local
#endif
#ifdef SE
			a: DOUBLE
#endif
#ifdef VE
			a: REAL
#endif
		do
#ifdef ISE
			Result := log_2 (d)
#endif
#ifdef VE || SE
			a := 2.0
#endif
#ifdef SE
			Result := d.log / a.log
#endif
#ifdef VE
			Result := old_log (d.truncated_to_real) / log (a)
#endif
		end

	log10 (d: DOUBLE): DOUBLE is
			-- Base 10 logarithm of `d'
		require
			d_positive: d > 0.0
		do
#ifdef SE
			Result := d.log10
#endif
#ifdef ISE
			Result := old_log10 (d)
#endif
#ifdef VE
			Result := log (d) / log (10.0)
#endif
		end

feature -- Exponent

	exp (d: DOUBLE): DOUBLE is
			-- Inverse of the natural logarithm
		do
#ifdef SE
			Result := d.exp
#endif
#ifdef ISE
			Result := old_exp (d)
#endif
#ifdef VE
			Result := old_exp (d.truncated_to_real)
#endif
		end

	nth_root (d, n: DOUBLE): DOUBLE is
			-- `n'-th root of `d'
		require
#ifdef VE
			divisible: (1.0).divisible (n.truncated_to_real)
#else
			divisible: (1.0).divisible (n)
#endif
		do
#ifdef ISE || VE
			Result := d ^ (1.0 / n)
#endif
#ifdef SE
			Result := d.pow (1.0 / n)
#endif
		end

feature -- Conversion

	truncated_to_integer (d: DOUBLE): INTEGER is
			-- Integer part (Same sign, largest absolute
			-- value no greater than current object's)
		require
			d_large_enough: d >= Platform.Minimum_integer
			d_small_enough: d <= Platform.Maximum_integer
		do
			Result := d.truncated_to_integer
		end

	rounded_to_integer (d: DOUBLE): INTEGER is
			-- Rounded integral value
		require
			d_large_enough: (d.abs + 0.5) >= Platform.Minimum_integer
			d_small_enough: (d.abs + 0.5) < (Platform.Maximum_integer + 1.0)
		do
#ifdef ISE
			Result := d.rounded
#else
			Result := d.sign * floor_to_integer (d.abs + 0.5)
#endif
		ensure
			definition: Result = d.sign * floor_to_integer (d.abs + 0.5)
		end

	floor_to_integer (d: DOUBLE): INTEGER is
			-- INTEGER floor
			-- (floor returns integer in ELKS, but a floating point value with SE2)
		require
			d_large_enough: d >= Platform.Minimum_integer
			d_small_enough: d < (Platform.Maximum_integer + 1.0)
		do
			Result := d.truncated_to_integer
			if d.floor /= Result then
				Result := Result - 1
			end
		ensure
			definition: Result = d.floor
		end

feature -- NaN

	is_nan (d: DOUBLE): BOOLEAN is
			-- Does `d' correspond to a Not-A-Number?
#ifdef ISE
		local
			p1: MANAGED_POINTER
			b1, b2, b3, b4, b5, b6, b7, b8: NATURAL_8
		do
				-- Do not compare `d' with itself directly (it should return False in case
				-- of NaN as explained in http://en.wikipedia.org/wiki/NaN) as a workaround
				-- because of a bug in lcc-win32 when used as back-end C compiler of gec.
			create p1.make (8)
			p1.put_real_64 (d, 0)
			b1 := p1.read_natural_8 (0)
			b2 := p1.read_natural_8 (1)
			b3 := p1.read_natural_8 (2)
			b4 := p1.read_natural_8 (3)
			b5 := p1.read_natural_8 (4)
			b6 := p1.read_natural_8 (5)
			b7 := p1.read_natural_8 (6)
			b8 := p1.read_natural_8 (7)
			if b8 = 127 or b8 = 255 then
				if b7 > 240 then
					Result := True
				elseif b7 = 240 then
					Result := b6 /= 0 or b5 /= 0 or b4 /= 0 or b3 /= 0 or b2 /= 0 or b1 /= 0
				end
			end
#else
		local
			d1: DOUBLE
		do
			d1 := d
			Result := (d /= d1)
#endif
		end

feature -- Infinity

	is_plus_infinity (d: DOUBLE): BOOLEAN is
			-- Does `d' correspond to positive infinity?
#ifdef ISE
		local
			p1, p2: MANAGED_POINTER
		do
				-- Do not compare `d' with `plus_infinity' directly as a workaround
				-- because of a bug in lcc-win32 when used as back-end C compiler of gec.
			create p1.make (8)
			p1.put_real_64 (d, 0)
			create p2.make (8)
			p2.put_real_64 (plus_infinity, 0)
			Result := p1.read_natural_64 (0) = p2.read_natural_64 (0)
#else
		do
			Result := (d = plus_infinity)
#endif
		end

	is_minus_infinity (d: DOUBLE): BOOLEAN is
			-- Does `d' correspond to minus infinity?
#ifdef ISE
		local
			p1, p2: MANAGED_POINTER
		do
				-- Do not compare `d' with `minus_infinity' directly as a workaround
				-- because of a bug in lcc-win32 when used as back-end C compiler of gec.
			create p1.make (8)
			p1.put_real_64 (d, 0)
			create p2.make (8)
			p2.put_real_64 (minus_infinity, 0)
			Result := p1.read_natural_64 (0) = p2.read_natural_64 (0)
#else
		do
			Result := (d = minus_infinity)
#endif
		end

	plus_infinity: DOUBLE is
			-- Positive infinity
#ifdef ISE
		local
			p: MANAGED_POINTER
		once
				-- Binary representation of IEEE 754 '+infinity'.
				-- See: http://en.wikipedia.org/wiki/IEEE_754
			create p.make (8)
			p.put_natural_8 (0, 0)
			p.put_natural_8 (0, 1)
			p.put_natural_8 (0, 2)
			p.put_natural_8 (0, 3)
			p.put_natural_8 (0, 4)
			p.put_natural_8 (0, 5)
			p.put_natural_8 (240, 6)
			p.put_natural_8 (127, 7)
			Result := p.read_real_64 (0)
#else
#ifdef VE
		local
			p: RTS_MEMORY_MAPPED_AREA_ARRAY [CHARACTER]
		once
				-- Binary representation of IEEE 754 '+infinity'.
				-- See: http://en.wikipedia.org/wiki/IEEE_754
			create p.make ($Result, 8)
			p.put ('%/0/', 1)
			p.put ('%/0/', 2)
			p.put ('%/0/', 3)
			p.put ('%/0/', 4)
			p.put ('%/0/', 5)
			p.put ('%/0/', 6)
			p.put ('%/240/', 7)
			p.put ('%/127/', 8)
#else
		local
			d1: DOUBLE
			large_number: DOUBLE
		once
				-- Overflow on purpose. Note that Borland bcc 5.5.1 raises
				-- an exception when there is an overflow.
			large_number := 2.0e300
				-- Bug in SE 1.2r7: make sure that this once-function is
				-- not precomputed otherwise MSVC 7.1 complains about a
				-- division by zero at compilation time.
			-- Result := large_number * large_number
			d1 := large_number
			Result := d1 * d1
#endif
#endif
		ensure
			positive: Result > 0
		end

	minus_infinity: DOUBLE is
			-- Negative infinity
#ifdef ISE
		local
			p: MANAGED_POINTER
		once
				-- Binary representation of IEEE 754 '-infinity'.
				-- See: http://en.wikipedia.org/wiki/IEEE_754
			create p.make (8)
			p.put_natural_8 (0, 0)
			p.put_natural_8 (0, 1)
			p.put_natural_8 (0, 2)
			p.put_natural_8 (0, 3)
			p.put_natural_8 (0, 4)
			p.put_natural_8 (0, 5)
			p.put_natural_8 (240, 6)
			p.put_natural_8 (255, 7)
			Result := p.read_real_64 (0)
#else
#ifdef VE
		local
			p: RTS_MEMORY_MAPPED_AREA_ARRAY [CHARACTER]
		once
				-- Binary representation of IEEE 754 '+infinity'.
				-- See: http://en.wikipedia.org/wiki/IEEE_754
			create p.make ($Result, 8)
			p.put ('%/0/', 1)
			p.put ('%/0/', 2)
			p.put ('%/0/', 3)
			p.put ('%/0/', 4)
			p.put ('%/0/', 5)
			p.put ('%/0/', 6)
			p.put ('%/240/', 7)
			p.put ('%/255/', 8)
#else
		local
			d1, d2: DOUBLE
			large_number: DOUBLE
			large_negative_number: DOUBLE
		once
				-- Overflow on purpose. Note that Borland bcc 5.5.1 raises
				-- an exception when there is an overflow.
			large_number := 2.0e300
			large_negative_number := -2.0e300
				-- Bug in SE 1.2r7: make sure that this once-function is
				-- not precomputed otherwise MSVC 7.1 complains about a
				-- division by zero at compilation time.
			-- Result := large_number * large_negative_number
			d1 := large_number
			d2 := large_negative_number
			Result := d1 * d2
#endif
#endif
		ensure
			negative: Result < 0
		end

end
