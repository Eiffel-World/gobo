indexing

	description:

		"Class similuating ISE's class SPECIAL with features `item', `put' and `count'"

	library: "Gobo Eiffel Kernel Library"
	copyright: "Copyright (c) 2003, Eric Bezault and others"
	license: "Eiffel Forum License v2 (see forum.txt)"
	date: "$Date$"
	revision: "$Revision$"

#ifdef ISE || HACT
class DUMMY_SPECIAL [G]
#else
class SPECIAL [G]

inherit

#ifdef SE
	FIXED_ARRAY [G]
		rename
			resize as array_resize
		end
#endif
#ifdef VE
	ARRAY [G]
		rename
			make as array_make,
			make_from_array as array_make_from_array,
			resize as array_resize
		end
#endif

creation

	make, make_from_array

feature {NONE} -- Initialization

#ifdef VE
	make (n: INTEGER) is
			-- Create a new special object.
		require
			non_negative_n: n >= 0
		do
			array_make (0, n - 1)
		ensure
			count_set: count = n
		end

#endif
	make_from_array (an_array: ARRAY [G]) is
			-- Create a new special object and fill it
			-- with items from `an_array'.
		require
			an_array_not_void: an_array /= Void
#ifdef SE
		do
			from_collection (an_array)
#endif
#ifdef VE
		local
			i, j, nb: INTEGER
		do
			i := an_array.lower
			nb := an_array.upper
			make (nb - i + 1)
			from until i > nb loop
				put (an_array.item (i), j)
				j := j + 1
				i := i + 1
			end
#endif
		ensure
			count_set: count = an_array.count
			-- same_items: forall i in 0.. (count - 1),
			--	item (i) = an_array.item (an_array.lower + i)
		end

feature -- Resizing

	resize (n: INTEGER): SPECIAL [G] is
			-- Resize current special object so that it contains
			-- `n' items. Do not lose any previously entered items.
			-- Note: the returned special object might be `Current'
			-- or a newly created special object where items from
			-- `Current' have been copied to.
		require
			n_large_enough: n >= count
		do
			if n = count then
				Result := Current
			else
#ifdef SE
				Result := Current
				array_resize (n)
#endif
#ifdef VE
				Result := Current
				array_resize (0, n - 1)
#endif
			end
		ensure
			special_not_void: Result /= Void
			count_set: Result.count = n
		end

#ifdef SE
feature -- Removal

	clear_all is
			-- Reset all items to default values.
		local
			v: G
		do
			set_all_with (v)
		ensure
			-- all_cleared: forall i in 0..(count - 1),
			--		item (i) = Void or else
			--		item (i) = item (i).default
		end

#endif
invariant

	zero_based: lower = 0

#endif
end
