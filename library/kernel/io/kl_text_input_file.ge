indexing

	description:

		"Text input files. The line separtor of the underlying file system %
		%is automatically converted to %%N when read from the file. %
		%However `read_line' and `read_new_line' are able to recognize %
		%'%%N', '%%R%%N' and '%%R' as line separators."

	library:    "Gobo Eiffel Kernel Library"
	author:     "Eric Bezault <ericb@gobosoft.com>"
	copyright:  "Copyright (c) 2001, Eric Bezault and others"
	license:    "Eiffel Forum Freeware License v1 (see forum.txt)"
	date:       "$Date$"
	revision:   "$Revision$"

class KL_TEXT_INPUT_FILE

inherit

	KI_TEXT_INPUT_FILE
		undefine
#ifdef ISE
			read_to_string,
#endif
			read_to_buffer
		end

	KL_INPUT_FILE
#ifdef ISE || HACT || VE
#ifdef ISE || HACT
		rename
			index as position
		undefine
#ifdef HACT
			medium_table_type,
#endif
			is_plain_text
#endif
#ifdef HACT || VE
		redefine
#ifdef HACT
			file_ps
#endif
#ifdef VE
			read_character,
			read_string
#endif
#endif
		end
#endif

#ifdef ISE || HACT
	PLAIN_TEXT_FILE
		rename
			make as old_make,
			name as old_name,
			exists as old_exists,
			is_readable as old_is_readable,
			is_open_read as old_is_open_read,
			is_open_write as old_is_open_write,
			end_of_file as old_end_of_file,
			is_closed as old_is_closed,
			open_read as old_open_read,
			open_write as old_open_write,
			put_character as old_put_character,
			put_string as old_put_string,
			put_integer as old_put_integer,
			put_boolean as old_put_boolean,
			put_new_line as old_put_new_line,
			read_character as old_read_character,
			read_stream as old_read_stream,
			read_line as old_read_line,
			change_name as old_change_name,
			flush as old_flush,
			close as old_close,
			delete as old_delete
		export
			{NONE} all
		undefine
			file_readable
#ifdef HACT
		redefine
			file_ps
#endif
		end

#endif
creation

	make

feature -- Access

	eol: STRING is "%N"
			-- Line separator

feature -- Input

#ifdef VE
	read_character is
			-- Read the next character in input file.
			-- Make the result available in `last_character'.
		do
			if character_buffer /= Void then
				last_character := character_buffer.item
				character_buffer := character_buffer.right
			elseif old_end_of_file then
				end_of_file := True
			else
				if is_windows then
						-- Windows.
					old_read_character
					if not old_end_of_file then
						if last_character = '%R' then
							old_read_character
							if old_end_of_file then
								last_character := '%R'
							elseif last_character /= '%N' then
								unread_character (last_character)
								last_character := '%R'
							end
						end
					else
						end_of_file := True
					end
				else
					old_read_character
					end_of_file := old_end_of_file
				end
			end
		end

	read_string (nb: INTEGER) is
			-- Read at most `nb' characters from input file.
			-- Make the characters that have actually been read
			-- available in `last_string'.
		local
			old_string: STRING
			i, j: INTEGER
			a_target: STRING
		do
			if is_windows then
					-- Windows.
				if last_string = Void then
					!! last_string.make (nb)
				elseif last_string.count < nb then
					last_string.resize (nb)
				end
				a_target := last_string
				from i := nb until i < 1 loop
					read_character
					if not end_of_file then
						j := j + 1
						a_target.put (last_character, j)
						i := i - 1
					else
						i := 0 -- Jump out of the loop.
					end
				end
				a_target.resize (j)
			elseif character_buffer = Void then
				if not old_end_of_file then
					old_string := last_string
					old_read_stream (nb)
					if last_string = Void then
						if old_string /= Void then
							old_string.wipe_out
							last_string := old_string
						else
							!! last_string.make (0)
						end
					end
				elseif last_string = Void then
					!! last_string.make (0)
				else
					last_string.wipe_out
				end
			else
				if last_string = Void then
					!! last_string.make (nb)
				elseif last_string.count < nb then
					last_string.resize (nb)
				end
				i := read_to_string (last_string, 1, nb)
				last_string.resize (i)
			end
			end_of_file := (last_string.count = 0)
		end

#endif
	read_line is
			-- Read characters from input file until a line separator
			-- or end of file is reached. Make the characters that have
			-- been read available in `last_string' and discard the line
			-- separator characters from the input file.
			-- Line separators recognized by current file are: '%N',
			-- '%R%N and '%R'.
		local
			done: BOOLEAN
			a_target: STRING
			c: CHARACTER
			is_eof: BOOLEAN
			has_carriage: BOOLEAN
		do
			if last_string = Void then
#ifdef VE
				!! last_string.make (0)
#else
				!! last_string.make (256)
#endif
			else
#ifdef ISE
				last_string.clear_all
#endif
#ifdef SE
				last_string.clear
#endif
#ifdef HACT
				last_string.set_count (0)
#endif
#ifdef VE
				last_string.wipe_out
#endif
			end
			is_eof := True
			a_target := last_string
			from until done loop
				read_character
				if end_of_file then
					done := True
				else
					is_eof := False
					c := last_character
					inspect c
					when '%N' then
						done := True
					when '%R' then
						has_carriage := True
					else
						if has_carriage then
								-- Put character back to input file.
							unread_character (c)
							done := True
						else
							a_target.append_character (c)
						end
					end
				end
			end
			end_of_file := is_eof
		end

	read_new_line is
			-- Read a line separator from input file.
			-- Make the characters making up the recognized
			-- line separator available in `last_string',
			-- or make `last_string' empty and leave the
			-- input file unchanged if no line separator
			-- was found.
			-- Line separators recognized by current file are:
			-- '%N', '%R%N and '%R'.
		do
			if last_string = Void then
#ifdef VE
				!! last_string.make (0)
#else
				!! last_string.make (256)
#endif
			else
#ifdef ISE
				last_string.clear_all
#endif
#ifdef SE
				last_string.clear
#endif
#ifdef HACT
				last_string.set_count (0)
#endif
#ifdef VE
				last_string.wipe_out
#endif
			end
			read_character
			if not end_of_file then
				inspect last_character
				when '%N' then
					last_string.append_character ('%N')
				when '%R' then
					last_string.append_character ('%R')
					read_character
					if not end_of_file then
						if last_character = '%N' then
							last_string.append_character ('%N')
						else
								-- Put character back to input file.
							unread_character (last_character)
						end
					end
				else
						-- Put character back to input file.
					unread_character (last_character)
				end
			end
			end_of_file := False
		end

#ifdef SE || HACT
feature {NONE} -- Implementation

#ifdef SE
	old_open_read is
			-- Open file in read-only mode.
		do
			connect_to (name)
		end

#endif
#ifdef HACT
	file_ps (file : POINTER; s : POINTER; length : INTEGER) is
			-- Print `a_string' to `file'.
		external
			"C | <eif_file.h>"
		alias
			"file_pt_ps"
		end

#endif
#endif
end -- class KL_TEXT_INPUT_FILE
