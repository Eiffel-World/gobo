indexing

	description:

		"Binary input files"

	library:    "Gobo Eiffel Kernel Library"
	author:     "Eric Bezault <ericb@gobosoft.com>"
	copyright:  "Copyright (c) 2001, Eric Bezault and others"
	license:    "Eiffel Forum Freeware License v1 (see forum.txt)"
	date:       "$Date$"
	revision:   "$Revision$"

class KL_BINARY_INPUT_FILE

inherit

	KI_BINARY_INPUT_FILE
		redefine
#ifdef ISE
			read_to_string,
#endif
			read_to_buffer
		end

	KL_SHARED_FILE_SYSTEM
#ifdef SE
		rename
			rename_file as se_rename_file
#endif
		export
			{NONE} all
		end

#ifdef ISE || HACT
	RAW_FILE
		rename
			make as old_make,
			name as old_name,
			open_read as old_open_read,
			read_line as old_read_line,
			read_stream as old_read_stream,
			read_character as old_read_character,
			close as old_close,
			delete as old_delete,
			end_of_file as old_end_of_file,
			is_open_read as old_is_open_read,
			is_closed as old_is_closed
		export
			{NONE} all
		redefine
			file_readable
		end
#endif
#ifdef SE
	TEXT_FILE_READ
		rename
			make as old_make,
			is_connected as old_is_open_read,
			rename_file as se_rename_file,
			end_of_input as old_end_of_file,
			read_line as old_read_line,
			read_character as old_read_character,
			unread_character as old_unread_character,
			last_character as old_last_character,
			disconnect as old_close
		export
			{NONE} all
		redefine
			last_string
		end

	FILE_TOOLS
		rename
			rename_file as se_rename_file,
			delete as old_delete,
			tmp_string as old_tmp_string
		export
			{NONE} all
		end
#endif
#ifdef VE
	FILE
		rename
			make as old_make,
			name as old_name,
			read_stream as old_read_stream,
			read_character as old_read_character,
			read_line as old_read_line,
			open_read as old_open_read,
			is_open_read as old_is_open_read,
			is_closed as old_is_closed,
			end_of_file as old_end_of_file,
			close as old_close,
			delete as old_delete
		export
			{NONE} all
		end
#endif

creation

	make

feature {NONE} -- Initialization

	make (a_name: like name) is
			-- Create a new binary input file named `a_name'.
		do
			name := a_name
#ifdef ISE || HACT
			if a_name.count > 0 then
				old_name := a_name
			else
				old_name := Empty_name
			end
			mode := Closed_file
#endif
#ifdef SE
			old_make
#endif
#ifdef VE
			if a_name.count > 0 then
				old_make (a_name)
			else
				old_make (Empty_name)
			end
#endif
			end_of_file := False
		end

feature -- Access

	name: STRING
			-- File name

#ifdef SE
	last_character: CHARACTER
			-- Last character read

	last_string: STRING
			-- Last string read
			-- (Note: this query always return the same object.
			-- Therefore a clone should be used if the result
			-- is to be kept beyond the next call to this feature.
			-- However `last_string' is not shared between file objects.)

#endif
feature -- Status report

	is_open_read: BOOLEAN is
			-- Is file opened in read mode?
		do
			Result := old_is_open_read
		end

	is_closed: BOOLEAN is
			-- Is file closed?
		do
#ifdef SE
			Result := not old_is_open_read
#else
			Result := old_is_closed
#endif
		end

	end_of_file: BOOLEAN
			-- Has the end of file been reached?

feature -- Input

	read_character is
			-- Read the next character in input file.
			-- Make the result available in `last_character'.
		do
			if character_buffer /= Void then
				last_character := character_buffer.item
				character_buffer := character_buffer.right
			elseif old_end_of_file then
				end_of_file := True
			else
				old_read_character
				end_of_file := old_end_of_file
#ifdef SE
				if not end_of_file then
					last_character := old_last_character
				end
#endif
			end
		end

	unread_character (a_character: CHARACTER) is
			-- Put `a_character' back in input file.
			-- This character will be read first by the next
			-- call to a read routine.
		local
			a_cell: like character_buffer
		do
			!! a_cell.make (a_character)
			if character_buffer /= Void then
				a_cell.put_right (character_buffer)
			end
			character_buffer := a_cell
			last_character := a_character
			end_of_file := False
		end

	read_string (nb: INTEGER) is
			-- Read at most `nb' characters from input stream.
			-- Make the characters that have actually been read
			-- available in `last_string'.
#ifdef ISE || HACT
		local
			i: INTEGER
		do
			if last_string = Void then
				!! last_string.make (nb)
			elseif last_string.capacity < nb then
				last_string.resize (nb)
			end
			if character_buffer = Void then
				if not old_end_of_file then
					old_read_stream (nb)
				else
					last_string.set_count (0)
				end
			else
				last_string.set_count (nb)
				i := read_to_string (last_string, 1, nb)
				last_string.set_count (i)
			end
#endif
#ifdef SE
		local
			i: INTEGER
			a_target: STRING
		do
			if last_string = Void then
				!! a_target.make (nb)
				last_string := a_target
			else
				a_target := last_string
				if a_target.capacity < nb then
					a_target.resize (nb)
				end
				a_target.clear
			end
			from i := nb until i < 1 loop
				read_character
				if not end_of_file then
					a_target.append_character (last_character)
					i := i - 1
				else
					i := 0 -- Jump out of the loop.
				end
			end
#endif
#ifdef VE
		local
			old_string: STRING
			i, j: INTEGER
			a_target: STRING
		do
			if character_buffer = Void then
				if not old_end_of_file then
					old_string := last_string
					old_read_stream (nb)
					if last_string = Void then
						if old_string /= Void then
							old_string.wipe_out
							last_string := old_string
						else
							!! last_string.make (0)
						end
					end
				elseif last_string = Void then
					!! last_string.make (0)
				else
					last_string.wipe_out
				end
			else
				if last_string = Void then
					!! last_string.make (nb)
				elseif last_string.count < nb then
					last_string.resize (nb)
				end
				i := read_to_string (last_string, 1, nb)
				last_string.resize (i)
			end
#endif
			end_of_file := (last_string.count = 0)
		end

#ifdef ISE
	read_to_string (a_string: STRING; pos, nb: INTEGER): INTEGER is
			-- Fill `a_string', starting at position `pos' with
			-- at most `nb' characters read from input file.
			-- Return the number of characters actually read.
		local
			str_area: ANY
			i, j: INTEGER
		do
			from
				j := pos
			until
				i = nb or
				character_buffer = Void
			loop
				i := i + 1
				a_string.put (character_buffer.item, j)
				character_buffer := character_buffer.right
				j := j + 1
			end
			if i < nb then
				if not old_end_of_file then
					str_area := a_string.area
					Result := i + file_gss (file_pointer, c_rtid ($str_area) + (j - 1), nb - i)
				else
					Result := i
				end
			end
		end

#endif
	read_to_buffer (a_buffer: KI_BUFFER [CHARACTER]; pos, nb: INTEGER): INTEGER is
			-- Fill `a_buffer', starting at position `pos', with
			-- at most `nb' characters read from input stream.
			-- Return the number of characters actually read.
		local
			char_buffer: KL_CHARACTER_BUFFER
		do
			char_buffer ?= a_buffer
			if char_buffer /= Void then
				Result := char_buffer.fill_from_stream (Current, pos, nb)
			else
				Result := precursor (a_buffer, pos, nb)
			end
		end

feature -- Basic operations

	open_read is
			-- Open current file in read-only mode if
			-- it can be opened, let it closed otherwise.
		local
			rescued: BOOLEAN
		do
			if not rescued then
				if name.count > 0 then
					character_buffer := Void
					end_of_file := False
#ifdef SE
					input_stream := basic_io_binary_file_read_open (name.to_external)
					if input_stream.is_not_null then
						push_back_flag := False
						memory := (' ').code
						path := name
					end
#else
					old_open_read
#endif
				end
			elseif not is_closed then
				close
			end
		rescue
			if not rescued then
				rescued := True
				retry
			end
		end

	close is
			-- Close current file if it is closable,
			-- let it open otherwise.
		local
			rescued: BOOLEAN
		do
			if not rescued then
				old_close
				character_buffer := Void
			end
		rescue
			if not rescued then
				rescued := True
				retry
			end
		end

	rename_file (new_name: STRING) is
			-- Rename current file as `new_name'.
			-- Do nothing if the file could not be renamed, if
			-- it did not exist or if `new_name' already existed.
			-- If renaming was successful, then `name' is set to
			-- `new_name'.
#ifndef SE
		local
			a_name: STRING
#endif
		do
			if new_name.count > 0 then
#ifdef SE
				if not file_exists (new_name) then
#else
				a_name := old_name
				old_name := new_name
				if exists then
					old_name := a_name
				else
					old_name := a_name
#endif
					file_system.rename_file (name, new_name)
#ifdef SE
					if file_exists (new_name) then
						name := new_name
#else
					a_name := old_name
					old_name := new_name
					if exists then
						name := new_name
					else
						old_name := a_name
#endif
					end
				end
			end
		end

	delete is
			-- Delete current file.
			-- Do nothing if the file could not be
			-- deleted or if it did not exist.
		local
			rescued: BOOLEAN
		do
			if not rescued then
				if name.count > 0 then
#ifdef SE
					old_delete (name)
#endif
#ifdef ISE || HACT || VE
					if exists then
						old_delete
					end
#endif
				end
			end
		rescue
			if not rescued then
				rescued := True
				retry
			end
		end

feature {NONE} -- Implementation

	character_buffer: KL_LINKABLE [CHARACTER]
			-- Unread characters

#ifdef SE
	basic_io_binary_file_read_open (path_pointer: POINTER): POINTER is
			-- Open file in binary read-only mode.
		external
			"SmallEiffel"
		end

#endif
#ifdef ISE || HACT
	file_readable: BOOLEAN is
			-- Is there a current item that may be read?
		do
			Result := is_open_read
		end

#ifdef ISE
	c_rtid (p: POINTER): POINTER is
			-- Return `p'
		external
			"C [macro <eif_macros.h>]"
		alias
			"/**/"
		end

#endif
#endif
#ifdef ISE || HACT || VE
	Empty_name: STRING is "empty_name"
			-- Empty name place-holder

#endif
end -- class KL_BINARY_INPUT_FILE
