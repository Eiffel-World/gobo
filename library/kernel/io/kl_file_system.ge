indexing

	description:

		"File systems"

	library:    "Gobo Eiffel Kernel Library"
	author:     "Eric Bezault <ericb@gobosoft.com>"
	copyright:  "Copyright (c) 2001, Eric Bezault and others"
	license:    "Eiffel Forum Freeware License v1 (see forum.txt)"
	date:       "$Date$"
	revision:   "$Revision$"

deferred class KL_FILE_SYSTEM

inherit

	KI_FILE_SYSTEM
#ifdef VE
		redefine
			make
		end
#endif

	KL_IMPORTED_STRING_ROUTINES
#ifdef SE
		rename
			rename_file as se_rename_file
#endif
		export
			{NONE} all
		end

	KL_SHARED_FILE_SYSTEM
#ifdef SE
		rename
			rename_file as se_rename_file
#endif
		export
			{NONE} all
		end

#ifdef VE
feature {NONE} -- Initialization

	make is
			-- Create a new file system object.
		do
--			ve_make
		end

#endif
feature -- Status report

	is_current_file_system: BOOLEAN is
			-- Is file system the file system of the underlying platform?
		do
			Result := same_type (file_system)
		end

feature -- File handling

	is_file_readable (a_filename: STRING): BOOLEAN is
			-- Can file named `a_filename' be opened in read mode?
			-- (`a_filename' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (a_filename)
			Result := tmp_file.is_readable
		end

	rename_file (old_name, new_name: STRING) is
			-- Rename file named `old_name' as `new_name'.
			-- Do nothing if the file could not be renamed, if
			-- it did not exist or if `new_name' already existed.
			-- (`old_name' and `new_name' should follow the pathname
			-- convention of the underlying platform. For pathname
			-- conversion use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (old_name)
			tmp_file.change_name (new_name)
		end

	copy_file (old_name, new_name: STRING) is
			-- Copy file named `old_name' to `new_name'.
			-- Do nothing if the file could not be copied, if it
			-- did not exist or if `new_name' already existed.
			-- (`old_name' and `new_name' should follow the pathname
			-- convention of the underlying platform. For pathname
			-- conversion use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (old_name)
			tmp_file.copy_file (new_name)
		end

	delete_file (a_filename: STRING) is
			-- Delete file named `a_filename'.
			-- Do nothing if the file could not be
			-- deleted or if it did not exist.
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (a_filename)
			tmp_file.delete
		end

feature -- Directory handling

	is_directory_readable (a_dirname: STRING): BOOLEAN is
			-- Can directory named `a_dirname' be opened in read mode?
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_directory.reset (a_dirname)
			Result := tmp_directory.is_readable
		end

	create_directory (a_dirname: STRING) is
			-- Create a new directory named `a_dirname'.
			-- Do nothing if the directory could not
			-- be created, if it already existed or if
			-- `a_dirname' is a nested directory name
			-- and the parent directory does not exist.
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_directory.reset (a_dirname)
			tmp_directory.create_directory
		end

	delete_directory (a_dirname: STRING) is
			-- Delete directory named `a_dirname'.
			-- Do nothing if the directory could not be deleted,
			-- if it did not exist or if it is not empty.
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_directory.reset (a_dirname)
			tmp_directory.delete
		end

feature -- Working directory

	cwd, current_working_directory: STRING is
			-- Name of current working directory;
			-- Return absolute pathname with the naming 
			-- convention of the underlying file system
			-- (Return a new object at each call.)
		do
#ifdef SE
			basic_directory.connect_to_current_working_directory
			Result := clone (basic_directory.last_entry)
			basic_directory.disconnect
#endif
#ifdef ISE || HACT
			Result := execution_environment.current_working_directory
#endif
#ifdef VE
			Result := file_system_impl.current_cluster
#endif
		end

	cd, set_current_working_directory (a_dirname: STRING) is
			-- Set current working directory to `a_dirname'.
			-- Do nothing if the current working directory could not
			-- be changed or if directory `a_dirname' did not exist.
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		local
			rescued: BOOLEAN
		do
			if not rescued then
				if a_dirname.count > 0 then
#ifdef SE
					basic_directory.change_current_working_directory (a_dirname)
#endif
#ifdef ISE || HACT
					execution_environment.change_working_directory (a_dirname)
#endif
#ifdef VE
					if file_system_impl.cluster_exists (a_dirname) then
						file_system_impl.change_cluster (a_dirname)
					end
#endif
				end
			end
		rescue
			if not rescued then
				rescued := True
				retry
			end
		end

feature {NONE} -- Implementation

	tmp_file: KL_TEXT_INPUT_FILE is
			-- Temporary file object
		once
			!! Result.make (dummy_name)
		ensure
			file_not_void: Result /= Void
			file_closed: Result.is_closed
		end

	tmp_directory: KL_DIRECTORY is
			-- Temporary directory object
		once
			!! Result.make (dummy_name)
		ensure
			directory_not_void: Result /= Void
			directory_closed: Result.is_closed
		end

	dummy_name: STRING is "dummy"
			-- Dummy name

#ifdef SE
	basic_directory: BASIC_DIRECTORY
			-- Implementation

#endif
#ifdef VE
	file_system_impl: FILE_SYSTEM is
			-- Implementation
		once
			!! Result.make
		ensure
			file_system_impl_not_void: Result /= Void
		end

#endif
#ifdef ISE || HACT
	execution_environment: EXECUTION_ENVIRONMENT is
			-- Execution environment implementation
		once
			!! Result
		ensure
			execution_environment_not_void: Result /= Void
		end

#endif
end -- class KL_FILE_SYSTEM
