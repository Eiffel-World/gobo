indexing

	description:

		"File systems"

	library:    "Gobo Eiffel Kernel Library"
	author:     "Eric Bezault <ericb@gobosoft.com>"
	copyright:  "Copyright (c) 2001, Eric Bezault and others"
	license:    "Eiffel Forum Freeware License v1 (see forum.txt)"
	date:       "$Date$"
	revision:   "$Revision$"

deferred class KL_FILE_SYSTEM

inherit

	KI_FILE_SYSTEM
#ifdef VE
		redefine
			make
		end
#endif

	KL_IMPORTED_STRING_ROUTINES
#ifdef SE
		rename
			rename_file as se_rename_file,
			file_exists as se_file_exists
#endif
		export
			{NONE} all
		end

	KL_SHARED_FILE_SYSTEM
#ifdef SE
		rename
			rename_file as se_rename_file,
			file_exists as se_file_exists
#endif
		export
			{NONE} all
		end

#ifdef HACT
	EXECUTION_ENVIRONMENT
		rename
			current_working_directory as old_current_working_directory
		export
			{NONE} all
		end

#endif
#ifdef VE
feature {NONE} -- Initialization

	make is
			-- Create a new file system object.
		do
		end

#endif
feature -- Status report

	is_current_file_system: BOOLEAN is
			-- Is file system the file system of the underlying platform?
		do
			Result := same_type (file_system)
		end

feature -- File handling

	is_file_readable (a_filename: STRING): BOOLEAN is
			-- Can file named `a_filename' be opened in read mode?
			-- (`a_filename' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (a_filename)
			Result := tmp_file.is_readable
		end

	file_exists (a_filename: STRING): BOOLEAN is
			-- Does file named `a_filename' physically exist on disk?
			-- (Note that with SmallEiffel this routine actually returns `is_readable'.)
			-- (`a_filename' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (a_filename)
			Result := tmp_file.exists
		end

	file_count (a_filename: STRING): INTEGER is
			-- Number of bytes in file named `a_filename';
			-- Return -1 if the number of bytes was not available,
			-- if the file did not exist for example.
			-- (`a_filename' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (a_filename)
			Result := tmp_file.count
		end

	file_time_stamp (a_filename: STRING): INTEGER is
			-- Time stamp (number of seconds since 1 January 1970
			-- at 00:00:00 UTC) of last modification to file `a_filename';
			-- Return -1 if the time stamp was not available, if the
			-- file did not exist for example, or if the time stamp
			-- didn't fit into an INTEGER. (Use DT_DATE_TIME.make_from_epoch
			-- to convert this time stamp to a human readable format.)
			-- (`a_filename' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (a_filename)
			Result := tmp_file.time_stamp
		end

	same_physical_file (a_filename1, a_filename2: STRING): BOOLEAN is
			-- Are files named `a_filename1' and `a_filename2'
			-- the same physical file? Return False if one 
			-- or both files don't exist. (Return True if
			-- it was impossible to determine whether the
			-- files were physically the same files.)
			-- (`a_filename1' and `a_filename2' should follow
			-- the pathname convention of the underlying
			-- platform. For pathname conversion use
			-- KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (a_filename1)
			Result := tmp_file.same_physical_file (a_filename2)
		end

	rename_file (old_name, new_name: STRING) is
			-- Rename file named `old_name' as `new_name'.
			-- Do nothing if the file could not be renamed, if
			-- it did not exist or if `new_name' is physically
			-- the same file as current file. Overwrite `new_name'
			-- if it already existed. (`old_name' and `new_name'
			-- should follow the pathname convention of the
			-- underlying platform. For pathname conversion use
			-- KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (old_name)
			tmp_file.change_name (new_name)
		end

	copy_file (old_name, new_name: STRING) is
			-- Copy file named `old_name' to `new_name'.
			-- Do nothing if the file could not be copied, if it
			-- did not exist or if `new_name' is physically
			-- the same file as `old_name'. Overwrite `new_name'
			-- if it already existed. (`old_name' and `new_name'
			-- should follow the pathname convention of the
			-- underlying platform. For pathname conversion use
			-- KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (old_name)
			tmp_file.copy_file (new_name)
		end

	delete_file (a_filename: STRING) is
			-- Delete file named `a_filename'.
			-- Do nothing if the file could not be
			-- deleted or if it did not exist.
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_file.reset (a_filename)
			tmp_file.delete
		end

feature -- Directory handling

	is_directory_readable (a_dirname: STRING): BOOLEAN is
			-- Can directory named `a_dirname' be opened in read mode?
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_directory.reset (a_dirname)
			Result := tmp_directory.is_readable
		end

	directory_exists (a_dirname: STRING): BOOLEAN is
			-- Does directory named `a_dirname' physically exist on disk?
			-- (Note that with SmallEiffel this routine actually returns `is_readable'.)
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_directory.reset (a_dirname)
			Result := tmp_directory.exists
		end

	create_directory (a_dirname: STRING) is
			-- Create a new directory named `a_dirname'.
			-- Do nothing if the directory could not
			-- be created, if it already existed or if
			-- `a_dirname' is a nested directory name
			-- and the parent directory does not exist.
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_directory.reset (a_dirname)
			tmp_directory.create_directory
		end

	recursive_create_directory (a_dirname: STRING) is
			-- Create a new directory named `a_dirname' on disk.
			-- Create its parent directories if they do not exist yet.
			-- Do nothing if the directory could not be created,
			-- if it already existed or `name' is a nested directory
			-- name and its parent directory does not exist and 
			-- could not be created.
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_directory.reset (a_dirname)
			tmp_directory.recursive_create_directory
		end

	delete_directory (a_dirname: STRING) is
			-- Delete directory named `a_dirname'.
			-- Do nothing if the directory could not be deleted,
			-- if it did not exist or if it is not empty.
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_directory.reset (a_dirname)
			tmp_directory.delete
		end

	recursive_delete_directory (a_dirname: STRING) is
			-- Delete directory named `a_dirname', its files
			-- and its subdirectories recursively. Do nothing if
			-- the directory could not be deleted, if it did not exist.
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		do
			tmp_directory.reset (a_dirname)
			tmp_directory.recursive_delete
		end

feature -- Working directory

	cwd, current_working_directory: STRING is
			-- Name of current working directory;
			-- Return absolute pathname with the naming 
			-- convention of the underlying file system
			-- (Return a new object at each call.)
		do
#ifdef SE
			basic_directory.connect_to_current_working_directory
			Result := clone (basic_directory.last_entry)
			basic_directory.disconnect
#endif
#ifdef ISE
			Result := execution_environment.current_working_directory
#endif
#ifdef HACT
			Result := dir_current
#endif
#ifdef VE
			Result := file_system_impl.current_cluster
#endif
		end

	cd, set_current_working_directory (a_dirname: STRING) is
			-- Set current working directory to `a_dirname'.
			-- Do nothing if the current working directory could not
			-- be changed or if directory `a_dirname' did not exist.
			-- (`a_dirname' should follow the pathname convention
			-- of the underlying platform. For pathname conversion
			-- use KI_FILE_SYSTEM.pathname_from_file_system.)
		local
			rescued: BOOLEAN
		do
			if not rescued then
				if a_dirname.count > 0 then
#ifdef SE
					basic_directory.change_current_working_directory (a_dirname)
#endif
#ifdef ISE || HACT
					execution_environment.change_working_directory (a_dirname)
#endif
#ifdef VE
					if file_system_impl.cluster_exists (a_dirname) then
						file_system_impl.change_cluster (a_dirname)
					end
#endif
				end
			end
		rescue
			if not rescued then
				rescued := True
				retry
			end
		end

feature {NONE} -- Implementation

	tmp_file: KL_TEXT_INPUT_FILE is
			-- Temporary file object
		once
			!! Result.make (dummy_name)
		ensure
			file_not_void: Result /= Void
			file_closed: Result.is_closed
		end

	tmp_directory: KL_DIRECTORY is
			-- Temporary directory object
		once
			!! Result.make (dummy_name)
		ensure
			directory_not_void: Result /= Void
			directory_closed: Result.is_closed
		end

	dummy_name: STRING is "dummy"
			-- Dummy name

#ifdef SE
	basic_directory: BASIC_DIRECTORY
			-- Implementation

#endif
#ifdef VE
	file_system_impl: FILE_SYSTEM is
			-- Implementation
		once
			!! Result.make
		ensure
			file_system_impl_not_void: Result /= Void
		end

#endif
#ifdef ISE || HACT
	execution_environment: EXECUTION_ENVIRONMENT is
			-- Execution environment implementation
		once
			!! Result
		ensure
			execution_environment_not_void: Result /= Void
		end

#endif
end -- class KL_FILE_SYSTEM
