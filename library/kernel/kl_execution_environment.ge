indexing

	description:

		"Execution environment facilities"

	library:    "Gobo Eiffel Kernel Library"
	author:     "Eric Bezault <ericb@gobo.demon.co.uk>"
	copyright:  "Copyright (c) 1997, Eric Bezault"
	date:       "$Date$"
	revision:   "$Revision$"

class KL_EXECUTION_ENVIRONMENT

feature -- Access

	variable_value (a_variable: STRING): STRING is
			-- Value of environment variable `a_variable';
			-- Void if `a_variable' has not been set
		require
			a_variable_not_void: a_variable /= Void
#ifdef VE
		local
			environment: expanded ENVIRONMENT
		do
			Result := environment.env_item (a_variable)
#else
#ifdef HACT
		local
			environment: expanded EXECUTION_ENVIRONMENT
		do
			Result := environment.get (a_variable)
#else
#ifdef TOWER
		local
			env_vars: expanded ENV_VARS
		do
			Result := env_vars.get (a_variable)
#else
#ifdef ISE
		local
			s: ANY
			c_string: POINTER
		do
			s := a_variable.to_c
			c_string := c_getenv ($s)
			if c_string /= default_pointer then
				!! Result.make (0)
				Result.from_c (c_string)
			end
#else
#ifdef SE
		do
			Result := get_environment_variable (a_variable)
#endif
#endif
#endif
#endif
#endif
		end

feature -- Setting

	set_variable_value (a_variable, a_value: STRING) is
			-- Set environment variable `a_variable' to `a_value'.
			-- (This setting may fail on certain platforms.)
		require
			a_variable_not_void: a_variable /= Void
			a_variable_not_empty: not a_variable.empty
			a_value_not_void: a_value /= Void
#ifdef VE
		local
			environment: expanded ENVIRONMENT
		do
			Result := environment.env_put (a_variable, a_value)
#else
#ifdef HACT
		local
			environment: expanded EXECUTION_ENVIRONMENT
		do
			Result := environment.put (a_value, a_variable)
#else
#ifdef TOWER
		local
			env_vars: expanded ENV_VARS
		do
			if env_vars.put_supported then
				Result := env_vars.put (a_variable, a_value)
			end
#else
#ifdef ISE
		local
			a_string: STRING
			s: ANY
			i: INTEGER
		do
			!! a_string.make (a_variable.count + a_value.count + 1)
			a_string.append_string (a_variable)
			a_string.append_character ('=')
			a_string.append_string (a_value)
			s := a_string.to_c
			i := c_putenv ($s)
#else
		do
			-- Not supported.
#endif
#endif
#endif
#endif
		ensure
			-- (This setting may fail on certain platforms, hence the
			-- following commented postcondition.)
			-- variable_set: equal (variable_value (a_variable), a_value)
		end

feature -- Conversion

	interpreted_string (a_string: STRING): STRING is
			-- String where the environment variables have been
			-- replaced by their values. The environment variables
			-- are considered to be either ${.*} or $[a-zA-Z0-9_]
			-- and the dollar sign is escaped using $$. Non defined
			-- environment variables are replaced by empty strings.
			-- The result is not defined when `a_string' does not
			-- conform to the conventions above.
			-- Return a new string each time.
		require
			a_string_not_void: a_string /= Void
		local
			s1: STRING
			i, j: INTEGER
			stop : BOOLEAN
		do
			from
				Result := clone (a_string)
				i := 1
			until
				i > Result.count
			loop
				if Result.item (i) = '$' then
						-- Found beginning of a environment variable
						-- It is either ${VAR} or $VAR.
					if i > 1 then
						s1 := Result.substring (1, i - 1)
					else
						!! s1.make (0)
					end
					i := i + 1
					inspect Result.item (i)
					when '{' then
							-- Looking for a right brace.
						from
							i := i + 1
							j := i
						until
							j > Result.count or else Result.item (j) = '}'
						loop
							j := j + 1
						end
						if j > Result.count then
							j := Result.count
						end
					when '$' then
						j := i
					else
							-- Looking for a non-alphanumeric character
							-- (i.e. [^a-zA-Z0-9_]).
						from
							j := i
							stop := False
						until
							j > Result.count or else stop
						loop
							inspect Result.item (j)
							when 'a'..'z', 'A'..'Z', '0'..'9', '_' then
								j := j + 1
							else
								stop := True
							end
						end
							-- We've been one char too far.
						j := j - 1
					end
					check
						j_large_enough: j >= i
						j_small_enough: j <= Result.count
					end
					if Result.item (j) = '$' then
						s1.append_character ('$')
					elseif Result.item (j) = '}' then
						if j - 1 >= i then
							s1.append_string
								(variable_value (Result.substring (i, j - 1)))
						end
					elseif j >= i then
						s1.append_string
							(variable_value (Result.substring (i, j)))
					end
					i := s1.count + 1
					if j < Result.count then
						s1.append (Result.substring (j + 1, Result.count))
					end
					Result := s1
				end
				i := i + 1
			end
		ensure
			interpreted_string_not_void: Result /= Void
		end

#ifdef ISE
feature {NONE} -- Externals

	c_getenv (s: POINTER): POINTER is
		external
			"C [macro <eiffel.h>]"
		alias
			"getenv"
		end

	c_putenv (s: POINTER): INTEGER is
		external
			"C [macro <eiffel.h>]"
		alias
			"putenv"
		end

#endif
end -- class KL_EXECUTION_ENVIRONMENT
