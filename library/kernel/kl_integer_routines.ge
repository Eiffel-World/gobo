indexing

	description:

		"Routines that ought to be in class INTEGER"

	library:		"Gobo Eiffel Kernel Library"
	author:		"Eric Bezault <ericb@gobosoft.com>"
	copyright:	"Copyright (c) 1999, Eric Bezault and others"
	license:		"Eiffel Forum Freeware License v1 (see forum.txt)"
	date:			"$Date$"
	revision:	"$Revision$"

class KL_INTEGER_ROUTINES

inherit

	KL_SHARED_PLATFORM
	KL_IMPORTED_STRING_ROUTINES

feature -- Conversion

	to_character (an_int: INTEGER): CHARACTER is
			-- Character whose ASCII code is `an_int'
		require
			a_int_large_enough: an_int >= Platform.Minimum_character_code
			a_int_small_enough: an_int <= Platform.Maximum_character_code
		do
#ifdef VE
			Result.from_integer (an_int)
#else
#ifdef ISE || HACT
			Result := '%U' + an_int
#else
			Result := an_int.to_character
#endif
#endif
		ensure
			valid_character_code: Result.code = an_int
		end

	to_hexadecimal (an_int: INTEGER; uppercase: BOOLEAN): STRING is
			-- Hexadecimal representation of `an_int' to `a_string'.
			-- Return a new string at each call.
			-- Regexp:
			--		uppercase:		0|[1-9A-F][0-9A-F]*
			--		not uppercase:	0|[1-9a-f][0-9a-f]*
		require
			an_int_positive: an_int >= 0
		do
			Result := STRING_.make (10)
			append_hexadecimal_integer (Result, an_int, uppercase)
		ensure
			hexadecimal_not_void: Result /= Void
		end

feature -- Output

	append_hexadecimal_integer (a_string: STRING; an_int: INTEGER; uppercase: BOOLEAN) is
			-- Append a hexadecimal representation of `an_int' to `a_string'.
			-- Regexp:
			--		uppercase:		0|[1-9A-F][0-9A-F]*
			--		not uppercase:	0|[1-9a-f][0-9a-f]*
		require
			a_string_not_void: a_string /= Void
			an_int_positive: an_int >= 0
		local
			j, k, i, nb: INTEGER
			c: CHARACTER
		do
			if an_int = 0 then
				a_string.append_character ('0')
			else
				from k := an_int until k = 0 loop
					inspect k \\ 16
					when 0 then
						a_string.append_character ('0')
					when 1 then
						a_string.append_character ('1')
					when 2 then
						a_string.append_character ('2')
					when 3 then
						a_string.append_character ('3')
					when 4 then
						a_string.append_character ('4')
					when 5 then
						a_string.append_character ('5')
					when 6 then
						a_string.append_character ('6')
					when 7 then
						a_string.append_character ('7')
					when 8 then
						a_string.append_character ('8')
					when 9 then
						a_string.append_character ('9')
					when 10 then
						if uppercase then
							a_string.append_character ('A')
						else
							a_string.append_character ('a')
						end
					when 11 then
						if uppercase then
							a_string.append_character ('B')
						else
							a_string.append_character ('b')
						end
					when 12 then
						if uppercase then
							a_string.append_character ('C')
						else
							a_string.append_character ('c')
						end
					when 13 then
						if uppercase then
							a_string.append_character ('D')
						else
							a_string.append_character ('d')
						end
					when 14 then
						if uppercase then
							a_string.append_character ('E')
						else
							a_string.append_character ('e')
						end
					when 15 then
						if uppercase then
							a_string.append_character ('F')
						else
							a_string.append_character ('f')
						end
					end
					k := k // 16
					nb := nb + 1
				end
				from
					j := a_string.count
					i := j - nb + 1
				until
					i >= j
				loop
					c := a_string.item (i)
					a_string.put (a_string.item (j), i)
					a_string.put (c, j)
					i := i + 1
					j := j - 1
				end
			end
		end

feature -- Tests

	even (an_int: INTEGER): BOOLEAN is
		do
#ifdef SE
			Result := an_int.even
			Result := an_int \\ 2 = 0
#endif
		end

end -- class KL_INTEGER_ROUTINES
